// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: `${string}://${string}/publishers/seren-db` | (string & {});
};

/**
 * Request to add an IP to the allow list
 */
export type AddIpAllowListRequest = {
    /**
     * Optional description for this IP entry
     */
    description?: string | null;
    /**
     * IP address or CIDR range (e.g., "192.168.1.0/24" or "10.0.0.1")
     */
    ip_address: string;
};

export type AssignProjectVpcEndpointRequest = {
    label?: string | null;
    vpc_endpoint_id: string;
};

/**
 * Branch represents a SerenDB timeline (database copy)
 */
export type Branch = {
    archived: boolean;
    created_at: string;
    created_by: string;
    deleted_at?: string | null;
    deleted_by?: string | null;
    expires_at?: string | null;
    id: string;
    init_source?: string | null;
    /**
     * Computed field: true if this branch is the project's default branch.
     * Not stored in DB - computed by comparing branch.id with project.default_branch_id.
     */
    is_default?: boolean;
    last_reset_at?: string | null;
    logical_size_bytes?: number;
    name: string;
    parent_branch_id?: string | null;
    parent_lsn?: string | null;
    parent_timestamp?: string | null;
    physical_size_bytes?: number;
    project_id: string;
    protected: boolean;
    timeline_id: string;
    updated_at: string;
};

/**
 * Response after creating a branch
 */
export type BranchCreated = {
    archived: boolean;
    created_at: string;
    id: string;
    init_source?: string | null;
    /**
     * True if this is the project's default branch
     */
    is_default?: boolean;
    logical_size_bytes?: number;
    name: string;
    parent_branch_id?: string | null;
    parent_lsn?: string | null;
    parent_timestamp?: string | null;
    physical_size_bytes?: number;
    project_id: string;
    protected: boolean;
    timeline_id: string;
};

/**
 * Response wrapper returned when branch creation provisions auxiliary resources
 */
export type BranchCreationResult = {
    branch: BranchCreated;
    /**
     * Error message if endpoint provisioning failed.
     * When present, the branch was created successfully but the endpoint failed.
     * The UI should show a "Retry" or "Add Compute" button.
     */
    endpoint_error?: string | null;
    endpoints?: Array<EndpointCreated> | null;
};

/**
 * Response for branch detail information
 */
export type BranchDetail = {
    ancestor_lsn?: string | null;
    ancestor_timeline_id?: string | null;
    branch_id: string;
    current_logical_size?: number | null;
    disk_consistent_lsn: string;
    last_record_lsn: string;
    prev_record_lsn?: string | null;
    remote_consistent_lsn?: string | null;
    state: string;
    timeline_id: string;
};

export type BranchEndpointRequest = {
    endpoint_type?: string | null;
    settings?: unknown;
};

/**
 * Branch protection response (API output)
 */
export type BranchProtection = {
    allowed_bypass_roles: Array<string>;
    branch_id: string;
    created_at: string;
    id: string;
    prevent_deletion: boolean;
    prevent_reset: boolean;
    project_id: string;
    require_approval_for_changes: boolean;
    updated_at: string;
};

/**
 * Response after restoring a branch
 */
export type BranchRestored = {
    /**
     * The backup branch containing the pre-restore state
     */
    backup_branch: Branch;
    /**
     * The restored branch
     */
    branch: Branch;
};

/**
 * Response for a single, canonical connection string.
 *
 * The backend always prefers SerenDB proxy-based connection strings when
 * proxy configuration is available, and falls back to direct compute
 * connection strings only when the proxy is not configured.
 */
export type ConnectionString = {
    /**
     * Fully resolved PostgreSQL connection string (proxy preferred).
     */
    connection_string: string;
};

/**
 * ConsumptionPeriodData for API responses (simplified)
 */
export type ConsumptionPeriodData = {
    active_time_seconds?: number;
    compute_time_seconds?: number;
    data_transfer_bytes?: number;
    period_id: string;
    synthetic_storage_size_bytes?: number;
    written_data_bytes?: number;
};

/**
 * ConsumptionSummary represents aggregated usage for a period
 */
export type ConsumptionSummary = {
    active_time_seconds?: number;
    compute_time_seconds?: number;
    data_transfer_bytes?: number;
    synthetic_storage_size_bytes?: number;
    written_data_bytes?: number;
};

/**
 * Request to create or update branch protection
 */
export type CreateBranchProtectionRequest = {
    allowed_bypass_roles?: Array<string>;
    prevent_deletion?: boolean;
    prevent_reset?: boolean;
    require_approval_for_changes?: boolean;
};

/**
 * Request to create a new branch
 */
export type CreateBranchRequest = {
    /**
     * Whether to automatically create an endpoint for this branch.
     * Defaults to true.
     * Set to false to create a branch without compute (equivalent to --no-compute).
     */
    add_endpoint?: boolean;
    archived?: boolean | null;
    endpoints?: Array<BranchEndpointRequest>;
    /**
     * Optional expiration timestamp for auto-deletion of this branch.
     * Useful for temporary dev/preview branches.
     */
    expires_at?: string | null;
    init_source?: string | null;
    name: string;
    parent_branch_id?: string | null;
    parent_lsn?: string | null;
    parent_timestamp?: string | null;
    protected?: boolean | null;
    /**
     * Create branch with schema only (no data).
     * When true, only the database schema is copied, not the data.
     */
    schema_only?: boolean;
};

/**
 * Request to create a new database
 */
export type CreateDatabaseRequest = {
    name: string;
    owner_name?: string | null;
};

/**
 * Request to create a new PostgreSQL database role
 */
export type CreateDbRoleRequest = {
    name: string;
};

/**
 * Request to create a new endpoint
 */
export type CreateEndpointRequest = {
    autoscaling_max?: number;
    autoscaling_min?: number;
    compute_unit?: string;
    /**
     * Type of endpoint: read_write (default) or read_only (replica)
     */
    endpoint_type?: EndpointType;
    /**
     * Optional name for the endpoint. If not provided, a name will be auto-generated.
     */
    name?: string;
    pooler_enabled?: boolean;
    pooler_mode?: PoolerMode;
    suspend_timeout_seconds?: number;
};

/**
 * Request to create a new project
 */
export type CreateProjectRequest = {
    block_public_connections?: boolean | null;
    block_vpc_connections?: boolean | null;
    compute_unit_max?: number | null;
    compute_unit_min?: number | null;
    /**
     * Enable logical replication for this project. Sets wal_level=logical for all compute endpoints.
     * Once enabled, this cannot be disabled.
     */
    enable_logical_replication?: boolean | null;
    hipaa?: boolean | null;
    name: string;
    protected_branches_only?: boolean | null;
    region: string;
};

/**
 * Request to create a publication
 */
export type CreatePublicationRequest = {
    name: string;
    publish_delete?: boolean;
    publish_insert?: boolean;
    publish_truncate?: boolean;
    publish_update?: boolean;
    /**
     * Tables to include (empty/null means ALL TABLES)
     */
    tables?: Array<string>;
};

/**
 * Request to create a replication slot
 */
export type CreateReplicationSlotRequest = {
    name: string;
    /**
     * Plugin for logical slots (default: pgoutput)
     */
    plugin?: string;
    /**
     * Slot type: logical or physical (default: logical)
     */
    slot_type?: string;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseBranch = {
    /**
     * Branch represents a SerenDB timeline (database copy)
     */
    data: {
        archived: boolean;
        created_at: string;
        created_by: string;
        deleted_at?: string | null;
        deleted_by?: string | null;
        expires_at?: string | null;
        id: string;
        init_source?: string | null;
        /**
         * Computed field: true if this branch is the project's default branch.
         * Not stored in DB - computed by comparing branch.id with project.default_branch_id.
         */
        is_default?: boolean;
        last_reset_at?: string | null;
        logical_size_bytes?: number;
        name: string;
        parent_branch_id?: string | null;
        parent_lsn?: string | null;
        parent_timestamp?: string | null;
        physical_size_bytes?: number;
        project_id: string;
        protected: boolean;
        timeline_id: string;
        updated_at: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseBranchCreationResult = {
    /**
     * Response wrapper returned when branch creation provisions auxiliary resources
     */
    data: {
        branch: BranchCreated;
        /**
         * Error message if endpoint provisioning failed.
         * When present, the branch was created successfully but the endpoint failed.
         * The UI should show a "Retry" or "Add Compute" button.
         */
        endpoint_error?: string | null;
        endpoints?: Array<EndpointCreated> | null;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseBranchDetail = {
    /**
     * Response for branch detail information
     */
    data: {
        ancestor_lsn?: string | null;
        ancestor_timeline_id?: string | null;
        branch_id: string;
        current_logical_size?: number | null;
        disk_consistent_lsn: string;
        last_record_lsn: string;
        prev_record_lsn?: string | null;
        remote_consistent_lsn?: string | null;
        state: string;
        timeline_id: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseBranchProtection = {
    /**
     * Branch protection response (API output)
     */
    data: {
        allowed_bypass_roles: Array<string>;
        branch_id: string;
        created_at: string;
        id: string;
        prevent_deletion: boolean;
        prevent_reset: boolean;
        project_id: string;
        require_approval_for_changes: boolean;
        updated_at: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseBranchRestored = {
    /**
     * Response after restoring a branch
     */
    data: {
        /**
         * The backup branch containing the pre-restore state
         */
        backup_branch: Branch;
        /**
         * The restored branch
         */
        branch: Branch;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseConnectionString = {
    /**
     * Response for a single, canonical connection string.
     *
     * The backend always prefers SerenDB proxy-based connection strings when
     * proxy configuration is available, and falls back to direct compute
     * connection strings only when the proxy is not configured.
     */
    data: {
        /**
         * Fully resolved PostgreSQL connection string (proxy preferred).
         */
        connection_string: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseDatabaseCreated = {
    /**
     * Response after creating a database
     */
    data: {
        branch_id: string;
        created_at: string;
        id: string;
        name: string;
        owner_role_id?: string | null;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseDatabaseWithOwner = {
    /**
     * Database with owner role name included
     */
    data: {
        branch_id: string;
        created_at: string;
        id: string;
        name: string;
        owner_name?: string | null;
        updated_at: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseEndpoint = {
    /**
     * Endpoint represents a compute instance for a branch
     */
    data: {
        active_time_seconds?: number;
        autoscaling_max: number;
        autoscaling_min: number;
        branch_id: string;
        compute_unit: string;
        connection_count?: number;
        connection_string?: string | null;
        connection_string_direct?: string | null;
        connection_string_pooled?: string | null;
        created_at: string;
        created_by: string;
        current_state?: string | null;
        /**
         * Type of endpoint: read_write (primary) or read_only (replica)
         */
        endpoint_type: string;
        id: string;
        last_active_at?: string | null;
        name: string;
        pooler_enabled: boolean;
        pooler_mode: string;
        /**
         * Reference to the primary endpoint for read replicas (NULL for read_write endpoints)
         */
        primary_endpoint_id?: string | null;
        proxy_host?: string | null;
        status: string;
        suspend_timeout_seconds: number;
        tenant_id: string;
        timeline_id: string;
        updated_at: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseEndpointCreated = {
    /**
     * Response after creating an endpoint
     */
    data: {
        branch_id: string;
        compute_unit: string;
        connection_string?: string | null;
        connection_string_direct?: string | null;
        connection_string_pooled?: string | null;
        created_at: string;
        /**
         * Type of endpoint: read_write (primary) or read_only (replica)
         */
        endpoint_type: string;
        id: string;
        internal_http_address?: string | null;
        name: string;
        pg_address?: string | null;
        /**
         * Reference to the primary endpoint for read replicas
         */
        primary_endpoint_id?: string | null;
        status: string;
        warnings?: Array<string> | null;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseEndpointStatusInfo = {
    /**
     * Status response used by lifecycle endpoints
     */
    data: {
        compute_status?: string | null;
        id: string;
        k8s_ready: boolean;
        status: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseIpAllowList = {
    /**
     * IP allow list entry for project-level access control
     */
    data: {
        created_at: string;
        created_by: string;
        description?: string | null;
        id: string;
        /**
         * IP address or CIDR range (stored as PostgreSQL CIDR type)
         */
        ip_address: string;
        project_id: string;
        updated_at: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseLogicalReplicationSettings = {
    /**
     * Project logical replication settings
     */
    data: {
        enabled: boolean;
        project_id: string;
        publications_count: number;
        slots_count: number;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseLsnByTimestamp = {
    /**
     * Response for LSN by timestamp query
     */
    data: {
        lsn: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseProject = {
    /**
     * Project represents a SerenDB database instance
     */
    data: {
        active_time_seconds?: number;
        block_public_connections: boolean;
        block_vpc_connections: boolean;
        branch_count?: number;
        compute_last_active_at?: string | null;
        compute_unit_max: number;
        compute_unit_min: number;
        created_at: string;
        created_by: string;
        default_branch_id?: string | null;
        default_compute_size_max?: number;
        default_compute_size_min?: number;
        deleted_at?: string | null;
        deleted_by?: string | null;
        enable_logical_replication?: boolean;
        hipaa: boolean;
        history_retention_seconds?: number;
        id: string;
        /**
         * Whether this is a service project (hidden from normal listings, contains seren_* databases)
         */
        is_service_project?: boolean;
        name: string;
        organization_id: string;
        postgres_version?: string;
        protected_branches_only: boolean;
        region: string;
        storage_bytes?: number;
        tenant_id: string;
        updated_at: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseProjectConnectionUri = {
    data: {
        uri: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseProjectConsumption = {
    /**
     * ProjectConsumption wraps consumption data for API responses
     */
    data: {
        current_month: ConsumptionSummary;
        from: string;
        periods: Array<ConsumptionPeriodData>;
        project_id: string;
        to: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseProjectCreated = {
    /**
     * Response after creating a project
     */
    data: {
        block_public_connections: boolean;
        block_vpc_connections: boolean;
        branch_count?: number;
        compute_unit_max: number;
        compute_unit_min: number;
        created_at: string;
        /**
         * The main branch for this project
         */
        default_branch_id?: string | null;
        /**
         * Whether logical replication is enabled for this project
         */
        enable_logical_replication?: boolean;
        hipaa: boolean;
        id: string;
        /**
         * Whether this is a service project (hidden from normal listings, contains seren_* databases)
         */
        is_service_project?: boolean;
        name: string;
        organization_id: string;
        postgres_version?: string;
        protected_branches_only: boolean;
        region: string;
        storage_bytes?: number;
        tenant_id: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseProjectSize = {
    /**
     * Response for project storage size
     */
    data: {
        project_id: string;
        size_bytes: number;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponsePublicationInfo = {
    /**
     * Publication response (API output)
     */
    data: {
        branch_id: string;
        created_at: string;
        id: string;
        name: string;
        project_id: string;
        publish_delete: boolean;
        publish_insert: boolean;
        publish_truncate: boolean;
        publish_update: boolean;
        /**
         * Tables to replicate (empty means ALL TABLES)
         */
        tables: Array<string>;
        updated_at: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseQueryResult = {
    /**
     * Query result returned to the caller.
     */
    data: {
        columns: Array<string>;
        row_count: number;
        rows: Array<Array<unknown>>;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseReplicationSlotInfo = {
    /**
     * Replication slot response (API output)
     */
    data: {
        active_pid?: number | null;
        branch_id: string;
        confirmed_flush_lsn?: string | null;
        created_at: string;
        id: string;
        name: string;
        plugin: string;
        project_id: string;
        restart_lsn?: string | null;
        slot_type: string;
        status: string;
        updated_at: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseRoleCreated = {
    /**
     * Response after creating a role
     */
    data: {
        branch_id: string;
        created_at: string;
        id: string;
        name: string;
        password: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseRolePasswordReset = {
    /**
     * Response after resetting password
     */
    data: {
        password: string;
        role_id: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseTimestampByLsn = {
    /**
     * Response for timestamp by LSN query
     */
    data: {
        timestamp: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseValue = {
    data: unknown;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecBranch = {
    data: Array<{
        archived: boolean;
        created_at: string;
        created_by: string;
        deleted_at?: string | null;
        deleted_by?: string | null;
        expires_at?: string | null;
        id: string;
        init_source?: string | null;
        /**
         * Computed field: true if this branch is the project's default branch.
         * Not stored in DB - computed by comparing branch.id with project.default_branch_id.
         */
        is_default?: boolean;
        last_reset_at?: string | null;
        logical_size_bytes?: number;
        name: string;
        parent_branch_id?: string | null;
        parent_lsn?: string | null;
        parent_timestamp?: string | null;
        physical_size_bytes?: number;
        project_id: string;
        protected: boolean;
        timeline_id: string;
        updated_at: string;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecBranchProtection = {
    data: Array<{
        allowed_bypass_roles: Array<string>;
        branch_id: string;
        created_at: string;
        id: string;
        prevent_deletion: boolean;
        prevent_reset: boolean;
        project_id: string;
        require_approval_for_changes: boolean;
        updated_at: string;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecDatabaseWithOwner = {
    data: Array<{
        branch_id: string;
        created_at: string;
        id: string;
        name: string;
        owner_name?: string | null;
        updated_at: string;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecEndpoint = {
    data: Array<{
        active_time_seconds?: number;
        autoscaling_max: number;
        autoscaling_min: number;
        branch_id: string;
        compute_unit: string;
        connection_count?: number;
        connection_string?: string | null;
        connection_string_direct?: string | null;
        connection_string_pooled?: string | null;
        created_at: string;
        created_by: string;
        current_state?: string | null;
        /**
         * Type of endpoint: read_write (primary) or read_only (replica)
         */
        endpoint_type: string;
        id: string;
        last_active_at?: string | null;
        name: string;
        pooler_enabled: boolean;
        pooler_mode: string;
        /**
         * Reference to the primary endpoint for read replicas (NULL for read_write endpoints)
         */
        primary_endpoint_id?: string | null;
        proxy_host?: string | null;
        status: string;
        suspend_timeout_seconds: number;
        tenant_id: string;
        timeline_id: string;
        updated_at: string;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecIpAllowList = {
    data: Array<{
        created_at: string;
        created_by: string;
        description?: string | null;
        id: string;
        /**
         * IP address or CIDR range (stored as PostgreSQL CIDR type)
         */
        ip_address: string;
        project_id: string;
        updated_at: string;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecProject = {
    data: Array<{
        active_time_seconds?: number;
        block_public_connections: boolean;
        block_vpc_connections: boolean;
        branch_count?: number;
        compute_last_active_at?: string | null;
        compute_unit_max: number;
        compute_unit_min: number;
        created_at: string;
        created_by: string;
        default_branch_id?: string | null;
        default_compute_size_max?: number;
        default_compute_size_min?: number;
        deleted_at?: string | null;
        deleted_by?: string | null;
        enable_logical_replication?: boolean;
        hipaa: boolean;
        history_retention_seconds?: number;
        id: string;
        /**
         * Whether this is a service project (hidden from normal listings, contains seren_* databases)
         */
        is_service_project?: boolean;
        name: string;
        organization_id: string;
        postgres_version?: string;
        protected_branches_only: boolean;
        region: string;
        storage_bytes?: number;
        tenant_id: string;
        updated_at: string;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecPublicationInfo = {
    data: Array<{
        branch_id: string;
        created_at: string;
        id: string;
        name: string;
        project_id: string;
        publish_delete: boolean;
        publish_insert: boolean;
        publish_truncate: boolean;
        publish_update: boolean;
        /**
         * Tables to replicate (empty means ALL TABLES)
         */
        tables: Array<string>;
        updated_at: string;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecReplicationSlotInfo = {
    data: Array<{
        active_pid?: number | null;
        branch_id: string;
        confirmed_flush_lsn?: string | null;
        created_at: string;
        id: string;
        name: string;
        plugin: string;
        project_id: string;
        restart_lsn?: string | null;
        slot_type: string;
        status: string;
        updated_at: string;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecRoleInfo = {
    data: Array<{
        branch_id: string;
        created_at: string;
        id: string;
        name: string;
        protected: boolean;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Response after creating a database
 */
export type DatabaseCreated = {
    branch_id: string;
    created_at: string;
    id: string;
    name: string;
    owner_role_id?: string | null;
};

/**
 * Database with owner role name included
 */
export type DatabaseWithOwner = {
    branch_id: string;
    created_at: string;
    id: string;
    name: string;
    owner_name?: string | null;
    updated_at: string;
};

/**
 * Endpoint represents a compute instance for a branch
 */
export type Endpoint = {
    active_time_seconds?: number;
    autoscaling_max: number;
    autoscaling_min: number;
    branch_id: string;
    compute_unit: string;
    connection_count?: number;
    connection_string?: string | null;
    connection_string_direct?: string | null;
    connection_string_pooled?: string | null;
    created_at: string;
    created_by: string;
    current_state?: string | null;
    /**
     * Type of endpoint: read_write (primary) or read_only (replica)
     */
    endpoint_type: string;
    id: string;
    last_active_at?: string | null;
    name: string;
    pooler_enabled: boolean;
    pooler_mode: string;
    /**
     * Reference to the primary endpoint for read replicas (NULL for read_write endpoints)
     */
    primary_endpoint_id?: string | null;
    proxy_host?: string | null;
    status: string;
    suspend_timeout_seconds: number;
    tenant_id: string;
    timeline_id: string;
    updated_at: string;
};

/**
 * Response after creating an endpoint
 */
export type EndpointCreated = {
    branch_id: string;
    compute_unit: string;
    connection_string?: string | null;
    connection_string_direct?: string | null;
    connection_string_pooled?: string | null;
    created_at: string;
    /**
     * Type of endpoint: read_write (primary) or read_only (replica)
     */
    endpoint_type: string;
    id: string;
    internal_http_address?: string | null;
    name: string;
    pg_address?: string | null;
    /**
     * Reference to the primary endpoint for read replicas
     */
    primary_endpoint_id?: string | null;
    status: string;
    warnings?: Array<string> | null;
};

/**
 * Status response used by lifecycle endpoints
 */
export type EndpointStatusInfo = {
    compute_status?: string | null;
    id: string;
    k8s_ready: boolean;
    status: string;
};

/**
 * Endpoint type enum - distinguishes between primary and replica endpoints
 */
export type EndpointType = 'read_write' | 'read_only';

/**
 * IP allow list entry for project-level access control
 */
export type IpAllowList = {
    created_at: string;
    created_by: string;
    description?: string | null;
    id: string;
    /**
     * IP address or CIDR range (stored as PostgreSQL CIDR type)
     */
    ip_address: string;
    project_id: string;
    updated_at: string;
};

/**
 * Project logical replication settings
 */
export type LogicalReplicationSettings = {
    enabled: boolean;
    project_id: string;
    publications_count: number;
    slots_count: number;
};

/**
 * Response for LSN by timestamp query
 */
export type LsnByTimestamp = {
    lsn: string;
};

/**
 * Pagination metadata included in responses.
 */
export type PaginationMeta = {
    /**
     * Number of items in this response
     */
    count: number;
    /**
     * Whether there are more items after this page
     */
    has_more: boolean;
    /**
     * Maximum items per page
     */
    limit: number;
    /**
     * Offset from start
     */
    offset: number;
    /**
     * Total number of items across all pages
     */
    total: number;
};

/**
 * Point in time specification (timestamp or LSN)
 */
export type PointInTime = {
    timestamp: string;
} | {
    lsn: string;
};

/**
 * Pooler mode enum
 */
export type PoolerMode = 'transaction' | 'session';

/**
 * Project represents a SerenDB database instance
 */
export type Project = {
    active_time_seconds?: number;
    block_public_connections: boolean;
    block_vpc_connections: boolean;
    branch_count?: number;
    compute_last_active_at?: string | null;
    compute_unit_max: number;
    compute_unit_min: number;
    created_at: string;
    created_by: string;
    default_branch_id?: string | null;
    default_compute_size_max?: number;
    default_compute_size_min?: number;
    deleted_at?: string | null;
    deleted_by?: string | null;
    enable_logical_replication?: boolean;
    hipaa: boolean;
    history_retention_seconds?: number;
    id: string;
    /**
     * Whether this is a service project (hidden from normal listings, contains seren_* databases)
     */
    is_service_project?: boolean;
    name: string;
    organization_id: string;
    postgres_version?: string;
    protected_branches_only: boolean;
    region: string;
    storage_bytes?: number;
    tenant_id: string;
    updated_at: string;
};

export type ProjectConnectionUri = {
    uri: string;
};

/**
 * ProjectConsumption wraps consumption data for API responses
 */
export type ProjectConsumption = {
    current_month: ConsumptionSummary;
    from: string;
    periods: Array<ConsumptionPeriodData>;
    project_id: string;
    to: string;
};

/**
 * Response after creating a project
 */
export type ProjectCreated = {
    block_public_connections: boolean;
    block_vpc_connections: boolean;
    branch_count?: number;
    compute_unit_max: number;
    compute_unit_min: number;
    created_at: string;
    /**
     * The main branch for this project
     */
    default_branch_id?: string | null;
    /**
     * Whether logical replication is enabled for this project
     */
    enable_logical_replication?: boolean;
    hipaa: boolean;
    id: string;
    /**
     * Whether this is a service project (hidden from normal listings, contains seren_* databases)
     */
    is_service_project?: boolean;
    name: string;
    organization_id: string;
    postgres_version?: string;
    protected_branches_only: boolean;
    region: string;
    storage_bytes?: number;
    tenant_id: string;
};

/**
 * Response for project storage size
 */
export type ProjectSize = {
    project_id: string;
    size_bytes: number;
};

/**
 * Publication response (API output)
 */
export type PublicationInfo = {
    branch_id: string;
    created_at: string;
    id: string;
    name: string;
    project_id: string;
    publish_delete: boolean;
    publish_insert: boolean;
    publish_truncate: boolean;
    publish_update: boolean;
    /**
     * Tables to replicate (empty means ALL TABLES)
     */
    tables: Array<string>;
    updated_at: string;
};

/**
 * JSON body for the query endpoint.
 */
export type QueryRequest = {
    /**
     * Branch ID (uses default branch if omitted)
     */
    branch_id?: string | null;
    /**
     * Target database name (defaults to "serendb")
     */
    database?: string;
    /**
     * Project ID (required)
     */
    project_id: string;
    /**
     * SQL query to execute
     */
    query: string;
    /**
     * Execute query in a read-only transaction (defaults to true).
     */
    read_only?: boolean;
};

/**
 * Query result returned to the caller.
 */
export type QueryResult = {
    columns: Array<string>;
    row_count: number;
    rows: Array<Array<unknown>>;
};

/**
 * Request to rename a branch
 */
export type RenameBranchRequest = {
    name: string;
};

/**
 * Replication slot response (API output)
 */
export type ReplicationSlotInfo = {
    active_pid?: number | null;
    branch_id: string;
    confirmed_flush_lsn?: string | null;
    created_at: string;
    id: string;
    name: string;
    plugin: string;
    project_id: string;
    restart_lsn?: string | null;
    slot_type: string;
    status: string;
    updated_at: string;
};

/**
 * Request to reset a branch to its parent's latest state
 */
export type ResetBranchRequest = {
    /**
     * Whether to reset to parent (currently the only supported option)
     */
    parent: boolean;
};

/**
 * Entry used when resetting the IP allow list
 */
export type ResetIpAllowListEntry = {
    /**
     * Optional description for the entry
     */
    description?: string | null;
    /**
     * IP address or CIDR range to allow
     */
    ip_address: string;
};

/**
 * Request to replace the entire IP allow list
 */
export type ResetIpAllowListRequest = {
    /**
     * Entries that should remain in the allow list after the reset.
     * Empty list means the allow list is cleared.
     */
    entries?: Array<ResetIpAllowListEntry>;
};

/**
 * Request to restore a branch to a point in time
 */
export type RestoreBranchRequest = {
    /**
     * Name for the backup branch that will preserve the current state
     */
    preserve_under_name: string;
    /**
     * Source to restore from
     */
    source: RestoreSource;
};

/**
 * Restore source for point-in-time recovery
 */
export type RestoreSource = {
    point_in_time: PointInTime;
    type: '^self';
} | {
    point_in_time?: null | PointInTime;
    type: '^parent';
} | {
    point_in_time?: null | PointInTime;
    source_branch_id: string;
    type: 'branch';
};

/**
 * Response after creating a role
 */
export type RoleCreated = {
    branch_id: string;
    created_at: string;
    id: string;
    name: string;
    password: string;
};

/**
 * Public role info (without password hash)
 */
export type RoleInfo = {
    branch_id: string;
    created_at: string;
    id: string;
    name: string;
    protected: boolean;
};

/**
 * Response after resetting password
 */
export type RolePasswordReset = {
    password: string;
    role_id: string;
};

/**
 * Request to set branch archived status
 */
export type SetBranchArchivedRequest = {
    archived: boolean;
};

/**
 * Request to set branch expiration
 */
export type SetBranchExpirationRequest = {
    expires_at?: string | null;
};

/**
 * Response for timestamp by LSN query
 */
export type TimestampByLsn = {
    timestamp: string;
};

/**
 * Request to update branch protection
 */
export type UpdateBranchProtectionRequest = {
    allowed_bypass_roles?: Array<string> | null;
    prevent_deletion?: boolean | null;
    prevent_reset?: boolean | null;
    require_approval_for_changes?: boolean | null;
};

/**
 * Request to update a database
 */
export type UpdateDatabaseRequest = {
    owner_name?: string | null;
};

/**
 * Request to update an endpoint
 */
export type UpdateEndpointRequest = {
    autoscaling_max?: number | null;
    autoscaling_min?: number | null;
    pooler_enabled?: boolean | null;
    pooler_mode?: null | PoolerMode;
    suspend_timeout_seconds?: number | null;
};

/**
 * Request to update logical replication settings
 */
export type UpdateLogicalReplicationRequest = {
    enabled: boolean;
};

/**
 * Request to update a project
 */
export type UpdateProjectRequest = {
    block_public_connections?: boolean | null;
    block_vpc_connections?: boolean | null;
    compute_unit_max?: number | null;
    compute_unit_min?: number | null;
    /**
     * Enable logical replication for this project. Sets wal_level=logical for all compute endpoints.
     * Once enabled, this cannot be disabled. Enabling will suspend all active endpoints.
     */
    enable_logical_replication?: boolean | null;
    hipaa?: boolean | null;
    /**
     * History retention period in seconds for point-in-time recovery (PITR).
     * Determines how far back you can create branches from historical data.
     * Default is 21600 (6 hours). Minimum is 3600 (1 hour). Maximum is 2592000 (30 days).
     */
    history_retention_seconds?: number | null;
    name?: string | null;
    protected_branches_only?: boolean | null;
};

/**
 * Request to update a publication
 */
export type UpdatePublicationRequest = {
    publish_delete?: boolean | null;
    publish_insert?: boolean | null;
    publish_truncate?: boolean | null;
    publish_update?: boolean | null;
    tables?: Array<string> | null;
};

export type SerenDbListProjectsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/projects';
};

export type SerenDbListProjectsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type SerenDbListProjectsResponses = {
    /**
     * Projects listed
     */
    200: DataResponseVecProject;
};

export type SerenDbListProjectsResponse = SerenDbListProjectsResponses[keyof SerenDbListProjectsResponses];

export type SerenDbCreateProjectData = {
    body: CreateProjectRequest;
    path?: never;
    query?: never;
    url: '/projects';
};

export type SerenDbCreateProjectErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
};

export type SerenDbCreateProjectResponses = {
    /**
     * Project created
     */
    201: DataResponseProjectCreated;
};

export type SerenDbCreateProjectResponse = SerenDbCreateProjectResponses[keyof SerenDbCreateProjectResponses];

export type SerenDbDeleteProjectData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
    };
    query?: never;
    url: '/projects/{id}';
};

export type SerenDbDeleteProjectErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbDeleteProjectResponses = {
    /**
     * Project deleted
     */
    200: DataResponseValue;
};

export type SerenDbDeleteProjectResponse = SerenDbDeleteProjectResponses[keyof SerenDbDeleteProjectResponses];

export type SerenDbGetProjectData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
    };
    query?: never;
    url: '/projects/{id}';
};

export type SerenDbGetProjectErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbGetProjectResponses = {
    /**
     * Project retrieved
     */
    200: DataResponseProject;
};

export type SerenDbGetProjectResponse = SerenDbGetProjectResponses[keyof SerenDbGetProjectResponses];

export type SerenDbUpdateProjectData = {
    body: UpdateProjectRequest;
    path: {
        /**
         * Project ID
         */
        id: string;
    };
    query?: never;
    url: '/projects/{id}';
};

export type SerenDbUpdateProjectErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbUpdateProjectResponses = {
    /**
     * Project updated
     */
    200: DataResponseProject;
};

export type SerenDbUpdateProjectResponse = SerenDbUpdateProjectResponses[keyof SerenDbUpdateProjectResponses];

export type SerenDbListBranchProtectionRulesData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
    };
    query?: never;
    url: '/projects/{id}/branch-protection';
};

export type SerenDbListBranchProtectionRulesErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbListBranchProtectionRulesResponses = {
    /**
     * Branch protection rules listed
     */
    200: DataResponseVecBranchProtection;
};

export type SerenDbListBranchProtectionRulesResponse = SerenDbListBranchProtectionRulesResponses[keyof SerenDbListBranchProtectionRulesResponses];

export type SerenDbListBranchesData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
    };
    query?: never;
    url: '/projects/{id}/branches';
};

export type SerenDbListBranchesResponses = {
    /**
     * Branches listed
     */
    200: DataResponseVecBranch;
};

export type SerenDbListBranchesResponse = SerenDbListBranchesResponses[keyof SerenDbListBranchesResponses];

export type SerenDbCreateBranchData = {
    body: CreateBranchRequest;
    path: {
        /**
         * Project ID
         */
        id: string;
    };
    query?: never;
    url: '/projects/{id}/branches';
};

export type SerenDbCreateBranchErrors = {
    /**
     * Bad request
     */
    400: unknown;
};

export type SerenDbCreateBranchResponses = {
    /**
     * Branch created
     */
    201: DataResponseBranchCreationResult;
};

export type SerenDbCreateBranchResponse = SerenDbCreateBranchResponses[keyof SerenDbCreateBranchResponses];

export type SerenDbGetBranchCountData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
    };
    query?: never;
    url: '/projects/{id}/branches/count';
};

export type SerenDbGetBranchCountErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbGetBranchCountResponses = {
    /**
     * Branch count retrieved
     */
    200: DataResponseValue;
};

export type SerenDbGetBranchCountResponse = SerenDbGetBranchCountResponses[keyof SerenDbGetBranchCountResponses];

export type SerenDbDeleteBranchData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}';
};

export type SerenDbDeleteBranchErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbDeleteBranchResponses = {
    /**
     * Branch deleted
     */
    200: DataResponseValue;
};

export type SerenDbDeleteBranchResponse = SerenDbDeleteBranchResponses[keyof SerenDbDeleteBranchResponses];

export type SerenDbGetBranchData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}';
};

export type SerenDbGetBranchErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbGetBranchResponses = {
    /**
     * Branch retrieved
     */
    200: DataResponseBranch;
};

export type SerenDbGetBranchResponse = SerenDbGetBranchResponses[keyof SerenDbGetBranchResponses];

export type SerenDbRenameBranchData = {
    body: RenameBranchRequest;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}';
};

export type SerenDbRenameBranchErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbRenameBranchResponses = {
    /**
     * Branch renamed
     */
    200: DataResponseBranch;
};

export type SerenDbRenameBranchResponse = SerenDbRenameBranchResponses[keyof SerenDbRenameBranchResponses];

export type SerenDbSetBranchArchivedData = {
    body: SetBranchArchivedRequest;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/archived';
};

export type SerenDbSetBranchArchivedErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbSetBranchArchivedResponses = {
    /**
     * Branch archived state updated
     */
    200: DataResponseValue;
};

export type SerenDbSetBranchArchivedResponse = SerenDbSetBranchArchivedResponses[keyof SerenDbSetBranchArchivedResponses];

export type SerenDbGetConnectionStringData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
    };
    query?: {
        /**
         * Use pooled connection if true
         */
        pooled?: boolean;
        /**
         * Optional role name override
         */
        role?: string;
    };
    url: '/projects/{id}/branches/{bid}/connection-string';
};

export type SerenDbGetConnectionStringErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbGetConnectionStringResponses = {
    /**
     * Connection string retrieved
     */
    200: DataResponseConnectionString;
};

export type SerenDbGetConnectionStringResponse = SerenDbGetConnectionStringResponses[keyof SerenDbGetConnectionStringResponses];

export type SerenDbListDatabasesData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/databases';
};

export type SerenDbListDatabasesResponses = {
    /**
     * Databases listed
     */
    200: DataResponseVecDatabaseWithOwner;
};

export type SerenDbListDatabasesResponse = SerenDbListDatabasesResponses[keyof SerenDbListDatabasesResponses];

export type SerenDbCreateDatabaseData = {
    body: CreateDatabaseRequest;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/databases';
};

export type SerenDbCreateDatabaseErrors = {
    /**
     * Bad request
     */
    400: unknown;
};

export type SerenDbCreateDatabaseResponses = {
    /**
     * Database created
     */
    201: DataResponseDatabaseCreated;
};

export type SerenDbCreateDatabaseResponse = SerenDbCreateDatabaseResponses[keyof SerenDbCreateDatabaseResponses];

export type SerenDbDeleteDatabaseData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
        /**
         * Database ID
         */
        did: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/databases/{did}';
};

export type SerenDbDeleteDatabaseErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbDeleteDatabaseResponses = {
    /**
     * Database deleted
     */
    200: DataResponseValue;
};

export type SerenDbDeleteDatabaseResponse = SerenDbDeleteDatabaseResponses[keyof SerenDbDeleteDatabaseResponses];

export type SerenDbGetDatabaseData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
        /**
         * Database ID
         */
        did: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/databases/{did}';
};

export type SerenDbGetDatabaseErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbGetDatabaseResponses = {
    /**
     * Database retrieved
     */
    200: DataResponseDatabaseWithOwner;
};

export type SerenDbGetDatabaseResponse = SerenDbGetDatabaseResponses[keyof SerenDbGetDatabaseResponses];

export type SerenDbUpdateDatabaseData = {
    body: UpdateDatabaseRequest;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
        /**
         * Database ID
         */
        did: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/databases/{did}';
};

export type SerenDbUpdateDatabaseErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbUpdateDatabaseResponses = {
    /**
     * Database updated
     */
    200: DataResponseDatabaseWithOwner;
};

export type SerenDbUpdateDatabaseResponse = SerenDbUpdateDatabaseResponses[keyof SerenDbUpdateDatabaseResponses];

export type SerenDbGetBranchDetailsData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/details';
};

export type SerenDbGetBranchDetailsErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbGetBranchDetailsResponses = {
    /**
     * Branch details retrieved
     */
    200: DataResponseBranchDetail;
};

export type SerenDbGetBranchDetailsResponse = SerenDbGetBranchDetailsResponses[keyof SerenDbGetBranchDetailsResponses];

export type SerenDbListEndpointsData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/endpoints';
};

export type SerenDbListEndpointsResponses = {
    /**
     * Endpoints listed
     */
    200: DataResponseVecEndpoint;
};

export type SerenDbListEndpointsResponse = SerenDbListEndpointsResponses[keyof SerenDbListEndpointsResponses];

export type SerenDbCreateEndpointData = {
    body: CreateEndpointRequest;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/endpoints';
};

export type SerenDbCreateEndpointErrors = {
    /**
     * Bad request
     */
    400: unknown;
};

export type SerenDbCreateEndpointResponses = {
    /**
     * Endpoint created
     */
    201: DataResponseEndpointCreated;
};

export type SerenDbCreateEndpointResponse = SerenDbCreateEndpointResponses[keyof SerenDbCreateEndpointResponses];

export type SerenDbDeleteEndpointData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
        /**
         * Endpoint ID
         */
        eid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/endpoints/{eid}';
};

export type SerenDbDeleteEndpointErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbDeleteEndpointResponses = {
    /**
     * Endpoint deleted
     */
    200: DataResponseValue;
};

export type SerenDbDeleteEndpointResponse = SerenDbDeleteEndpointResponses[keyof SerenDbDeleteEndpointResponses];

export type SerenDbUpdateEndpointData = {
    body: UpdateEndpointRequest;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
        /**
         * Endpoint ID
         */
        eid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/endpoints/{eid}';
};

export type SerenDbUpdateEndpointErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbUpdateEndpointResponses = {
    /**
     * Endpoint updated
     */
    200: DataResponseEndpoint;
};

export type SerenDbUpdateEndpointResponse = SerenDbUpdateEndpointResponses[keyof SerenDbUpdateEndpointResponses];

export type SerenDbGetEndpointHealthData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
        /**
         * Endpoint ID
         */
        eid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/endpoints/{eid}/health';
};

export type SerenDbGetEndpointHealthErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbGetEndpointHealthResponses = {
    /**
     * Endpoint health retrieved
     */
    200: DataResponseValue;
};

export type SerenDbGetEndpointHealthResponse = SerenDbGetEndpointHealthResponses[keyof SerenDbGetEndpointHealthResponses];

export type SerenDbGetEndpointMetricsData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
        /**
         * Endpoint ID
         */
        eid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/endpoints/{eid}/metrics';
};

export type SerenDbGetEndpointMetricsErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbGetEndpointMetricsResponses = {
    /**
     * Endpoint metrics retrieved
     */
    200: DataResponseValue;
};

export type SerenDbGetEndpointMetricsResponse = SerenDbGetEndpointMetricsResponses[keyof SerenDbGetEndpointMetricsResponses];

export type SerenDbStartEndpointData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
        /**
         * Endpoint ID
         */
        eid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/endpoints/{eid}/start';
};

export type SerenDbStartEndpointErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbStartEndpointResponses = {
    /**
     * Endpoint started
     */
    200: DataResponseEndpointStatusInfo;
};

export type SerenDbStartEndpointResponse = SerenDbStartEndpointResponses[keyof SerenDbStartEndpointResponses];

export type SerenDbGetEndpointStatusData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
        /**
         * Endpoint ID
         */
        eid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/endpoints/{eid}/status';
};

export type SerenDbGetEndpointStatusErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbGetEndpointStatusResponses = {
    /**
     * Endpoint status
     */
    200: DataResponseEndpointStatusInfo;
};

export type SerenDbGetEndpointStatusResponse = SerenDbGetEndpointStatusResponses[keyof SerenDbGetEndpointStatusResponses];

export type SerenDbStopEndpointData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
        /**
         * Endpoint ID
         */
        eid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/endpoints/{eid}/stop';
};

export type SerenDbStopEndpointErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbStopEndpointResponses = {
    /**
     * Endpoint stopped
     */
    200: DataResponseEndpointStatusInfo;
};

export type SerenDbStopEndpointResponse = SerenDbStopEndpointResponses[keyof SerenDbStopEndpointResponses];

export type SerenDbSetBranchExpirationData = {
    body: SetBranchExpirationRequest;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/expiration';
};

export type SerenDbSetBranchExpirationErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbSetBranchExpirationResponses = {
    /**
     * Branch expiration set
     */
    200: DataResponseValue;
};

export type SerenDbSetBranchExpirationResponse = SerenDbSetBranchExpirationResponses[keyof SerenDbSetBranchExpirationResponses];

export type SerenDbGetLsnByTimestampData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
    };
    query: {
        /**
         * Timestamp in ISO-8601 format
         */
        timestamp: string;
    };
    url: '/projects/{id}/branches/{bid}/lsn_by_timestamp';
};

export type SerenDbGetLsnByTimestampErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbGetLsnByTimestampResponses = {
    /**
     * LSN retrieved
     */
    200: DataResponseLsnByTimestamp;
};

export type SerenDbGetLsnByTimestampResponse = SerenDbGetLsnByTimestampResponses[keyof SerenDbGetLsnByTimestampResponses];

export type SerenDbDeleteBranchProtectionData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/protection';
};

export type SerenDbDeleteBranchProtectionErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbDeleteBranchProtectionResponses = {
    /**
     * Branch protection rule deleted
     */
    204: void;
};

export type SerenDbDeleteBranchProtectionResponse = SerenDbDeleteBranchProtectionResponses[keyof SerenDbDeleteBranchProtectionResponses];

export type SerenDbGetBranchProtectionData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/protection';
};

export type SerenDbGetBranchProtectionErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbGetBranchProtectionResponses = {
    /**
     * Branch protection rule retrieved
     */
    200: DataResponseBranchProtection;
};

export type SerenDbGetBranchProtectionResponse = SerenDbGetBranchProtectionResponses[keyof SerenDbGetBranchProtectionResponses];

export type SerenDbUpdateBranchProtectionData = {
    body: UpdateBranchProtectionRequest;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/protection';
};

export type SerenDbUpdateBranchProtectionErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbUpdateBranchProtectionResponses = {
    /**
     * Branch protection rule updated
     */
    200: DataResponseBranchProtection;
};

export type SerenDbUpdateBranchProtectionResponse = SerenDbUpdateBranchProtectionResponses[keyof SerenDbUpdateBranchProtectionResponses];

export type SerenDbCreateBranchProtectionData = {
    body: CreateBranchProtectionRequest;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/protection';
};

export type SerenDbCreateBranchProtectionErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbCreateBranchProtectionResponses = {
    /**
     * Branch protection rule created
     */
    201: DataResponseBranchProtection;
};

export type SerenDbCreateBranchProtectionResponse = SerenDbCreateBranchProtectionResponses[keyof SerenDbCreateBranchProtectionResponses];

export type SerenDbListPublicationsData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/publications';
};

export type SerenDbListPublicationsErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbListPublicationsResponses = {
    /**
     * Publications listed
     */
    200: DataResponseVecPublicationInfo;
};

export type SerenDbListPublicationsResponse = SerenDbListPublicationsResponses[keyof SerenDbListPublicationsResponses];

export type SerenDbCreatePublicationData = {
    body: CreatePublicationRequest;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/publications';
};

export type SerenDbCreatePublicationErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbCreatePublicationResponses = {
    /**
     * Publication created
     */
    201: DataResponsePublicationInfo;
};

export type SerenDbCreatePublicationResponse = SerenDbCreatePublicationResponses[keyof SerenDbCreatePublicationResponses];

export type SerenDbDeletePublicationData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
        /**
         * Publication ID
         */
        publication_id: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/publications/{publication_id}';
};

export type SerenDbDeletePublicationErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbDeletePublicationResponses = {
    /**
     * Publication deleted
     */
    204: void;
};

export type SerenDbDeletePublicationResponse = SerenDbDeletePublicationResponses[keyof SerenDbDeletePublicationResponses];

export type SerenDbUpdatePublicationData = {
    body: UpdatePublicationRequest;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
        /**
         * Publication ID
         */
        publication_id: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/publications/{publication_id}';
};

export type SerenDbUpdatePublicationErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbUpdatePublicationResponses = {
    /**
     * Publication updated
     */
    200: DataResponsePublicationInfo;
};

export type SerenDbUpdatePublicationResponse = SerenDbUpdatePublicationResponses[keyof SerenDbUpdatePublicationResponses];

export type SerenDbListReplicationSlotsData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/replication-slots';
};

export type SerenDbListReplicationSlotsErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbListReplicationSlotsResponses = {
    /**
     * Replication slots listed
     */
    200: DataResponseVecReplicationSlotInfo;
};

export type SerenDbListReplicationSlotsResponse = SerenDbListReplicationSlotsResponses[keyof SerenDbListReplicationSlotsResponses];

export type SerenDbCreateReplicationSlotData = {
    body: CreateReplicationSlotRequest;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/replication-slots';
};

export type SerenDbCreateReplicationSlotErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbCreateReplicationSlotResponses = {
    /**
     * Replication slot created
     */
    201: DataResponseReplicationSlotInfo;
};

export type SerenDbCreateReplicationSlotResponse = SerenDbCreateReplicationSlotResponses[keyof SerenDbCreateReplicationSlotResponses];

export type SerenDbDeleteReplicationSlotData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
        /**
         * Replication slot ID
         */
        slot_id: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/replication-slots/{slot_id}';
};

export type SerenDbDeleteReplicationSlotErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbDeleteReplicationSlotResponses = {
    /**
     * Replication slot deleted
     */
    204: void;
};

export type SerenDbDeleteReplicationSlotResponse = SerenDbDeleteReplicationSlotResponses[keyof SerenDbDeleteReplicationSlotResponses];

export type SerenDbResetBranchData = {
    body: ResetBranchRequest;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/reset';
};

export type SerenDbResetBranchErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbResetBranchResponses = {
    /**
     * Branch reset
     */
    200: DataResponseBranch;
};

export type SerenDbResetBranchResponse = SerenDbResetBranchResponses[keyof SerenDbResetBranchResponses];

export type SerenDbRestoreBranchData = {
    body: RestoreBranchRequest;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/restore';
};

export type SerenDbRestoreBranchErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbRestoreBranchResponses = {
    /**
     * Branch restored
     */
    200: DataResponseBranchRestored;
};

export type SerenDbRestoreBranchResponse = SerenDbRestoreBranchResponses[keyof SerenDbRestoreBranchResponses];

export type SerenDbListRolesData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/roles';
};

export type SerenDbListRolesResponses = {
    /**
     * Roles listed
     */
    200: DataResponseVecRoleInfo;
};

export type SerenDbListRolesResponse = SerenDbListRolesResponses[keyof SerenDbListRolesResponses];

export type SerenDbCreateRoleData = {
    body: CreateDbRoleRequest;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/roles';
};

export type SerenDbCreateRoleErrors = {
    /**
     * Bad request
     */
    400: unknown;
};

export type SerenDbCreateRoleResponses = {
    /**
     * Role created
     */
    201: DataResponseRoleCreated;
};

export type SerenDbCreateRoleResponse = SerenDbCreateRoleResponses[keyof SerenDbCreateRoleResponses];

export type SerenDbDeleteRoleData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
        /**
         * Role ID
         */
        rid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/roles/{rid}';
};

export type SerenDbDeleteRoleErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbDeleteRoleResponses = {
    /**
     * Role deleted
     */
    200: DataResponseValue;
};

export type SerenDbDeleteRoleResponse = SerenDbDeleteRoleResponses[keyof SerenDbDeleteRoleResponses];

export type SerenDbResetRolePasswordData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
        /**
         * Role ID
         */
        rid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/roles/{rid}/reset_password';
};

export type SerenDbResetRolePasswordErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbResetRolePasswordResponses = {
    /**
     * Password reset
     */
    200: DataResponseRolePasswordReset;
};

export type SerenDbResetRolePasswordResponse = SerenDbResetRolePasswordResponses[keyof SerenDbResetRolePasswordResponses];

export type SerenDbRevealRolePasswordData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
        /**
         * Role name
         */
        role_name: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/roles/{role_name}/reveal_password';
};

export type SerenDbRevealRolePasswordErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbRevealRolePasswordResponses = {
    /**
     * Role password revealed
     */
    200: DataResponseRolePasswordReset;
};

export type SerenDbRevealRolePasswordResponse = SerenDbRevealRolePasswordResponses[keyof SerenDbRevealRolePasswordResponses];

export type SerenDbSetDefaultBranchData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/set-default';
};

export type SerenDbSetDefaultBranchErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbSetDefaultBranchResponses = {
    /**
     * Branch set as default
     */
    200: DataResponseValue;
};

export type SerenDbSetDefaultBranchResponse = SerenDbSetDefaultBranchResponses[keyof SerenDbSetDefaultBranchResponses];

export type SerenDbSetDefaultBranchAliasData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
    };
    query?: never;
    url: '/projects/{id}/branches/{bid}/set_as_default';
};

export type SerenDbSetDefaultBranchAliasErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbSetDefaultBranchAliasResponses = {
    /**
     * Branch set as default
     */
    200: DataResponseValue;
};

export type SerenDbSetDefaultBranchAliasResponse = SerenDbSetDefaultBranchAliasResponses[keyof SerenDbSetDefaultBranchAliasResponses];

export type SerenDbGetTimestampByLsnData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Branch ID
         */
        bid: string;
    };
    query: {
        /**
         * Log sequence number
         */
        lsn: string;
    };
    url: '/projects/{id}/branches/{bid}/timestamp_by_lsn';
};

export type SerenDbGetTimestampByLsnErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbGetTimestampByLsnResponses = {
    /**
     * Timestamp retrieved
     */
    200: DataResponseTimestampByLsn;
};

export type SerenDbGetTimestampByLsnResponse = SerenDbGetTimestampByLsnResponses[keyof SerenDbGetTimestampByLsnResponses];

export type SerenDbConnectionUriData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
    };
    query?: {
        /**
         * Optional branch ID
         */
        branch_id?: string;
        /**
         * Optional endpoint ID
         */
        endpoint_id?: string;
        /**
         * Optional database name
         */
        database_name?: string;
        /**
         * Optional role name
         */
        role_name?: string;
        /**
         * Use pooled connection if true
         */
        pooled?: boolean;
    };
    url: '/projects/{id}/connection_uri';
};

export type SerenDbConnectionUriErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbConnectionUriResponses = {
    /**
     * Connection URI retrieved
     */
    200: DataResponseProjectConnectionUri;
};

export type SerenDbConnectionUriResponse = SerenDbConnectionUriResponses[keyof SerenDbConnectionUriResponses];

export type SerenDbGetProjectConsumptionData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
    };
    query?: {
        /**
         * Start date (YYYY-MM-DD)
         */
        start_date?: string;
        /**
         * End date (YYYY-MM-DD)
         */
        end_date?: string;
    };
    url: '/projects/{id}/consumption';
};

export type SerenDbGetProjectConsumptionErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbGetProjectConsumptionResponses = {
    /**
     * Consumption retrieved
     */
    200: DataResponseProjectConsumption;
};

export type SerenDbGetProjectConsumptionResponse = SerenDbGetProjectConsumptionResponses[keyof SerenDbGetProjectConsumptionResponses];

export type SerenDbListProjectDatabasesData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
    };
    query?: never;
    url: '/projects/{id}/databases';
};

export type SerenDbListProjectDatabasesErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbListProjectDatabasesResponses = {
    /**
     * Project databases listed
     */
    200: DataResponseValue;
};

export type SerenDbListProjectDatabasesResponse = SerenDbListProjectDatabasesResponses[keyof SerenDbListProjectDatabasesResponses];

export type SerenDbListProjectEndpointsData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
    };
    query?: never;
    url: '/projects/{id}/endpoints';
};

export type SerenDbListProjectEndpointsErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbListProjectEndpointsResponses = {
    /**
     * Project endpoints listed
     */
    200: DataResponseValue;
};

export type SerenDbListProjectEndpointsResponse = SerenDbListProjectEndpointsResponses[keyof SerenDbListProjectEndpointsResponses];

export type SerenDbDeleteProjectEndpointData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Endpoint ID
         */
        eid: string;
    };
    query?: never;
    url: '/projects/{id}/endpoints/{eid}';
};

export type SerenDbDeleteProjectEndpointErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbDeleteProjectEndpointResponses = {
    /**
     * Project endpoint deleted
     */
    200: DataResponseValue;
};

export type SerenDbDeleteProjectEndpointResponse = SerenDbDeleteProjectEndpointResponses[keyof SerenDbDeleteProjectEndpointResponses];

export type SerenDbUpdateProjectEndpointData = {
    body: UpdateEndpointRequest;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Endpoint ID
         */
        eid: string;
    };
    query?: never;
    url: '/projects/{id}/endpoints/{eid}';
};

export type SerenDbUpdateProjectEndpointErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbUpdateProjectEndpointResponses = {
    /**
     * Project endpoint updated
     */
    200: DataResponseValue;
};

export type SerenDbUpdateProjectEndpointResponse = SerenDbUpdateProjectEndpointResponses[keyof SerenDbUpdateProjectEndpointResponses];

export type SerenDbRestartEndpointData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Endpoint ID
         */
        eid: string;
    };
    query?: never;
    url: '/projects/{id}/endpoints/{eid}/restart';
};

export type SerenDbRestartEndpointErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbRestartEndpointResponses = {
    /**
     * Endpoint restarted
     */
    200: DataResponseEndpointStatusInfo;
};

export type SerenDbRestartEndpointResponse = SerenDbRestartEndpointResponses[keyof SerenDbRestartEndpointResponses];

export type SerenDbStartProjectEndpointData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Endpoint ID
         */
        eid: string;
    };
    query?: never;
    url: '/projects/{id}/endpoints/{eid}/start';
};

export type SerenDbStartProjectEndpointErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbStartProjectEndpointResponses = {
    /**
     * Project endpoint started
     */
    200: DataResponseValue;
};

export type SerenDbStartProjectEndpointResponse = SerenDbStartProjectEndpointResponses[keyof SerenDbStartProjectEndpointResponses];

export type SerenDbSuspendProjectEndpointData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Endpoint ID
         */
        eid: string;
    };
    query?: never;
    url: '/projects/{id}/endpoints/{eid}/suspend';
};

export type SerenDbSuspendProjectEndpointErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbSuspendProjectEndpointResponses = {
    /**
     * Project endpoint suspended
     */
    200: DataResponseValue;
};

export type SerenDbSuspendProjectEndpointResponse = SerenDbSuspendProjectEndpointResponses[keyof SerenDbSuspendProjectEndpointResponses];

export type SerenDbListIpAllowListData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
    };
    query?: never;
    url: '/projects/{id}/ip-allow';
};

export type SerenDbListIpAllowListErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbListIpAllowListResponses = {
    /**
     * IP allow list listed
     */
    200: DataResponseVecIpAllowList;
};

export type SerenDbListIpAllowListResponse = SerenDbListIpAllowListResponses[keyof SerenDbListIpAllowListResponses];

export type SerenDbAddIpAllowListData = {
    body: AddIpAllowListRequest;
    path: {
        /**
         * Project ID
         */
        id: string;
    };
    query?: never;
    url: '/projects/{id}/ip-allow';
};

export type SerenDbAddIpAllowListErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbAddIpAllowListResponses = {
    /**
     * IP allow list entry added
     */
    201: DataResponseIpAllowList;
};

export type SerenDbAddIpAllowListResponse = SerenDbAddIpAllowListResponses[keyof SerenDbAddIpAllowListResponses];

export type SerenDbResetIpAllowListData = {
    body: ResetIpAllowListRequest;
    path: {
        /**
         * Project ID
         */
        id: string;
    };
    query?: never;
    url: '/projects/{id}/ip-allow/reset';
};

export type SerenDbResetIpAllowListErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbResetIpAllowListResponses = {
    /**
     * IP allow list reset
     */
    200: DataResponseVecIpAllowList;
};

export type SerenDbResetIpAllowListResponse = SerenDbResetIpAllowListResponses[keyof SerenDbResetIpAllowListResponses];

export type SerenDbRemoveIpAllowListData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * IP allow list entry ID
         */
        ip_id: string;
    };
    query?: never;
    url: '/projects/{id}/ip-allow/{ip_id}';
};

export type SerenDbRemoveIpAllowListErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbRemoveIpAllowListResponses = {
    /**
     * IP allow list entry removed
     */
    204: void;
};

export type SerenDbRemoveIpAllowListResponse = SerenDbRemoveIpAllowListResponses[keyof SerenDbRemoveIpAllowListResponses];

export type SerenDbListOperationsData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
    };
    query?: never;
    url: '/projects/{id}/operations';
};

export type SerenDbListOperationsErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbListOperationsResponses = {
    /**
     * Operations listed
     */
    200: DataResponseValue;
};

export type SerenDbListOperationsResponse = SerenDbListOperationsResponses[keyof SerenDbListOperationsResponses];

export type SerenDbGetOperationData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Operation ID
         */
        operation_id: string;
    };
    query?: never;
    url: '/projects/{id}/operations/{operation_id}';
};

export type SerenDbGetOperationErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbGetOperationResponses = {
    /**
     * Operation retrieved
     */
    200: DataResponseValue;
};

export type SerenDbGetOperationResponse = SerenDbGetOperationResponses[keyof SerenDbGetOperationResponses];

export type SerenDbGetReplicationSettingsData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
    };
    query?: never;
    url: '/projects/{id}/replication';
};

export type SerenDbGetReplicationSettingsErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbGetReplicationSettingsResponses = {
    /**
     * Replication settings retrieved
     */
    200: DataResponseLogicalReplicationSettings;
};

export type SerenDbGetReplicationSettingsResponse = SerenDbGetReplicationSettingsResponses[keyof SerenDbGetReplicationSettingsResponses];

export type SerenDbUpdateReplicationSettingsData = {
    body: UpdateLogicalReplicationRequest;
    path: {
        /**
         * Project ID
         */
        id: string;
    };
    query?: never;
    url: '/projects/{id}/replication';
};

export type SerenDbUpdateReplicationSettingsErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbUpdateReplicationSettingsResponses = {
    /**
     * Replication settings updated
     */
    200: DataResponseLogicalReplicationSettings;
};

export type SerenDbUpdateReplicationSettingsResponse = SerenDbUpdateReplicationSettingsResponses[keyof SerenDbUpdateReplicationSettingsResponses];

export type SerenDbGetProjectSizeData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
    };
    query?: never;
    url: '/projects/{id}/size';
};

export type SerenDbGetProjectSizeErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbGetProjectSizeResponses = {
    /**
     * Project size retrieved
     */
    200: DataResponseProjectSize;
};

export type SerenDbGetProjectSizeResponse = SerenDbGetProjectSizeResponses[keyof SerenDbGetProjectSizeResponses];

export type SerenDbListProjectVpcEndpointsData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
    };
    query?: never;
    url: '/projects/{id}/vpc-endpoints';
};

export type SerenDbListProjectVpcEndpointsErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbListProjectVpcEndpointsResponses = {
    /**
     * VPC endpoint assignments listed
     */
    200: DataResponseValue;
};

export type SerenDbListProjectVpcEndpointsResponse = SerenDbListProjectVpcEndpointsResponses[keyof SerenDbListProjectVpcEndpointsResponses];

export type SerenDbAssignProjectVpcEndpointData = {
    body: AssignProjectVpcEndpointRequest;
    path: {
        /**
         * Project ID
         */
        id: string;
    };
    query?: never;
    url: '/projects/{id}/vpc-endpoints';
};

export type SerenDbAssignProjectVpcEndpointErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbAssignProjectVpcEndpointResponses = {
    /**
     * VPC endpoint assignment created
     */
    201: DataResponseValue;
};

export type SerenDbAssignProjectVpcEndpointResponse = SerenDbAssignProjectVpcEndpointResponses[keyof SerenDbAssignProjectVpcEndpointResponses];

export type SerenDbRemoveProjectVpcEndpointData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Assignment ID
         */
        assignment_id: string;
    };
    query?: never;
    url: '/projects/{id}/vpc-endpoints/{assignment_id}';
};

export type SerenDbRemoveProjectVpcEndpointErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbRemoveProjectVpcEndpointResponses = {
    /**
     * VPC endpoint assignment removed
     */
    204: void;
};

export type SerenDbRemoveProjectVpcEndpointResponse = SerenDbRemoveProjectVpcEndpointResponses[keyof SerenDbRemoveProjectVpcEndpointResponses];

export type SerenDbListProjectVpcEndpointsAliasData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
    };
    query?: never;
    url: '/projects/{id}/vpc_endpoints';
};

export type SerenDbListProjectVpcEndpointsAliasErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbListProjectVpcEndpointsAliasResponses = {
    /**
     * VPC endpoint assignments listed
     */
    200: DataResponseValue;
};

export type SerenDbListProjectVpcEndpointsAliasResponse = SerenDbListProjectVpcEndpointsAliasResponses[keyof SerenDbListProjectVpcEndpointsAliasResponses];

export type SerenDbRemoveProjectVpcEndpointByVpcIdData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Organization VPC endpoint ID
         */
        vpc_endpoint_id: string;
    };
    query?: never;
    url: '/projects/{id}/vpc_endpoints/{vpc_endpoint_id}';
};

export type SerenDbRemoveProjectVpcEndpointByVpcIdErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbRemoveProjectVpcEndpointByVpcIdResponses = {
    /**
     * VPC endpoint assignment removed
     */
    204: void;
};

export type SerenDbRemoveProjectVpcEndpointByVpcIdResponse = SerenDbRemoveProjectVpcEndpointByVpcIdResponses[keyof SerenDbRemoveProjectVpcEndpointByVpcIdResponses];

export type SerenDbAssignProjectVpcEndpointByIdData = {
    body?: never;
    path: {
        /**
         * Project ID
         */
        id: string;
        /**
         * Organization VPC endpoint ID
         */
        vpc_endpoint_id: string;
    };
    query?: never;
    url: '/projects/{id}/vpc_endpoints/{vpc_endpoint_id}';
};

export type SerenDbAssignProjectVpcEndpointByIdErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenDbAssignProjectVpcEndpointByIdResponses = {
    /**
     * VPC endpoint assignment created
     */
    201: DataResponseValue;
};

export type SerenDbAssignProjectVpcEndpointByIdResponse = SerenDbAssignProjectVpcEndpointByIdResponses[keyof SerenDbAssignProjectVpcEndpointByIdResponses];

export type SerenDbQueryData = {
    body: QueryRequest;
    path?: never;
    query?: never;
    url: '/query';
};

export type SerenDbQueryErrors = {
    /**
     * Bad request / query error
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
};

export type SerenDbQueryResponses = {
    /**
     * Query executed
     */
    200: DataResponseQueryResult;
};

export type SerenDbQueryResponse = SerenDbQueryResponses[keyof SerenDbQueryResponses];
