// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: `${string}://${string}` | (string & {});
};

export type AddPaymentMethodRequest = {
    set_as_default: boolean;
    stripe_payment_method_id: string;
};

/**
 * Source of an agent credit grant (fiat-only, no on-chain deposits)
 */
export type AgentCreditSource = 'fiat_purchase' | 'signup_bonus' | 'payment_method_bonus' | 'daily_claim' | 'referral_reward' | 'admin_grant' | 'promo_code' | 'tier_bonus' | 'refund' | 'publisher_payout';

/**
 * Agent information returned on successful registration
 */
export type AgentInfo = {
    /**
     * The full API key (seren_<key_id>_<secret>) - shown ONCE, save it immediately!
     */
    api_key: string;
    /**
     * When the account was created
     */
    created_at: string;
    /**
     * The agent's unique ID
     */
    id: string;
    /**
     * The agent's display name (auto-generated celestial name like "radiant-sirius-a1b2")
     */
    name: string;
    /**
     * The organization ID for API calls
     */
    organization_id: string;
    /**
     * Account status (always "active" for new agents)
     */
    status: string;
    /**
     * Agent type (always "agent")
     */
    user_type: string;
};

/**
 * DataResponse wrapper for agent registration (for OpenAPI schema)
 */
export type AgentRegisterDataResponse = {
    /**
     * The actual response data
     */
    data: AgentRegisterResponse;
};

/**
 * Request to register a new AI agent account.
 * All fields are optional - an empty body is valid.
 */
export type AgentRegisterRequest = {
    /**
     * Optional custom display name for the agent.
     * If not provided, a unique celestial-themed name will be generated (e.g., "radiant-sirius").
     */
    name?: string | null;
};

/**
 * Response from agent registration endpoint
 */
export type AgentRegisterResponse = {
    /**
     * The newly created agent account
     */
    agent: AgentInfo;
    /**
     * Welcome message
     */
    message: string;
    /**
     * Setup instructions for getting started
     */
    setup: SetupInstructions;
    /**
     * Links to skill files and documentation
     */
    skill_files: SkillFiles;
    /**
     * Whether registration was successful
     */
    success: boolean;
};

/**
 * An agent task — tracks a single agent invocation lifecycle.
 */
export type AgentTask = {
    a2a_context_id?: string | null;
    a2a_task_id?: string | null;
    completed_at?: string | null;
    cost_cap_atomic?: number | null;
    cost_compute_atomic: number;
    cost_llm_atomic: number;
    cost_tool_atomic: number;
    cost_total_atomic: number;
    created_at: string;
    error_message?: string | null;
    id: string;
    input_message: unknown;
    metadata?: unknown;
    organization_id: string;
    output?: unknown;
    payment_request_id?: string | null;
    publisher_id: string;
    started_at?: string | null;
    status: AgentTaskStatus;
    trigger_type: AgentTriggerType;
    updated_at: string;
    user_id: string;
};

/**
 * An event in the agent task lifecycle (for SSE streaming).
 */
export type AgentTaskEvent = {
    created_at: string;
    event_type: string;
    id: string;
    payload: unknown;
    task_id: string;
};

/**
 * Agent task execution status, mirroring A2A TaskState with Seren additions.
 */
export type AgentTaskStatus = 'pending' | 'submitted' | 'working' | 'input_required' | 'completed' | 'failed' | 'canceled';

/**
 * Summary view of agent template for catalog listing
 */
export type AgentTemplateSummary = {
    description?: string | null;
    id: string;
    is_verified: boolean;
    language: TemplateLanguage;
    name: string;
    price_atomic: number;
    publisher_name?: string | null;
    publisher_slug?: string | null;
    slug: string;
    total_invocations: number;
};

/**
 * How the agent task was triggered.
 */
export type AgentTriggerType = 'manual' | 'api' | 'mcp' | 'cli' | 'desktop' | 'scheduled' | 'webhook';

/**
 * Request to update an agent's profile.
 */
export type AgentUpdateRequest = {
    /**
     * Email address to set and verify.
     * A verification email will be sent to this address.
     */
    email: string;
};

/**
 * Response struct for API key creation (includes the full key ONCE)
 */
export type ApiKeyCreated = {
    /**
     * The full API key (seren_<key_id>_<secret>) - shown ONCE.
     */
    api_key: string;
    created_at: string;
    expires_at?: string | null;
    id: string;
    key_id: string;
    name: string;
    organization_id: string;
};

/**
 * Response struct for listing API keys (never includes the secret)
 */
export type ApiKeyInfo = {
    created_at: string;
    expires_at?: string | null;
    id: string;
    key_id: string;
    key_prefix: string;
    last_used_at?: string | null;
    name: string;
    organization_id: string;
    revoked_at?: string | null;
};

/**
 * Request to apply a referral code
 */
export type ApplyReferralRequest = {
    referral_code: string;
};

/**
 * Minimal asset info for API responses
 */
export type AssetInfo = {
    contract_address?: string | null;
    decimals: number;
    id: string;
    is_native: boolean;
    is_stablecoin: boolean;
    name: string;
    network_id: string;
    network_name: string;
    symbol: string;
};

/**
 * Request to assign a role to a member
 */
export type AssignRoleRequest = {
    /**
     * Either role_id or role_name must be provided
     */
    role_id?: string | null;
    /**
     * Name of the role (owner, admin, editor, viewer, or custom role name)
     */
    role_name?: string | null;
};

/**
 * Audit log entry from the database
 */
export type AuditLog = {
    action: string;
    action_category?: string | null;
    actor_id?: string | null;
    actor_type: string;
    created_at: string;
    error_message?: string | null;
    id: string;
    ip_address?: string | null;
    metadata?: unknown;
    organization_id?: string | null;
    request_id?: string | null;
    resource_id?: string | null;
    resource_type: string;
    status: string;
    user_agent?: string | null;
};

/**
 * Response for listing audit logs
 */
export type AuditLogList = {
    data: Array<AuditLog>;
    limit: number;
    offset: number;
    total: number;
};

/**
 * High-level billing health summary.
 */
export type BillingHealth = {
    /**
     * Total failures recorded for the daily aggregation job since process start.
     */
    daily_aggregation_failures_total: number;
    /**
     * True when we have a recent daily aggregation run and no known failures.
     */
    daily_aggregation_ok: boolean;
    /**
     * True when the last daily aggregation was within the expected window (<= 30h old).
     */
    has_recent_daily_run: boolean;
    /**
     * Failure counters per billing job since process start.
     */
    jobs: Array<BillingJobHealth>;
    /**
     * Last time daily_aggregated_usage was written, in UTC (RFC3339).
     */
    last_daily_aggregation_run_utc?: string | null;
};

/**
 * Billing job health for a single background job.
 */
export type BillingJobHealth = {
    failures_total: number;
    job: string;
};

/**
 * Wrapped bonus claim response for OpenAPI
 */
export type BonusClaimDataResponse = {
    data: BonusClaimResponse;
};

/**
 * Response for claiming bonuses
 */
export type BonusClaimResponse = {
    amount_atomic: number;
    amount_usd: string;
    bonus_type: string;
    success: boolean;
};

/**
 * Request to upgrade/downgrade an organization's plan
 */
export type ChangePlanRequest = {
    plan_id: string;
    stripe_payment_method_id?: null | StripePaymentMethodId;
};

/**
 * Compute type - specific compute offering when publisher_category = Compute
 */
export type ComputeType = 'template' | 'workflow' | 'function' | 'agent';

/**
 * Debug view: compute_usage_events entry for an endpoint
 */
export type ComputeUsageEventDebugRecord = {
    event_time: string;
    event_type: string;
};

export type ConnectionsResponse = {
    connections: Array<UserOAuthConnectionResponse>;
};

/**
 * ConsumptionPeriodData for API responses (simplified)
 */
export type ConsumptionPeriodData = {
    active_time_seconds?: number;
    compute_time_seconds?: number;
    data_transfer_bytes?: number;
    period_id: string;
    synthetic_storage_size_bytes?: number;
    written_data_bytes?: number;
};

/**
 * ConsumptionSummary represents aggregated usage for a period
 */
export type ConsumptionSummary = {
    active_time_seconds?: number;
    compute_time_seconds?: number;
    data_transfer_bytes?: number;
    synthetic_storage_size_bytes?: number;
    written_data_bytes?: number;
};

/**
 * Cost estimate breakdown
 */
export type CostEstimate = {
    /**
     * Asset symbol (e.g., USDC, USDT)
     */
    asset_symbol: string;
    /**
     * Base cost in asset units (as decimal string)
     */
    base_cost: string;
    /**
     * Estimated rows to be returned
     */
    estimated_rows: number;
    /**
     * Markup multiplier
     */
    markup_multiplier: string;
    /**
     * Minimum charge in asset units
     */
    min_charge: string;
    /**
     * Total cost in asset units (as decimal string)
     */
    total_cost: string;
    /**
     * Total cost in atomic units
     */
    total_cost_atomic: number;
};

/**
 * Request to create a new API key
 */
export type CreateApiKeyRequest = {
    expires_in_days?: number | null;
    name: string;
};

export type CreateChargeRequest = {
    agent_wallet: string;
    amount_atomic: number;
    description: string;
    idempotency_key?: string | null;
};

/**
 * Request to create/update an OAuth provider (admin only)
 */
export type CreateOAuthProviderRequest = {
    authorization_url: string;
    client_id: string;
    /**
     * Client secret (will be encrypted)
     */
    client_secret: string;
    /**
     * Custom provider-specific authorization URL parameters (e.g., {"access_type": "offline"} for Google)
     */
    custom_auth_params?: unknown;
    description?: string | null;
    logo_url?: string | null;
    name: string;
    pkce_required?: boolean;
    revocation_url?: string | null;
    scopes: Array<string>;
    slug: string;
    token_endpoint_auth_method?: TokenEndpointAuthMethod;
    token_url: string;
    userinfo_url?: string | null;
};

/**
 * Request body for creating an organization invite.
 */
export type CreateOrganizationInviteRequest = {
    /**
     * Email address of the invitee.
     */
    email: string;
    /**
     * Optional role for the invitee (defaults to member).
     */
    role?: string | null;
};

export type CreateOrganizationVpcEndpointRequest = {
    endpoint_id: string;
    label?: string | null;
    region: string;
};

export type CreatePayoutRequest = {
    amount_atomic: number;
    description: string;
    destination_wallet: string;
    idempotency_key?: string | null;
};

/**
 * Request to create a publisher payout.
 */
export type CreatePublisherPayoutRequest = {
    /**
     * Amount to withdraw in atomic units (defaults to max available)
     */
    amount_atomic?: number | null;
    /**
     * Asset to withdraw (must be an asset accepted by the publisher)
     */
    asset_id: string;
    destination_wallet?: null | WalletAddress;
};

/**
 * Request to create a new publisher
 */
export type CreatePublisherRequest = {
    /**
     * A2A endpoint base URL (required for compute_type = agent)
     */
    a2a_endpoint_url?: string | null;
    /**
     * Asset IDs the publisher accepts for payment
     */
    accepted_asset_ids?: Array<string> | null;
    /**
     * Whitelist of agent-provided headers allowed to pass through to upstream
     */
    allowed_passthrough_headers?: Array<string>;
    /**
     * Headers for API requests (will be encrypted)
     */
    api_headers?: unknown;
    /**
     * Header name to inject upstream_api_key into (e.g., "Authorization", "X-API-Key")
     */
    api_key_header?: string | null;
    /**
     * Query parameter name to inject upstream_api_key into (e.g., "api_key")
     */
    api_key_query_param?: string | null;
    /**
     * External API URL (required for integration_type = api)
     */
    api_url?: string | null;
    /**
     * Upstream auth mode ("static", "jwt", or "oauth2_cc") (default: static)
     */
    auth_type?: string | null;
    base_price_per_1000_rows?: string | null;
    /**
     * Billing model ("x402_per_request", "prepaid_credits", "x402_passthrough", "pay_per_use")
     */
    billing_model?: string | null;
    /**
     * SerenDB branch ID (required for database_type = serendb)
     */
    branch_id?: string | null;
    /**
     * Publisher-declared capabilities for task matching
     */
    capabilities?: Array<string>;
    categories?: Array<string>;
    compute_type?: null | ComputeType;
    /**
     * Provider-specific configuration
     * For connection_string auth: { "connection_string": "postgresql://..." }
     */
    database_config?: unknown;
    /**
     * Database name within the SerenDB project (default: serendb)
     */
    database_name?: string | null;
    database_type?: null | DatabaseType;
    description?: string | null;
    /**
     * Publisher contact email for notifications and support
     */
    email?: string | null;
    /**
     * Structured endpoint definitions for LLM discoverability and access control
     */
    endpoints?: Array<EndpointDefinition> | null;
    /**
     * Gateway fee percentage for upstream x402 payments (pass-through).
     */
    gateway_fee_percent?: string | null;
    grace_period_minutes?: number | null;
    hourly_rate?: string | null;
    integration_type?: null | IntegrationType;
    /**
     * JWT access key / issuer claim (plaintext)
     */
    jwt_access_key?: string | null;
    /**
     * JWT signing algorithm ("HS256", "HS384", "HS512") (default: HS256)
     */
    jwt_algorithm?: string | null;
    /**
     * JWT expiration seconds (60-86400, default: 1800)
     */
    jwt_expiration_seconds?: number | null;
    /**
     * JWT secret key (will be encrypted)
     */
    jwt_secret_key?: string | null;
    /**
     * Optional publisher branding URL
     */
    logo_url?: string | null;
    low_balance_threshold?: string | null;
    markup_multiplier?: string | null;
    /**
     * MCP server endpoint URL (required for integration_type = mcp)
     */
    mcp_endpoint?: string | null;
    minimum_balance?: string | null;
    name: string;
    /**
     * OAuth2 client ID for Client Credentials flow
     */
    oauth2_client_id?: string | null;
    /**
     * OAuth2 client secret for Client Credentials flow (will be encrypted)
     */
    oauth2_client_secret?: string | null;
    /**
     * OAuth2 scopes to request during Client Credentials flow
     */
    oauth2_scopes?: Array<string>;
    /**
     * OAuth2 token endpoint URL for Client Credentials flow
     */
    oauth2_token_url?: string | null;
    /**
     * OAuth provider slug for BYOC (Bring Your Own Credentials) authentication.
     * When set along with requires_user_oauth=true, users must connect their own
     * OAuth account before using this publisher.
     */
    oauth_provider_slug?: string | null;
    /**
     * Enable resource ownership tracking (legacy gateway parity)
     */
    ownership_tracking_enabled?: boolean | null;
    price_per_call?: string | null;
    price_per_delete?: string | null;
    /**
     * Price per execution for agent templates or usage-based billing
     */
    price_per_execution?: string | null;
    price_per_get?: string | null;
    price_per_patch?: string | null;
    price_per_post?: string | null;
    price_per_put?: string | null;
    /**
     * SerenDB project ID (required for database_type = serendb)
     */
    project_id?: string | null;
    /**
     * Protected operations configuration - legacy, use endpoints[].is_protected instead
     */
    protected_operations?: unknown;
    /**
     * Publisher category: database, integration, or compute
     */
    publisher_category: PublisherCategory;
    publisher_type?: null | PublisherType;
    /**
     * Content-Type for upstream API requests (default: application/json)
     */
    request_content_type?: string | null;
    /**
     * If true, users must connect via OAuth before using this publisher (BYOC mode).
     * Requires oauth_provider_slug to be set.
     */
    requires_user_oauth?: boolean;
    /**
     * Maximum amount to reserve up-front for pay_per_use pre-authorization.
     */
    reserve_max_charge?: string | null;
    resource_description?: string | null;
    /**
     * JSONPath to resource ID in response body (for ownership tracking)
     */
    resource_id_response_path?: string | null;
    /**
     * URL pattern with :resourceId placeholder (for ownership tracking)
     */
    resource_id_url_pattern?: string | null;
    resource_name?: string | null;
    routing?: null | GeoRoutingConfig;
    slug: string;
    /**
     * TTL for cached exchanged tokens in seconds (60-86400, default: 3600)
     */
    token_cache_ttl_seconds?: number | null;
    /**
     * HTTP method for exchange endpoint (POST or GET, default: POST)
     */
    token_exchange_method?: string | null;
    /**
     * How to send Seren token: header, body, or query (default: header)
     */
    token_exchange_mode?: string | null;
    /**
     * URL to call for exchanging Seren API keys for publisher auth tokens
     */
    token_exchange_url?: string | null;
    /**
     * JSON field in exchange response containing the token (default: access_token)
     */
    token_response_field?: string | null;
    undocumented_endpoint_policy?: null | UndocumentedEndpointPolicy;
    /**
     * Fallback charge used when pay_per_use cost cannot be resolved from upstream response or token estimates.
     */
    unresolved_fallback_charge?: string | null;
    /**
     * Upstream static API key (will be encrypted)
     */
    upstream_api_key?: string | null;
    /**
     * Dot-separated path to upstream cost in response body (for pay_per_use and prepaid passthrough billing).
     * Example: "usage.cost"
     */
    upstream_cost_response_path?: string | null;
    /**
     * Non-sensitive headers to send to upstream API (e.g., User-Agent)
     */
    upstream_headers?: unknown;
    /**
     * Usage examples showing how to call the publisher's API
     */
    usage_examples?: Array<UsageExample> | null;
    /**
     * Human-readable use case descriptions
     */
    use_cases?: Array<string>;
    /**
     * Wallet address for receiving payments
     */
    wallet_address: WalletAddress;
    /**
     * Network ID for wallet (CAIP-2 format, e.g., "eip155:8453" for Base)
     */
    wallet_network_id: string;
};

/**
 * Request to create a custom role
 */
export type CreateRoleRequest = {
    description?: string | null;
    name: string;
    permissions: Array<string>;
};

/**
 * Request to create/publish an agent template
 */
export type CreateTemplateRequest = {
    /**
     * Template source code implementing run(input) -> output
     */
    code: string;
    /**
     * Preferred compute backend (e.g., "daytona", "modal"). If not specified, uses default.
     */
    computeBackend?: string | null;
    /**
     * Package dependencies (e.g., ["requests", "openai"])
     */
    dependencies?: Array<string> | null;
    /**
     * Description of what the template does
     */
    description?: string | null;
    /**
     * Programming language (python, typescript, javascript)
     */
    language: TemplateLanguage;
    llmConfig?: null | LlmConfig;
    /**
     * Display name
     */
    name: string;
    /**
     * Price per invocation (e.g., "0.05" for $0.05)
     */
    price: string;
    /**
     * URL-friendly slug (unique identifier)
     */
    slug: string;
};

/**
 * Response after creating a template
 */
export type CreateTemplateResponse = {
    createdAt: string;
    description?: string | null;
    id: string;
    isVerified: boolean;
    language: TemplateLanguage;
    name: string;
    priceAtomic: number;
    slug: string;
};

/**
 * Request to create a webhook
 */
export type CreateWebhookRequest = {
    events: Array<string>;
    name: string;
    project_id?: string | null;
    url: string;
};

/**
 * A validated currency code.
 *
 * Supports:
 * - ISO 4217 fiat currencies (USD, EUR, GBP, etc.)
 * - Common crypto currencies (USDC, SOL, ETH, etc.)
 *
 * # Examples
 *
 * ```
 * use seren_core::models::CurrencyCode;
 *
 * let usd = CurrencyCode::new("USD").unwrap();
 * let usdc = CurrencyCode::new("USDC").unwrap();
 * assert!(CurrencyCode::new("invalid").is_err());
 * ```
 */
export type CurrencyCode = string;

/**
 * Wrapped daily claim response for OpenAPI
 */
export type DailyClaimDataResponse = {
    data: DailyClaimResponse;
};

/**
 * Wrapped daily eligibility response for OpenAPI
 */
export type DailyClaimEligibilityDataResponse = {
    data: DailyClaimEligibilityResponse;
};

/**
 * Response for daily claim eligibility check
 */
export type DailyClaimEligibilityResponse = {
    can_claim: boolean;
    /**
     * Formatted USD amount that will be granted on a successful daily claim.
     * Optional to avoid breaking older clients.
     */
    claim_amount_usd?: string | null;
    claims_remaining_this_month: number;
    reason?: string | null;
    /**
     * Seconds until the daily claim resets (midnight UTC).
     * Only present when can_claim is false due to already claiming today.
     */
    resets_in_seconds?: number | null;
};

/**
 * Response for claiming daily credits
 */
export type DailyClaimResponse = {
    amount_atomic: number;
    amount_usd: string;
    balance_atomic: number;
    balance_usd: string;
    claims_remaining_this_month: number;
    success: boolean;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseAgentTask = {
    /**
     * An agent task — tracks a single agent invocation lifecycle.
     */
    data: {
        a2a_context_id?: string | null;
        a2a_task_id?: string | null;
        completed_at?: string | null;
        cost_cap_atomic?: number | null;
        cost_compute_atomic: number;
        cost_llm_atomic: number;
        cost_tool_atomic: number;
        cost_total_atomic: number;
        created_at: string;
        error_message?: string | null;
        id: string;
        input_message: unknown;
        metadata?: unknown;
        organization_id: string;
        output?: unknown;
        payment_request_id?: string | null;
        publisher_id: string;
        started_at?: string | null;
        status: AgentTaskStatus;
        trigger_type: AgentTriggerType;
        updated_at: string;
        user_id: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseApiKeyCreated = {
    /**
     * Response struct for API key creation (includes the full key ONCE)
     */
    data: {
        /**
         * The full API key (seren_<key_id>_<secret>) - shown ONCE.
         */
        api_key: string;
        created_at: string;
        expires_at?: string | null;
        id: string;
        key_id: string;
        name: string;
        organization_id: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseAuditLog = {
    /**
     * Audit log entry from the database
     */
    data: {
        action: string;
        action_category?: string | null;
        actor_id?: string | null;
        actor_type: string;
        created_at: string;
        error_message?: string | null;
        id: string;
        ip_address?: string | null;
        metadata?: unknown;
        organization_id?: string | null;
        request_id?: string | null;
        resource_id?: string | null;
        resource_type: string;
        status: string;
        user_agent?: string | null;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseAuditLogList = {
    /**
     * Response for listing audit logs
     */
    data: {
        data: Array<AuditLog>;
        limit: number;
        offset: number;
        total: number;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseBillingHealth = {
    /**
     * High-level billing health summary.
     */
    data: {
        /**
         * Total failures recorded for the daily aggregation job since process start.
         */
        daily_aggregation_failures_total: number;
        /**
         * True when we have a recent daily aggregation run and no known failures.
         */
        daily_aggregation_ok: boolean;
        /**
         * True when the last daily aggregation was within the expected window (<= 30h old).
         */
        has_recent_daily_run: boolean;
        /**
         * Failure counters per billing job since process start.
         */
        jobs: Array<BillingJobHealth>;
        /**
         * Last time daily_aggregated_usage was written, in UTC (RFC3339).
         */
        last_daily_aggregation_run_utc?: string | null;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseCreateTemplateResponse = {
    /**
     * Response after creating a template
     */
    data: {
        createdAt: string;
        description?: string | null;
        id: string;
        isVerified: boolean;
        language: TemplateLanguage;
        name: string;
        priceAtomic: number;
        slug: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseEndpointBillingEvents = {
    /**
     * Combined debug response for an endpoint's billing events
     */
    data: {
        compute_usage_events: Array<ComputeUsageEventDebugRecord>;
        endpoint_id: string;
        organization_id: string;
        usage_events: Array<UsageEventDebugRecord>;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseFederatedResourceResponse = {
    /**
     * Response for a single federated resource
     */
    data: {
        created_at: string;
        expires_at?: string | null;
        external_id: string;
        id: string;
        metadata: unknown;
        org_database_id?: string | null;
        publisher_id: string;
        resource_type: string;
        status: string;
        updated_at: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseFederationHistoryStatsResponse = {
    /**
     * Response for federation history aggregate statistics.
     */
    data: {
        by_operation: {
            [key: string]: number;
        };
        by_status: {
            [key: string]: number;
        };
        by_type: {
            [key: string]: number;
        };
        total_events: number;
        unique_publishers: number;
        unique_resources: number;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseFederationStatsResponse = {
    /**
     * Response for federation statistics
     */
    data: {
        by_status: {
            [key: string]: number;
        };
        by_type: {
            [key: string]: number;
        };
        total_active: number;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseInvoice = {
    /**
     * Invoice response with line items
     */
    data: {
        id: string;
        invoice_number: string;
        line_items: Array<InvoiceLineItem>;
        organization_id: string;
        period_end: string;
        period_start: string;
        status: string;
        subtotal_usd: string;
        tax_usd: string;
        total_usd: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseInvoicesGenerated = {
    /**
     * Response for invoice generation
     */
    data: {
        count: number;
        invoice_ids: Array<string>;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseInvokeTemplateResponse = {
    /**
     * Response from invoking a template
     */
    data: {
        /**
         * Cost breakdown
         */
        cost: InvocationCostBreakdown;
        /**
         * Execution time in milliseconds
         */
        executionTimeMs: number;
        /**
         * Invocation ID for tracking
         */
        invocationId: string;
        /**
         * Output from template execution
         */
        result: unknown;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseLoginResult = {
    data: {
        access_token: string;
        /**
         * The user's default organization ID for API calls requiring an organization context.
         * This is typically the first organization the user joined (their personal org).
         */
        default_organization_id: string;
        expires_in: number;
        refresh_token: string;
        user: UserInfo;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseLogoUploadResponse = {
    /**
     * Logo upload response
     */
    data: {
        /**
         * URL to access the uploaded logo
         */
        logo_url: string;
        /**
         * Message indicating success
         */
        message: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseOrganizationConsumption = {
    /**
     * OrganizationConsumption wraps organization-wide consumption
     */
    data: {
        current_month: ConsumptionSummary;
        from: string;
        organization_id: string;
        periods: Array<ConsumptionPeriodData>;
        to: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseOrganizationInvite = {
    /**
     * Response type for organization invites (token is not exposed over the API).
     */
    data: {
        accepted_at?: string | null;
        created_at: string;
        email: string;
        expires_at: string;
        id: string;
        invited_by: string;
        organization_id: string;
        revoked_at?: string | null;
        role: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseOrganizationPlanWithDetails = {
    /**
     * Response type that includes both the plan and organization_plan details
     */
    data: {
        organization_plan: OrganizationPlan;
        plan: Plan;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseOrganizationVpcEndpoint = {
    data: {
        created_at: string;
        endpoint_id: string;
        id: string;
        label?: string | null;
        organization_id: string;
        region: string;
        state: string;
        updated_at: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponsePasswordReset = {
    data: {
        message: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponsePasswordResetSent = {
    data: {
        message: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponsePaymentHistory = {
    /**
     * Payment history response
     */
    data: {
        payments: Array<PaymentRecord>;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponsePaymentIntentCreated = {
    /**
     * Response for creating a payment intent
     */
    data: {
        /**
         * Amount to be charged, in cents.
         */
        amount_cents: number;
        /**
         * Amount to be charged, in USD.
         */
        amount_usd: string;
        client_secret: string;
        currency: CurrencyCode;
        payment_intent_id: StripePaymentIntentId;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponsePaymentMethodAdded = {
    /**
     * Response for adding a payment method
     */
    data: {
        id: string;
        message: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponsePlan = {
    /**
     * Plan represents a subscription tier (Free, Launch, Scale)
     */
    data: {
        audit_logs_enabled: boolean;
        branch_price_per_hour?: string | null;
        compute_hours_quota?: number | null;
        compute_price_per_cu_hour?: string | null;
        created_at: string;
        data_transfer_gb_included?: number | null;
        data_transfer_price_per_gb?: string | null;
        description?: string | null;
        display_name: string;
        id: string;
        ip_allowlist_enabled: boolean;
        is_active: boolean;
        max_branches_per_project: number;
        max_compute_units: number;
        max_databases_per_branch?: number | null;
        max_endpoints_per_branch?: number | null;
        max_projects?: number | null;
        monitoring_enabled: boolean;
        monitoring_retention_days?: number | null;
        name: string;
        pitr_price_per_gb_month?: string | null;
        pitr_retention_hours?: number | null;
        price_monthly: string;
        scale_to_zero_delay_seconds?: number | null;
        sla_uptime_percent?: string | null;
        sort_order: number;
        sso_enabled: boolean;
        storage_gb_quota?: string | null;
        storage_price_per_gb_month?: string | null;
        /**
         * Stripe Price ID used for recurring subscriptions on this plan (for paid tiers).
         */
        stripe_price_id?: string | null;
        support_level: string;
        updated_at: string;
        vpc_enabled: boolean;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponsePricingConfigResponse = {
    /**
     * Pricing config response
     */
    data: {
        /**
         * Asset this pricing applies to
         */
        asset_id: string;
        /**
         * Asset symbol for display
         */
        asset_symbol?: string | null;
        base_price_per_1000_rows: string;
        grace_period_minutes?: number | null;
        hourly_rate?: string | null;
        low_balance_threshold: string;
        markup_multiplier: string;
        max_queries_per_minute?: number | null;
        min_charge: string;
        /**
         * Minimum price to display in UI for passthrough publishers (informational only)
         */
        min_display_price?: string | null;
        minimum_balance: string;
        onchain_enabled: boolean;
        payment_expiry_minutes: number;
        prepaid_enabled: boolean;
        price_per_call?: string | null;
        price_per_delete?: string | null;
        /**
         * Price per execution for agent templates or usage-based billing
         */
        price_per_execution?: string | null;
        price_per_get?: string | null;
        price_per_patch?: string | null;
        price_per_post?: string | null;
        price_per_put?: string | null;
        /**
         * Text to display for variable pricing (e.g., "Varies by model")
         */
        pricing_display_text?: string | null;
        pricing_model: PricingModel;
        reserve_max_charge?: string | null;
        unresolved_fallback_charge?: string | null;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponsePublisherAgentBalance = {
    data: {
        onchain_atomic?: number | null;
        serenbucks_atomic: number;
        total_available_atomic: number;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponsePublisherAnalytics = {
    /**
     * Response for publisher analytics
     */
    data: {
        publisher_id: string;
        templates: Array<TemplateAnalytics>;
        totals: PublisherAnalyticsTotals;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponsePublisherChargeInfo = {
    data: {
        agent_wallet: string;
        amount_atomic: number;
        id: string;
        status: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponsePublisherPayoutInfo = {
    data: {
        amount_atomic: number;
        destination_wallet: string;
        error_message?: string | null;
        id: string;
        status: string;
        tx_hash?: string | null;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponsePublisherPayoutResponse = {
    /**
     * Publisher payout response.
     */
    data: {
        amount: number;
        amount_atomic: number;
        asset: AssetInfo;
        destination_wallet: WalletAddress;
        error_message?: string | null;
        id: string;
        publisher_id: string;
        requested_at: string;
        status: PayoutStatus;
        tx_hash?: string | null;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponsePublisherResponse = {
    /**
     * Publisher response (excludes sensitive fields)
     */
    data: {
        /**
         * Cached A2A agent card
         */
        a2a_agent_card?: unknown;
        /**
         * A2A endpoint base URL (for compute_type = agent)
         */
        a2a_endpoint_url?: string | null;
        /**
         * A2A health status: unknown, healthy, unhealthy, unreachable
         */
        a2a_health_status?: string | null;
        /**
         * Accepted assets for payment
         */
        accepted_assets?: Array<AssetInfo> | null;
        allowed_passthrough_headers: Array<string>;
        /**
         * Header name to inject upstream_api_key into (e.g., "Authorization", "X-API-Key")
         */
        api_key_header?: string | null;
        /**
         * Query parameter name to inject upstream_api_key into (e.g., "api_key", "apiKey")
         */
        api_key_query_param?: string | null;
        /**
         * External API URL (for integration_type = api)
         */
        api_url?: string | null;
        billing_model: string;
        /**
         * SerenDB branch ID (for database_type = serendb)
         */
        branch_id?: string | null;
        /**
         * Publisher-declared capabilities for task matching
         */
        capabilities: Array<string>;
        categories: Array<string>;
        compute_type?: null | ComputeType;
        created_at: string;
        /**
         * Provider config (sensitive fields redacted)
         */
        database_config?: unknown;
        /**
         * Database name within the SerenDB project
         */
        database_name?: string | null;
        database_type?: null | DatabaseType;
        description?: string | null;
        /**
         * Publisher contact email for notifications and support
         */
        email?: string | null;
        /**
         * Structured endpoint definitions for LLM discoverability and access control
         */
        endpoints?: Array<EndpointDefinition> | null;
        gateway_fee_percent: string;
        id: string;
        integration_type?: null | IntegrationType;
        is_active: boolean;
        is_verified: boolean;
        logo_url?: string | null;
        /**
         * Cached MCP capabilities (tools, resources, prompts)
         */
        mcp_capabilities?: unknown;
        /**
         * MCP server endpoint URL (for integration_type = mcp)
         */
        mcp_endpoint?: string | null;
        name: string;
        /**
         * OAuth provider ID for BYOC (Bring Your Own Credentials) authentication
         */
        oauth_provider_id?: string | null;
        ownership_tracking_enabled: boolean;
        /**
         * Pricing config per asset (if included)
         */
        pricing?: Array<PricingConfigResponse> | null;
        /**
         * SerenDB project ID (for database_type = serendb)
         */
        project_id?: string | null;
        protected_operations?: unknown;
        /**
         * Publisher category: database, integration, or compute
         */
        publisher_category: PublisherCategory;
        publisher_type: PublisherType;
        /**
         * Content-Type for upstream API requests
         */
        request_content_type: string;
        /**
         * If true, users must connect via OAuth before using this publisher
         */
        requires_user_oauth: boolean;
        resource_description?: string | null;
        resource_id_response_path?: string | null;
        resource_id_url_pattern?: string | null;
        resource_name?: string | null;
        routing?: null | GeoRoutingConfig;
        slug: string;
        /**
         * TTL for cached exchanged tokens in seconds
         */
        token_cache_ttl_seconds?: number | null;
        /**
         * HTTP method for exchange endpoint (POST or GET)
         */
        token_exchange_method?: string | null;
        /**
         * How to send Seren token: header, body, or query
         */
        token_exchange_mode?: string | null;
        /**
         * URL to call for exchanging Seren API keys for publisher auth tokens
         */
        token_exchange_url?: string | null;
        /**
         * JSON field in exchange response containing the token
         */
        token_response_field?: string | null;
        total_queries: number;
        /**
         * Policy for handling requests to paths not in the endpoints catalog
         */
        undocumented_endpoint_policy: UndocumentedEndpointPolicy;
        unique_agents_served: number;
        updated_at: string;
        /**
         * Dot-separated path to upstream cost in response body (for pay_per_use and prepaid passthrough billing).
         * Example: "usage.cost"
         */
        upstream_cost_response_path?: string | null;
        /**
         * Non-sensitive headers to send to upstream API
         */
        upstream_headers: unknown;
        /**
         * Usage examples showing how to call the publisher's API
         */
        usage_examples?: Array<UsageExample> | null;
        /**
         * Human-readable use case descriptions
         */
        use_cases: Array<string>;
        /**
         * When verification expires (NULL = no expiry)
         */
        verification_expires_at?: string | null;
        wallet_address: WalletAddress;
        /**
         * Network for the wallet address
         */
        wallet_network_id: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseQuotaUsage = {
    /**
     * Quota usage summary for an organization
     */
    data: {
        compute_hours_usage_percent?: number | null;
        current_branches: number;
        current_compute_hours: number;
        current_projects: number;
        current_storage_gb: number;
        is_over_compute_quota: boolean;
        is_over_projects_quota: boolean;
        is_over_storage_quota: boolean;
        organization_id: string;
        plan: Plan;
        projects_usage_percent?: number | null;
        storage_usage_percent?: number | null;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseRbacRole = {
    /**
     * Response after creating or updating a role
     */
    data: {
        created_at: string;
        description?: string | null;
        id: string;
        is_built_in: boolean;
        name: string;
        permissions: Array<string>;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseSessionsRevoked = {
    data: {
        message: string;
        revoked_count: number;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseSuggestResponse = {
    /**
     * Response for suggest endpoint
     * Returns publisher and agent recommendations based on task/query matching
     */
    data: {
        /**
         * Matched agents sorted by relevance (agent templates coming soon)
         */
        agents: Array<unknown>;
        /**
         * Matched publishers sorted by relevance
         */
        publishers: Array<PublisherSuggestion>;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseUserMe = {
    /**
     * Response for GET /auth/me - current user info with default organization
     */
    data: UserInfo & {
        /**
         * The user's default organization ID for API calls requiring an organization context.
         * This is typically the first organization the user joined (their personal org).
         */
        default_organization_id: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecAgentTask = {
    data: Array<{
        a2a_context_id?: string | null;
        a2a_task_id?: string | null;
        completed_at?: string | null;
        cost_cap_atomic?: number | null;
        cost_compute_atomic: number;
        cost_llm_atomic: number;
        cost_tool_atomic: number;
        cost_total_atomic: number;
        created_at: string;
        error_message?: string | null;
        id: string;
        input_message: unknown;
        metadata?: unknown;
        organization_id: string;
        output?: unknown;
        payment_request_id?: string | null;
        publisher_id: string;
        started_at?: string | null;
        status: AgentTaskStatus;
        trigger_type: AgentTriggerType;
        updated_at: string;
        user_id: string;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecAgentTaskEvent = {
    data: Array<{
        created_at: string;
        event_type: string;
        id: string;
        payload: unknown;
        task_id: string;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecAgentTemplateSummary = {
    data: Array<{
        description?: string | null;
        id: string;
        is_verified: boolean;
        language: TemplateLanguage;
        name: string;
        price_atomic: number;
        publisher_name?: string | null;
        publisher_slug?: string | null;
        slug: string;
        total_invocations: number;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecApiKeyInfo = {
    data: Array<{
        created_at: string;
        expires_at?: string | null;
        id: string;
        key_id: string;
        key_prefix: string;
        last_used_at?: string | null;
        name: string;
        organization_id: string;
        revoked_at?: string | null;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecDatabaseWithContext = {
    data: Array<{
        /**
         * Branch ID
         */
        branch_id: string;
        /**
         * Human-readable branch name
         */
        branch_name: string;
        created_at: string;
        /**
         * Database ID
         */
        id: string;
        /**
         * Whether this is the project's default branch
         */
        is_default_branch: boolean;
        /**
         * Database name
         */
        name: string;
        /**
         * Database owner role name
         */
        owner_name?: string | null;
        /**
         * Project ID
         */
        project_id: string;
        /**
         * Human-readable project name
         */
        project_name: string;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecFederatedResourceHistoryResponse = {
    data: Array<{
        changed_at: string;
        expires_at?: string | null;
        external_id: string;
        federation_id?: string | null;
        id: string;
        metadata: unknown;
        operation: string;
        org_database_id?: string | null;
        publisher_id: string;
        publisher_name?: string | null;
        publisher_slug?: string | null;
        resource_type: string;
        status: string;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecFederatedResourceWithPublisherResponse = {
    data: Array<{
        created_at: string;
        expires_at?: string | null;
        external_id: string;
        id: string;
        metadata: unknown;
        org_database_id?: string | null;
        publisher_id: string;
        publisher_name: string;
        publisher_slug: string;
        resource_type: string;
        status: string;
        updated_at: string;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecOrganization = {
    data: Array<{
        created_at: string;
        created_by: string;
        deleted_at?: string | null;
        id: string;
        is_personal: boolean;
        name: string;
        slug: Slug;
        /**
         * Stripe Customer ID for this organization (if billing is enabled).
         */
        stripe_customer_id?: string | null;
        updated_at: string;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecOrganizationInvite = {
    data: Array<{
        accepted_at?: string | null;
        created_at: string;
        email: string;
        expires_at: string;
        id: string;
        invited_by: string;
        organization_id: string;
        revoked_at?: string | null;
        role: string;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecOrganizationMemberWithUser = {
    data: Array<{
        created_at: string;
        email: Email;
        id: string;
        name?: string | null;
        organization_id: string;
        role: string;
        user_id: string;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecPaymentMethod = {
    data: Array<{
        bank_last4?: string | null;
        card_brand?: string | null;
        card_exp_month?: number | null;
        card_exp_year?: number | null;
        card_last4?: string | null;
        id: string;
        is_default: boolean;
        type_: string;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecPlan = {
    data: Array<{
        audit_logs_enabled: boolean;
        branch_price_per_hour?: string | null;
        compute_hours_quota?: number | null;
        compute_price_per_cu_hour?: string | null;
        created_at: string;
        data_transfer_gb_included?: number | null;
        data_transfer_price_per_gb?: string | null;
        description?: string | null;
        display_name: string;
        id: string;
        ip_allowlist_enabled: boolean;
        is_active: boolean;
        max_branches_per_project: number;
        max_compute_units: number;
        max_databases_per_branch?: number | null;
        max_endpoints_per_branch?: number | null;
        max_projects?: number | null;
        monitoring_enabled: boolean;
        monitoring_retention_days?: number | null;
        name: string;
        pitr_price_per_gb_month?: string | null;
        pitr_retention_hours?: number | null;
        price_monthly: string;
        scale_to_zero_delay_seconds?: number | null;
        sla_uptime_percent?: string | null;
        sort_order: number;
        sso_enabled: boolean;
        storage_gb_quota?: string | null;
        storage_price_per_gb_month?: string | null;
        /**
         * Stripe Price ID used for recurring subscriptions on this plan (for paid tiers).
         */
        stripe_price_id?: string | null;
        support_level: string;
        updated_at: string;
        vpc_enabled: boolean;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecPublisherEarningsResponse = {
    data: Array<{
        asset: AssetInfo;
        available: number;
        available_atomic: number;
        pending_payout: number;
        pending_payout_atomic: number;
        publisher_id: string;
        publisher_name: string;
        publisher_slug: string;
        /**
         * Count of billable transactions for this asset (query_charge, api_call, service_fee).
         */
        request_count: number;
        total_revenue: number;
        total_revenue_atomic: number;
        total_withdrawn: number;
        total_withdrawn_atomic: number;
        wallet_address: WalletAddress;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecPublisherPayoutResponse = {
    data: Array<{
        amount: number;
        amount_atomic: number;
        asset: AssetInfo;
        destination_wallet: WalletAddress;
        error_message?: string | null;
        id: string;
        publisher_id: string;
        requested_at: string;
        status: PayoutStatus;
        tx_hash?: string | null;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecPublisherResponse = {
    data: Array<{
        /**
         * Cached A2A agent card
         */
        a2a_agent_card?: unknown;
        /**
         * A2A endpoint base URL (for compute_type = agent)
         */
        a2a_endpoint_url?: string | null;
        /**
         * A2A health status: unknown, healthy, unhealthy, unreachable
         */
        a2a_health_status?: string | null;
        /**
         * Accepted assets for payment
         */
        accepted_assets?: Array<AssetInfo> | null;
        allowed_passthrough_headers: Array<string>;
        /**
         * Header name to inject upstream_api_key into (e.g., "Authorization", "X-API-Key")
         */
        api_key_header?: string | null;
        /**
         * Query parameter name to inject upstream_api_key into (e.g., "api_key", "apiKey")
         */
        api_key_query_param?: string | null;
        /**
         * External API URL (for integration_type = api)
         */
        api_url?: string | null;
        billing_model: string;
        /**
         * SerenDB branch ID (for database_type = serendb)
         */
        branch_id?: string | null;
        /**
         * Publisher-declared capabilities for task matching
         */
        capabilities: Array<string>;
        categories: Array<string>;
        compute_type?: null | ComputeType;
        created_at: string;
        /**
         * Provider config (sensitive fields redacted)
         */
        database_config?: unknown;
        /**
         * Database name within the SerenDB project
         */
        database_name?: string | null;
        database_type?: null | DatabaseType;
        description?: string | null;
        /**
         * Publisher contact email for notifications and support
         */
        email?: string | null;
        /**
         * Structured endpoint definitions for LLM discoverability and access control
         */
        endpoints?: Array<EndpointDefinition> | null;
        gateway_fee_percent: string;
        id: string;
        integration_type?: null | IntegrationType;
        is_active: boolean;
        is_verified: boolean;
        logo_url?: string | null;
        /**
         * Cached MCP capabilities (tools, resources, prompts)
         */
        mcp_capabilities?: unknown;
        /**
         * MCP server endpoint URL (for integration_type = mcp)
         */
        mcp_endpoint?: string | null;
        name: string;
        /**
         * OAuth provider ID for BYOC (Bring Your Own Credentials) authentication
         */
        oauth_provider_id?: string | null;
        ownership_tracking_enabled: boolean;
        /**
         * Pricing config per asset (if included)
         */
        pricing?: Array<PricingConfigResponse> | null;
        /**
         * SerenDB project ID (for database_type = serendb)
         */
        project_id?: string | null;
        protected_operations?: unknown;
        /**
         * Publisher category: database, integration, or compute
         */
        publisher_category: PublisherCategory;
        publisher_type: PublisherType;
        /**
         * Content-Type for upstream API requests
         */
        request_content_type: string;
        /**
         * If true, users must connect via OAuth before using this publisher
         */
        requires_user_oauth: boolean;
        resource_description?: string | null;
        resource_id_response_path?: string | null;
        resource_id_url_pattern?: string | null;
        resource_name?: string | null;
        routing?: null | GeoRoutingConfig;
        slug: string;
        /**
         * TTL for cached exchanged tokens in seconds
         */
        token_cache_ttl_seconds?: number | null;
        /**
         * HTTP method for exchange endpoint (POST or GET)
         */
        token_exchange_method?: string | null;
        /**
         * How to send Seren token: header, body, or query
         */
        token_exchange_mode?: string | null;
        /**
         * URL to call for exchanging Seren API keys for publisher auth tokens
         */
        token_exchange_url?: string | null;
        /**
         * JSON field in exchange response containing the token
         */
        token_response_field?: string | null;
        total_queries: number;
        /**
         * Policy for handling requests to paths not in the endpoints catalog
         */
        undocumented_endpoint_policy: UndocumentedEndpointPolicy;
        unique_agents_served: number;
        updated_at: string;
        /**
         * Dot-separated path to upstream cost in response body (for pay_per_use and prepaid passthrough billing).
         * Example: "usage.cost"
         */
        upstream_cost_response_path?: string | null;
        /**
         * Non-sensitive headers to send to upstream API
         */
        upstream_headers: unknown;
        /**
         * Usage examples showing how to call the publisher's API
         */
        usage_examples?: Array<UsageExample> | null;
        /**
         * Human-readable use case descriptions
         */
        use_cases: Array<string>;
        /**
         * When verification expires (NULL = no expiry)
         */
        verification_expires_at?: string | null;
        wallet_address: WalletAddress;
        /**
         * Network for the wallet address
         */
        wallet_network_id: string;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecRbacRole = {
    data: Array<{
        created_at: string;
        description?: string | null;
        id: string;
        is_built_in: boolean;
        name: string;
        permissions: Array<string>;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecUsageSummary = {
    data: Array<{
        compute_cost_usd: string;
        compute_hours_large: number;
        compute_hours_medium: number;
        compute_hours_small: number;
        compute_hours_xlarge: number;
        organization_id: string;
        period_end: string;
        period_start: string;
        pitr_gb_avg: number;
        project_id: string;
        /**
         * Human-readable project name (denormalized for convenience).
         */
        project_name: string;
        /**
         * Cloud region for the project (e.g., aws-us-east-1).
         */
        project_region: string;
        storage_cost_usd: string;
        storage_gb_avg: number;
        total_cost_usd: string;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecWebhookInfo = {
    data: Array<{
        created_at: string;
        created_by: string;
        enabled: boolean;
        events: Array<string>;
        id: string;
        name: string;
        organization_id: string;
        project_id?: string | null;
        url: string;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVerificationSent = {
    data: {
        message: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseWebhookCreated = {
    /**
     * Webhook created response (includes secret on creation only)
     */
    data: {
        /**
         * The webhook secret - only shown once at creation time
         */
        secret: string;
        webhook: WebhookInfo;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseWebhookInfo = {
    /**
     * Webhook response (hides secret)
     */
    data: {
        created_at: string;
        created_by: string;
        enabled: boolean;
        events: Array<string>;
        id: string;
        name: string;
        organization_id: string;
        project_id?: string | null;
        url: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Request body for database queries
 */
export type DatabaseQueryRequest = {
    /**
     * Optional database name (primarily for SerenDB publishers)
     */
    database?: string | null;
    /**
     * Query parameters
     */
    params?: Array<unknown>;
    /**
     * Query payload to execute.
     *
     * - SQL publishers (serendb/neon/supabase): SQL string
     * - MongoDB publishers: JSON string matching `MongoDbQuery`
     */
    query: string;
};

/**
 * Database type - specific database provider when publisher_category = Database
 */
export type DatabaseType = 'serendb' | 'neon' | 'supabase' | 'mongodb';

/**
 * Database with full project and branch context for cross-project listing
 */
export type DatabaseWithContext = {
    /**
     * Branch ID
     */
    branch_id: string;
    /**
     * Human-readable branch name
     */
    branch_name: string;
    created_at: string;
    /**
     * Database ID
     */
    id: string;
    /**
     * Whether this is the project's default branch
     */
    is_default_branch: boolean;
    /**
     * Database name
     */
    name: string;
    /**
     * Database owner role name
     */
    owner_name?: string | null;
    /**
     * Project ID
     */
    project_id: string;
    /**
     * Human-readable project name
     */
    project_name: string;
};

export type DelegationType = 'in_loop' | 'full_handoff';

/**
 * Wrapped deposit response for OpenAPI
 */
export type DepositDataResponse = {
    data: DepositResponse;
};

/**
 * Request to deposit funds via Stripe
 */
export type DepositRequest = {
    /**
     * Amount in USD cents (minimum 500 = $5.00)
     */
    amount_cents: number;
    /**
     * Optional affiliate referral code for tracking
     */
    referral_code?: string | null;
};

/**
 * Response for wallet deposit initiation
 */
export type DepositResponse = {
    /**
     * Base deposit amount in atomic units
     */
    amount_atomic: number;
    amount_usd: string;
    /**
     * Tier bonus in atomic units (if applicable)
     */
    bonus_atomic: number;
    bonus_usd: string;
    /**
     * URL to the Stripe hosted checkout page - open this in a browser to complete payment
     */
    checkout_url: string;
    deposit_id: string;
    /**
     * Total to be credited in atomic units
     */
    total_atomic: number;
    total_usd: string;
};

/**
 * EIP-712 domain (matches ethereum.rs Eip712Domain)
 */
export type Eip712Domain = {
    chainId: number;
    name: string;
    verifyingContract: string;
    version: string;
};

/**
 * EIP-712 message for TransferWithAuthorization
 */
export type Eip712Message = {
    from: string;
    nonce: string;
    to: string;
    validAfter: string;
    validBefore: string;
    value: string;
};

/**
 * EIP-712 typed data for signing payment authorization
 */
export type Eip712TypedData = {
    domain: Eip712Domain;
    message: Eip712Message;
    primaryType: string;
    types: Eip712Types;
};

/**
 * EIP-712 type definitions
 */
export type Eip712Types = {
    EIP712Domain: Array<TypedParam>;
    TransferWithAuthorization: Array<TypedParam>;
};

/**
 * A validated email address.
 *
 * This type ensures email addresses are validated at construction time.
 * Stored as TEXT in the database via SQLx's transparent encoding.
 *
 * # Examples
 *
 * ```
 * use seren_core::models::Email;
 *
 * let email = Email::new("user@example.com").unwrap();
 * assert!(Email::new("invalid").is_err());
 * ```
 */
export type Email = string;

/**
 * Combined debug response for an endpoint's billing events
 */
export type EndpointBillingEvents = {
    compute_usage_events: Array<ComputeUsageEventDebugRecord>;
    endpoint_id: string;
    organization_id: string;
    usage_events: Array<UsageEventDebugRecord>;
};

/**
 * A structured endpoint definition for LLM discoverability and access control
 */
export type EndpointDefinition = {
    /**
     * Template for request body with {{query}} placeholder for user input
     * Used by browser extensions and LLMs to construct valid requests
     */
    body_template?: unknown;
    /**
     * Human-readable description of what this endpoint does
     */
    description?: string | null;
    /**
     * Example request body
     */
    example_request?: unknown;
    /**
     * Example response body
     */
    example_response?: unknown;
    /**
     * Whether this is the default endpoint for simple queries
     * When multiple endpoints exist, the default is used for basic operations
     */
    is_default?: boolean;
    /**
     * Whether this endpoint is blocked from agent access
     * Protected endpoints are documented but return 403 if called
     */
    is_protected?: boolean;
    /**
     * HTTP method (GET, POST, PUT, DELETE, PATCH)
     */
    method: HttpMethod;
    /**
     * Path relative to api_url (e.g., "/chat/completions")
     */
    path: string;
    /**
     * Endpoint-specific price override (in asset decimals, e.g., "0.49" for $0.49)
     * If set, takes precedence over method-level pricing (price_per_post, etc.)
     */
    price?: string | null;
    /**
     * Reason for protection (shown in 403 response, e.g., "Data redistribution policy")
     */
    protection_reason?: string | null;
    /**
     * Query parameter definitions
     */
    query_params?: Array<QueryParamDefinition> | null;
    /**
     * Request body schema (JSON Schema or simplified description)
     */
    request_body?: unknown;
    /**
     * Headers required for this endpoint (beyond publisher defaults)
     */
    required_headers?: Array<string> | null;
    /**
     * Response schema (JSON Schema or simplified description)
     */
    response?: unknown;
};

/**
 * Query estimate request body
 */
export type EstimateRequestBody = {
    /**
     * Optional asset id to estimate pricing for (defaults to publisher primary asset)
     */
    asset_id?: string | null;
    /**
     * Publisher UUID
     */
    publisher_id: string;
    /**
     * Query payload to estimate.
     *
     * - SQL publishers (serendb/neon/supabase): SQL string
     * - MongoDB publishers: JSON string matching `MongoDbQuery`
     */
    query: string;
};

/**
 * Query estimate response
 */
export type EstimateResponse = {
    /**
     * Asset symbol (e.g., USDC, USDT)
     */
    asset_symbol: string;
    /**
     * Estimated cost in configured asset
     */
    estimated_cost: string;
    /**
     * Estimated cost in atomic units
     */
    estimated_cost_atomic: number;
    /**
     * Estimated rows to be returned
     */
    estimated_rows: number;
    /**
     * Publisher name
     */
    publisher_name: string;
    /**
     * Publisher slug
     */
    publisher_slug: string;
};

export type EvalMatrixEntry = {
    score: number;
    signal_count: number;
};

export type EvalMatrixResponse = {
    generated_at: string;
    matrix: {
        [key: string]: {
            [key: string]: EvalMatrixEntry;
        };
    };
    total_signals: number;
};

export type EvalSignalItem = {
    delegation_type?: DelegationType;
    had_tool_errors?: boolean;
    latency_ms?: null | LatencyMs;
    model_id: string;
    satisfaction: number;
    task_type: TaskType;
    token_count?: null | TokenCount;
    tool_ids_used?: Array<string>;
};

export type EvalSignalRequest = {
    signals: Array<EvalSignalItem>;
};

export type EvalSignalResponse = {
    accepted: number;
    rejected: number;
};

/**
 * Response for a federation history event with optional publisher metadata.
 */
export type FederatedResourceHistoryResponse = {
    changed_at: string;
    expires_at?: string | null;
    external_id: string;
    federation_id?: string | null;
    id: string;
    metadata: unknown;
    operation: string;
    org_database_id?: string | null;
    publisher_id: string;
    publisher_name?: string | null;
    publisher_slug?: string | null;
    resource_type: string;
    status: string;
};

/**
 * Response for a single federated resource
 */
export type FederatedResourceResponse = {
    created_at: string;
    expires_at?: string | null;
    external_id: string;
    id: string;
    metadata: unknown;
    org_database_id?: string | null;
    publisher_id: string;
    resource_type: string;
    status: string;
    updated_at: string;
};

/**
 * Response for a federated resource with publisher info
 */
export type FederatedResourceWithPublisherResponse = {
    created_at: string;
    expires_at?: string | null;
    external_id: string;
    id: string;
    metadata: unknown;
    org_database_id?: string | null;
    publisher_id: string;
    publisher_name: string;
    publisher_slug: string;
    resource_type: string;
    status: string;
    updated_at: string;
};

/**
 * Response for federation history aggregate statistics.
 */
export type FederationHistoryStatsResponse = {
    by_operation: {
        [key: string]: number;
    };
    by_status: {
        [key: string]: number;
    };
    by_type: {
        [key: string]: number;
    };
    total_events: number;
    unique_publishers: number;
    unique_resources: number;
};

/**
 * Response for federation statistics
 */
export type FederationStatsResponse = {
    by_status: {
        [key: string]: number;
    };
    by_type: {
        [key: string]: number;
    };
    total_active: number;
};

export type ForgotPasswordRequest = {
    email: Email;
};

export type GenerateInvoicesRequest = {
    month: number;
    year: number;
};

/**
 * Error response when a publisher uses opt_in routing and the user has not opted in
 */
export type GeoRestrictedError = {
    error: string;
    message: string;
    opt_in_endpoint: string;
    proxy_region: string;
    publisher: string;
};

export type GeoRoutingConfig = {
    /**
     * Routing mode (defaults to `always`).
     */
    mode?: GeoRoutingMode;
    /**
     * Proxy region to route through (e.g., "EU")
     */
    proxy_region: string;
};

/**
 * Geographic routing configuration for publishers whose upstream API
 * should be accessed through a regional proxy.
 *
 * Two modes:
 * - `"always"`: all requests are routed through the proxy (e.g., upstream blocks US IPs)
 * - `"opt_in"`: users can choose to route through the proxy via `/user/routing`
 */
export type GeoRoutingMode = 'always' | 'opt_in';

/**
 * HTTP method for endpoint definitions
 */
export type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';

/**
 * Integration type - specific integration when publisher_category = Integration
 */
export type IntegrationType = 'api' | 'mcp';

/**
 * Cost breakdown for template invocation response
 */
export type InvocationCostBreakdown = {
    computeCost: string;
    llmCost: string;
    llmKeyUsed: string;
    publisherFee: string;
    total: string;
};

/**
 * Invoice response with line items
 */
export type Invoice = {
    id: string;
    invoice_number: string;
    line_items: Array<InvoiceLineItem>;
    organization_id: string;
    period_end: string;
    period_start: string;
    status: string;
    subtotal_usd: string;
    tax_usd: string;
    total_usd: string;
};

/**
 * Invoice line item response
 */
export type InvoiceLineItem = {
    amount_usd: string;
    description: string;
    line_type: string;
    quantity: string;
    unit_price: string;
};

/**
 * Response for invoice generation
 */
export type InvoicesGenerated = {
    count: number;
    invoice_ids: Array<string>;
};

/**
 * Request to invoke an agent template
 */
export type InvokeTemplateRequest = {
    /**
     * Input data to pass to the template
     */
    input: unknown;
};

/**
 * Response from invoking a template
 */
export type InvokeTemplateResponse = {
    /**
     * Cost breakdown
     */
    cost: InvocationCostBreakdown;
    /**
     * Execution time in milliseconds
     */
    executionTimeMs: number;
    /**
     * Invocation ID for tracking
     */
    invocationId: string;
    /**
     * Output from template execution
     */
    result: unknown;
};

export type LatencyMs = {
    first?: number | null;
    total?: number | null;
};

/**
 * LLM configuration for templates
 */
export type LlmConfig = {
    /**
     * API key (optional, will be encrypted)
     */
    apiKey?: string | null;
    /**
     * Model name (e.g., "gpt-4o", "claude-3-opus")
     */
    model: string;
    /**
     * LLM provider (e.g., "openai", "anthropic")
     */
    provider: string;
};

export type LoginResult = {
    access_token: string;
    /**
     * The user's default organization ID for API calls requiring an organization context.
     * This is typically the first organization the user joined (their personal org).
     */
    default_organization_id: string;
    expires_in: number;
    refresh_token: string;
    user: UserInfo;
};

/**
 * Logo upload request body
 */
export type LogoUploadRequest = {
    /**
     * Content type of the image (image/png, image/jpeg, image/webp, image/svg+xml)
     */
    content_type: string;
    /**
     * Base64 encoded image data
     */
    logo: string;
};

/**
 * Logo upload response
 */
export type LogoUploadResponse = {
    /**
     * URL to access the uploaded logo
     */
    logo_url: string;
    /**
     * Message indicating success
     */
    message: string;
};

/**
 * DataResponse wrapper for OpenAPI schema
 */
export type OAuthProviderDataResponse = {
    data: OAuthProviderResponse;
};

/**
 * Response type for OAuth provider (excludes sensitive fields like client_secret)
 */
export type OAuthProviderResponse = {
    authorization_url: string;
    client_id: string;
    created_at: string;
    description?: string | null;
    id: string;
    is_active: boolean;
    logo_url?: string | null;
    name: string;
    organization_id?: string | null;
    pkce_required: boolean;
    revocation_url?: string | null;
    scopes: Array<string>;
    slug: string;
    token_endpoint_auth_method: string;
    token_url: string;
    updated_at: string;
    userinfo_url?: string | null;
};

/**
 * DataResponse wrapper for list of providers
 */
export type OAuthProvidersDataResponse = {
    data: Array<OAuthProviderResponse>;
};

/**
 * Offset-based pagination metadata
 *
 * Used for APIs that use limit/offset pagination instead of page/per_page.
 * Standard fields following REST API conventions.
 */
export type OffsetPaginationMeta = {
    /**
     * Number of items in this response
     */
    count: number;
    /**
     * Whether more items exist beyond this page
     */
    has_more: boolean;
    /**
     * Maximum items requested
     */
    limit: number;
    /**
     * Starting offset
     */
    offset: number;
    /**
     * Total number of items across all pages
     */
    total: number;
};

/**
 * Request body for on-chain deposit
 */
export type OnchainDepositRequest = {
    /**
     * Amount to deposit in the configured asset (decimal string, e.g., "10.50")
     */
    amount: string;
    /**
     * Optional asset id to deposit (defaults to publisher primary asset)
     */
    asset_id?: string | null;
    /**
     * Publisher to deposit funds for
     */
    publisher_id: string;
};

/**
 * Response after successful on-chain deposit
 */
export type OnchainDepositResponse = {
    /**
     * Agent wallet address
     */
    agent_wallet: WalletAddress;
    /**
     * Asset symbol (e.g., USDC, USDT)
     */
    asset_symbol: string;
    /**
     * New balance (configured asset)
     */
    balance_amount: string;
    /**
     * Amount deposited (configured asset)
     */
    deposited_amount: string;
    /**
     * Deposit successful message
     */
    message: string;
    /**
     * Publisher ID
     */
    publisher_id: string;
    /**
     * On-chain transaction hash
     */
    tx_hash?: string | null;
};

export type Organization = {
    created_at: string;
    created_by: string;
    deleted_at?: string | null;
    id: string;
    is_personal: boolean;
    name: string;
    slug: Slug;
    /**
     * Stripe Customer ID for this organization (if billing is enabled).
     */
    stripe_customer_id?: string | null;
    updated_at: string;
};

/**
 * OrganizationConsumption wraps organization-wide consumption
 */
export type OrganizationConsumption = {
    current_month: ConsumptionSummary;
    from: string;
    organization_id: string;
    periods: Array<ConsumptionPeriodData>;
    to: string;
};

/**
 * Response type for organization invites (token is not exposed over the API).
 */
export type OrganizationInvite = {
    accepted_at?: string | null;
    created_at: string;
    email: string;
    expires_at: string;
    id: string;
    invited_by: string;
    organization_id: string;
    revoked_at?: string | null;
    role: string;
};

/**
 * Organization member with denormalized user fields for API responses.
 */
export type OrganizationMemberWithUser = {
    created_at: string;
    email: Email;
    id: string;
    name?: string | null;
    organization_id: string;
    role: string;
    user_id: string;
};

/**
 * OrganizationPlan tracks which plan an organization is currently on
 */
export type OrganizationPlan = {
    cancellation_reason?: string | null;
    cancelled_at?: string | null;
    cancelled_by?: string | null;
    created_at: string;
    ends_at?: string | null;
    id: string;
    is_trial: boolean;
    organization_id: string;
    plan_id: string;
    started_at: string;
    stripe_subscription_id?: string | null;
    trial_ends_at?: string | null;
    updated_at: string;
};

/**
 * Response type that includes both the plan and organization_plan details
 */
export type OrganizationPlanWithDetails = {
    organization_plan: OrganizationPlan;
    plan: Plan;
};

export type OrganizationVpcEndpoint = {
    created_at: string;
    endpoint_id: string;
    id: string;
    label?: string | null;
    organization_id: string;
    region: string;
    state: string;
    updated_at: string;
};

/**
 * Response wrapper with offset-based pagination
 *
 * Use this for list endpoints that use limit/offset pagination.
 */
export type PaginatedResponseVecPublisherResponse = {
    data: Array<{
        /**
         * Cached A2A agent card
         */
        a2a_agent_card?: unknown;
        /**
         * A2A endpoint base URL (for compute_type = agent)
         */
        a2a_endpoint_url?: string | null;
        /**
         * A2A health status: unknown, healthy, unhealthy, unreachable
         */
        a2a_health_status?: string | null;
        /**
         * Accepted assets for payment
         */
        accepted_assets?: Array<AssetInfo> | null;
        allowed_passthrough_headers: Array<string>;
        /**
         * Header name to inject upstream_api_key into (e.g., "Authorization", "X-API-Key")
         */
        api_key_header?: string | null;
        /**
         * Query parameter name to inject upstream_api_key into (e.g., "api_key", "apiKey")
         */
        api_key_query_param?: string | null;
        /**
         * External API URL (for integration_type = api)
         */
        api_url?: string | null;
        billing_model: string;
        /**
         * SerenDB branch ID (for database_type = serendb)
         */
        branch_id?: string | null;
        /**
         * Publisher-declared capabilities for task matching
         */
        capabilities: Array<string>;
        categories: Array<string>;
        compute_type?: null | ComputeType;
        created_at: string;
        /**
         * Provider config (sensitive fields redacted)
         */
        database_config?: unknown;
        /**
         * Database name within the SerenDB project
         */
        database_name?: string | null;
        database_type?: null | DatabaseType;
        description?: string | null;
        /**
         * Publisher contact email for notifications and support
         */
        email?: string | null;
        /**
         * Structured endpoint definitions for LLM discoverability and access control
         */
        endpoints?: Array<EndpointDefinition> | null;
        gateway_fee_percent: string;
        id: string;
        integration_type?: null | IntegrationType;
        is_active: boolean;
        is_verified: boolean;
        logo_url?: string | null;
        /**
         * Cached MCP capabilities (tools, resources, prompts)
         */
        mcp_capabilities?: unknown;
        /**
         * MCP server endpoint URL (for integration_type = mcp)
         */
        mcp_endpoint?: string | null;
        name: string;
        /**
         * OAuth provider ID for BYOC (Bring Your Own Credentials) authentication
         */
        oauth_provider_id?: string | null;
        ownership_tracking_enabled: boolean;
        /**
         * Pricing config per asset (if included)
         */
        pricing?: Array<PricingConfigResponse> | null;
        /**
         * SerenDB project ID (for database_type = serendb)
         */
        project_id?: string | null;
        protected_operations?: unknown;
        /**
         * Publisher category: database, integration, or compute
         */
        publisher_category: PublisherCategory;
        publisher_type: PublisherType;
        /**
         * Content-Type for upstream API requests
         */
        request_content_type: string;
        /**
         * If true, users must connect via OAuth before using this publisher
         */
        requires_user_oauth: boolean;
        resource_description?: string | null;
        resource_id_response_path?: string | null;
        resource_id_url_pattern?: string | null;
        resource_name?: string | null;
        routing?: null | GeoRoutingConfig;
        slug: string;
        /**
         * TTL for cached exchanged tokens in seconds
         */
        token_cache_ttl_seconds?: number | null;
        /**
         * HTTP method for exchange endpoint (POST or GET)
         */
        token_exchange_method?: string | null;
        /**
         * How to send Seren token: header, body, or query
         */
        token_exchange_mode?: string | null;
        /**
         * URL to call for exchanging Seren API keys for publisher auth tokens
         */
        token_exchange_url?: string | null;
        /**
         * JSON field in exchange response containing the token
         */
        token_response_field?: string | null;
        total_queries: number;
        /**
         * Policy for handling requests to paths not in the endpoints catalog
         */
        undocumented_endpoint_policy: UndocumentedEndpointPolicy;
        unique_agents_served: number;
        updated_at: string;
        /**
         * Dot-separated path to upstream cost in response body (for pay_per_use and prepaid passthrough billing).
         * Example: "usage.cost"
         */
        upstream_cost_response_path?: string | null;
        /**
         * Non-sensitive headers to send to upstream API
         */
        upstream_headers: unknown;
        /**
         * Usage examples showing how to call the publisher's API
         */
        usage_examples?: Array<UsageExample> | null;
        /**
         * Human-readable use case descriptions
         */
        use_cases: Array<string>;
        /**
         * When verification expires (NULL = no expiry)
         */
        verification_expires_at?: string | null;
        wallet_address: WalletAddress;
        /**
         * Network for the wallet address
         */
        wallet_network_id: string;
    }>;
    /**
     * Pagination metadata
     */
    pagination: OffsetPaginationMeta;
};

/**
 * Pagination metadata included in responses.
 */
export type PaginationMeta = {
    /**
     * Number of items in this response
     */
    count: number;
    /**
     * Whether there are more items after this page
     */
    has_more: boolean;
    /**
     * Maximum items per page
     */
    limit: number;
    /**
     * Offset from start
     */
    offset: number;
    /**
     * Total number of items across all pages
     */
    total: number;
};

/**
 * Parameter type for query/path parameters
 */
export type ParamType = 'string' | 'integer' | 'boolean' | 'number' | 'array';

export type PasswordReset = {
    message: string;
};

export type PasswordResetSent = {
    message: string;
};

/**
 * Payment history response
 */
export type PaymentHistory = {
    payments: Array<PaymentRecord>;
};

/**
 * Response for creating a payment intent
 */
export type PaymentIntentCreated = {
    /**
     * Amount to be charged, in cents.
     */
    amount_cents: number;
    /**
     * Amount to be charged, in USD.
     */
    amount_usd: string;
    client_secret: string;
    currency: CurrencyCode;
    payment_intent_id: StripePaymentIntentId;
};

/**
 * Payment method details
 */
export type PaymentMethod = {
    bank_last4?: string | null;
    card_brand?: string | null;
    card_exp_month?: number | null;
    card_exp_year?: number | null;
    card_last4?: string | null;
    id: string;
    is_default: boolean;
    type_: string;
};

/**
 * Response for adding a payment method
 */
export type PaymentMethodAdded = {
    id: string;
    message: string;
};

/**
 * Individual payment record
 */
export type PaymentRecord = {
    amount_usd: string;
    attempted_at: string;
    currency: CurrencyCode;
    failed_at?: string | null;
    failure_code?: string | null;
    failure_message?: string | null;
    id: string;
    status: string;
    stripe_charge_id?: null | StripeChargeId;
    stripe_payment_intent_id: StripePaymentIntentId;
    succeeded_at?: string | null;
};

/**
 * Internal payment request tracking (extends with Seren-specific fields)
 */
export type PaymentRequestInfo = {
    eip712TypedData?: null | Eip712TypedData;
    estimate?: null | CostEstimate;
    /**
     * Expiration timestamp (Unix seconds)
     */
    expires: number;
    /**
     * Payment request ID for correlation
     */
    payment_request_id: string;
    /**
     * Publisher ID
     */
    publisher_id: string;
};

/**
 * x402 V2 402 Payment Required Response
 *
 * The official V2 format with top-level resource info and extensions support.
 */
export type PaymentRequiredResponse = {
    /**
     * List of acceptable payment methods
     */
    accepts: Array<PaymentRequirements>;
    /**
     * Error message explaining why payment is required
     */
    error?: string | null;
    /**
     * Optional extensions (V2 feature for protocol extensibility)
     */
    extensions?: unknown;
    /**
     * Resource information (V2 - moved to top level)
     */
    resource: ResourceInfo;
    /**
     * x402 protocol version (2 for V2)
     */
    x402Version: number;
};

/**
 * 402 Payment Required response body (x402 v2) with Seren-specific extensions.
 */
export type PaymentRequiredResponseWithInfo = PaymentRequiredResponse & {
    seren?: null | PaymentRequestInfo;
};

/**
 * x402 V2 Payment Requirements
 *
 * Follows the official x402 V2 specification.
 * See: https://github.com/coinbase/x402/blob/main/typescript/packages/core/src/types/payments.ts
 */
export type PaymentRequirements = {
    /**
     * Amount in atomic units (token decimals)
     */
    amount: string;
    /**
     * Payment asset address (token contract)
     */
    asset: string;
    /**
     * Extra information about the payment (scheme-specific)
     *
     * For EVM/exact scheme, this typically contains:
     * - `name`: Asset name (e.g., "USD Coin")
     * - `version`: Asset version
     * - `eip712TypedData`: EIP-712 typed data for signing (EIP-3009)
     * - `paymentRequestId`: Correlation ID
     * - `expires`: Expiration timestamp
     * - `estimate`: Cost breakdown (optional)
     * - `settlementMethod`: "eip3009" or "transfer"
     */
    extra: unknown;
    /**
     * Maximum time in seconds for the resource server to respond
     */
    maxTimeoutSeconds: number;
    /**
     * Network for payment in CAIP-2 format (e.g., "eip155:8453" for Base mainnet)
     */
    network: string;
    /**
     * Address to pay value to (publisher or gateway wallet)
     */
    payTo: string;
    /**
     * Payment scheme (e.g., "exact")
     */
    scheme: string;
};

/**
 * Status of a publisher payout request.
 */
export type PayoutStatus = 'queued' | 'processing' | 'completed' | 'failed' | 'cancelled';

/**
 * Permission definition
 */
export type Permission = {
    action: string;
    created_at: string;
    description?: string | null;
    id: string;
    name: string;
    resource_type: string;
};

/**
 * Plan represents a subscription tier (Free, Launch, Scale)
 */
export type Plan = {
    audit_logs_enabled: boolean;
    branch_price_per_hour?: string | null;
    compute_hours_quota?: number | null;
    compute_price_per_cu_hour?: string | null;
    created_at: string;
    data_transfer_gb_included?: number | null;
    data_transfer_price_per_gb?: string | null;
    description?: string | null;
    display_name: string;
    id: string;
    ip_allowlist_enabled: boolean;
    is_active: boolean;
    max_branches_per_project: number;
    max_compute_units: number;
    max_databases_per_branch?: number | null;
    max_endpoints_per_branch?: number | null;
    max_projects?: number | null;
    monitoring_enabled: boolean;
    monitoring_retention_days?: number | null;
    name: string;
    pitr_price_per_gb_month?: string | null;
    pitr_retention_hours?: number | null;
    price_monthly: string;
    scale_to_zero_delay_seconds?: number | null;
    sla_uptime_percent?: string | null;
    sort_order: number;
    sso_enabled: boolean;
    storage_gb_quota?: string | null;
    storage_price_per_gb_month?: string | null;
    /**
     * Stripe Price ID used for recurring subscriptions on this plan (for paid tiers).
     */
    stripe_price_id?: string | null;
    support_level: string;
    updated_at: string;
    vpc_enabled: boolean;
};

/**
 * Pricing config response
 */
export type PricingConfigResponse = {
    /**
     * Asset this pricing applies to
     */
    asset_id: string;
    /**
     * Asset symbol for display
     */
    asset_symbol?: string | null;
    base_price_per_1000_rows: string;
    grace_period_minutes?: number | null;
    hourly_rate?: string | null;
    low_balance_threshold: string;
    markup_multiplier: string;
    max_queries_per_minute?: number | null;
    min_charge: string;
    /**
     * Minimum price to display in UI for passthrough publishers (informational only)
     */
    min_display_price?: string | null;
    minimum_balance: string;
    onchain_enabled: boolean;
    payment_expiry_minutes: number;
    prepaid_enabled: boolean;
    price_per_call?: string | null;
    price_per_delete?: string | null;
    /**
     * Price per execution for agent templates or usage-based billing
     */
    price_per_execution?: string | null;
    price_per_get?: string | null;
    price_per_patch?: string | null;
    price_per_post?: string | null;
    price_per_put?: string | null;
    /**
     * Text to display for variable pricing (e.g., "Varies by model")
     */
    pricing_display_text?: string | null;
    pricing_model: PricingModel;
    reserve_max_charge?: string | null;
    unresolved_fallback_charge?: string | null;
};

/**
 * Pricing model used to interpret pricing units.
 */
export type PricingModel = 'per_row' | 'per_request' | 'per_byte' | 'tiered' | 'passthrough';

/**
 * Simplified pricing summary for suggestions
 */
export type PricingSummary = {
    base_price_per_1000_rows?: string | null;
};

export type ProvidersResponse = {
    providers: Array<PublisherOAuthProviderResponse>;
};

export type PublisherAgentBalance = {
    onchain_atomic?: number | null;
    serenbucks_atomic: number;
    total_available_atomic: number;
};

/**
 * Response for publisher analytics
 */
export type PublisherAnalytics = {
    publisher_id: string;
    templates: Array<TemplateAnalytics>;
    totals: PublisherAnalyticsTotals;
};

/**
 * Aggregated totals for publisher analytics
 */
export type PublisherAnalyticsTotals = {
    failed_invocations: number;
    overall_success_rate: number;
    successful_invocations: number;
    total_invocations: number;
    total_revenue_atomic: number;
    total_revenue_usd: string;
    total_templates: number;
    unique_agents_served: number;
};

/**
 * Publisher category - the primary classification of what a publisher offers
 */
export type PublisherCategory = 'database' | 'integration' | 'compute';

export type PublisherChargeInfo = {
    agent_wallet: string;
    amount_atomic: number;
    id: string;
    status: string;
};

/**
 * Publisher earnings summary response (per asset).
 */
export type PublisherEarningsResponse = {
    asset: AssetInfo;
    available: number;
    available_atomic: number;
    pending_payout: number;
    pending_payout_atomic: number;
    publisher_id: string;
    publisher_name: string;
    publisher_slug: string;
    /**
     * Count of billable transactions for this asset (query_charge, api_call, service_fee).
     */
    request_count: number;
    total_revenue: number;
    total_revenue_atomic: number;
    total_withdrawn: number;
    total_withdrawn_atomic: number;
    wallet_address: WalletAddress;
};

/**
 * Response type for OAuth provider (excludes sensitive fields)
 */
export type PublisherOAuthProviderResponse = {
    created_at: string;
    /**
     * Custom provider-specific authorization URL parameters
     */
    custom_auth_params?: unknown;
    description?: string | null;
    id: string;
    is_active: boolean;
    logo_url?: string | null;
    name: string;
    organization_id?: string | null;
    scopes: Array<string>;
    slug: string;
};

export type PublisherPayoutInfo = {
    amount_atomic: number;
    destination_wallet: string;
    error_message?: string | null;
    id: string;
    status: string;
    tx_hash?: string | null;
};

/**
 * Publisher payout response.
 */
export type PublisherPayoutResponse = {
    amount: number;
    amount_atomic: number;
    asset: AssetInfo;
    destination_wallet: WalletAddress;
    error_message?: string | null;
    id: string;
    publisher_id: string;
    requested_at: string;
    status: PayoutStatus;
    tx_hash?: string | null;
};

/**
 * Publisher response (excludes sensitive fields)
 */
export type PublisherResponse = {
    /**
     * Cached A2A agent card
     */
    a2a_agent_card?: unknown;
    /**
     * A2A endpoint base URL (for compute_type = agent)
     */
    a2a_endpoint_url?: string | null;
    /**
     * A2A health status: unknown, healthy, unhealthy, unreachable
     */
    a2a_health_status?: string | null;
    /**
     * Accepted assets for payment
     */
    accepted_assets?: Array<AssetInfo> | null;
    allowed_passthrough_headers: Array<string>;
    /**
     * Header name to inject upstream_api_key into (e.g., "Authorization", "X-API-Key")
     */
    api_key_header?: string | null;
    /**
     * Query parameter name to inject upstream_api_key into (e.g., "api_key", "apiKey")
     */
    api_key_query_param?: string | null;
    /**
     * External API URL (for integration_type = api)
     */
    api_url?: string | null;
    billing_model: string;
    /**
     * SerenDB branch ID (for database_type = serendb)
     */
    branch_id?: string | null;
    /**
     * Publisher-declared capabilities for task matching
     */
    capabilities: Array<string>;
    categories: Array<string>;
    compute_type?: null | ComputeType;
    created_at: string;
    /**
     * Provider config (sensitive fields redacted)
     */
    database_config?: unknown;
    /**
     * Database name within the SerenDB project
     */
    database_name?: string | null;
    database_type?: null | DatabaseType;
    description?: string | null;
    /**
     * Publisher contact email for notifications and support
     */
    email?: string | null;
    /**
     * Structured endpoint definitions for LLM discoverability and access control
     */
    endpoints?: Array<EndpointDefinition> | null;
    gateway_fee_percent: string;
    id: string;
    integration_type?: null | IntegrationType;
    is_active: boolean;
    is_verified: boolean;
    logo_url?: string | null;
    /**
     * Cached MCP capabilities (tools, resources, prompts)
     */
    mcp_capabilities?: unknown;
    /**
     * MCP server endpoint URL (for integration_type = mcp)
     */
    mcp_endpoint?: string | null;
    name: string;
    /**
     * OAuth provider ID for BYOC (Bring Your Own Credentials) authentication
     */
    oauth_provider_id?: string | null;
    ownership_tracking_enabled: boolean;
    /**
     * Pricing config per asset (if included)
     */
    pricing?: Array<PricingConfigResponse> | null;
    /**
     * SerenDB project ID (for database_type = serendb)
     */
    project_id?: string | null;
    protected_operations?: unknown;
    /**
     * Publisher category: database, integration, or compute
     */
    publisher_category: PublisherCategory;
    publisher_type: PublisherType;
    /**
     * Content-Type for upstream API requests
     */
    request_content_type: string;
    /**
     * If true, users must connect via OAuth before using this publisher
     */
    requires_user_oauth: boolean;
    resource_description?: string | null;
    resource_id_response_path?: string | null;
    resource_id_url_pattern?: string | null;
    resource_name?: string | null;
    routing?: null | GeoRoutingConfig;
    slug: string;
    /**
     * TTL for cached exchanged tokens in seconds
     */
    token_cache_ttl_seconds?: number | null;
    /**
     * HTTP method for exchange endpoint (POST or GET)
     */
    token_exchange_method?: string | null;
    /**
     * How to send Seren token: header, body, or query
     */
    token_exchange_mode?: string | null;
    /**
     * URL to call for exchanging Seren API keys for publisher auth tokens
     */
    token_exchange_url?: string | null;
    /**
     * JSON field in exchange response containing the token
     */
    token_response_field?: string | null;
    total_queries: number;
    /**
     * Policy for handling requests to paths not in the endpoints catalog
     */
    undocumented_endpoint_policy: UndocumentedEndpointPolicy;
    unique_agents_served: number;
    updated_at: string;
    /**
     * Dot-separated path to upstream cost in response body (for pay_per_use and prepaid passthrough billing).
     * Example: "usage.cost"
     */
    upstream_cost_response_path?: string | null;
    /**
     * Non-sensitive headers to send to upstream API
     */
    upstream_headers: unknown;
    /**
     * Usage examples showing how to call the publisher's API
     */
    usage_examples?: Array<UsageExample> | null;
    /**
     * Human-readable use case descriptions
     */
    use_cases: Array<string>;
    /**
     * When verification expires (NULL = no expiry)
     */
    verification_expires_at?: string | null;
    wallet_address: WalletAddress;
    /**
     * Network for the wallet address
     */
    wallet_network_id: string;
};

/**
 * Request body for publisher root `POST /publishers/{slug}`.
 *
 * - For database publishers: use `DatabaseQueryRequest`
 * - For API publishers: any JSON body will be proxied to the upstream API root (`/`)
 */
export type PublisherRootRequest = DatabaseQueryRequest | unknown;

/**
 * A publisher suggestion with match score and reason
 */
export type PublisherSuggestion = {
    /**
     * Publisher-declared capabilities
     */
    capabilities: Array<string>;
    description?: string | null;
    /**
     * Why this publisher was suggested
     */
    match_reason: string;
    name: string;
    pricing?: null | PricingSummary;
    /**
     * Match score (0.0 to 1.0)
     */
    score: number;
    slug: string;
};

/**
 * Type of publisher in the store
 */
export type PublisherType = 'individual' | 'organization' | 'verified_partner';

/**
 * Instructions for using different publisher types
 */
export type PublisherTypeInstructions = {
    /**
     * For API publishers
     */
    api: string;
    /**
     * For database publishers
     */
    database: string;
    /**
     * For MCP publishers
     */
    mcp: string;
};

/**
 * Query parameter definition for an endpoint
 */
export type QueryParamDefinition = {
    /**
     * Human-readable description
     */
    description?: string | null;
    /**
     * Example value for documentation
     */
    example?: string | null;
    /**
     * Parameter name (e.g., "id", "limit")
     */
    name: string;
    /**
     * Parameter type
     */
    param_type?: ParamType;
    /**
     * Whether this parameter is required
     */
    required?: boolean;
};

/**
 * Quota usage summary for an organization
 */
export type QuotaUsage = {
    compute_hours_usage_percent?: number | null;
    current_branches: number;
    current_compute_hours: number;
    current_projects: number;
    current_storage_gb: number;
    is_over_compute_quota: boolean;
    is_over_projects_quota: boolean;
    is_over_storage_quota: boolean;
    organization_id: string;
    plan: Plan;
    projects_usage_percent?: number | null;
    storage_usage_percent?: number | null;
};

/**
 * Response after creating or updating a role
 */
export type RbacRole = {
    created_at: string;
    description?: string | null;
    id: string;
    is_built_in: boolean;
    name: string;
    permissions: Array<string>;
};

/**
 * Wrapped recovery response for OpenAPI
 */
export type RecoveryDataResponse = {
    data: RecoveryResponse;
};

/**
 * Response for recovery setup
 */
export type RecoveryResponse = {
    /**
     * Whether recovery is now set up
     */
    has_recovery: boolean;
    /**
     * Whether a recovery email is set
     */
    has_recovery_email: boolean;
    /**
     * Message about recovery status
     */
    message: string;
    /**
     * Recovery code (only shown once, save it securely!)
     * This is a 24-character code that can be used to recover your account.
     */
    recovery_code?: string | null;
};

/**
 * Wrapped referral info response for OpenAPI
 */
export type ReferralInfoDataResponse = {
    data: ReferralInfoResponse;
};

/**
 * Response for referral info
 */
export type ReferralInfoResponse = {
    pending_earnings_atomic: number;
    pending_earnings_usd: string;
    referral_code: string;
    referral_url: string;
    total_earnings_atomic: number;
    total_earnings_usd: string;
    total_referrals: number;
};

export type RefundChargeRequest = {
    reason: string;
};

export type ResendVerificationRequest = {
    email: Email;
};

export type ResetPasswordRequest = {
    new_password: string;
    token: string;
};

/**
 * Resource information for x402 V2
 *
 * In V2, resource metadata is a top-level field rather than being
 * embedded in each payment requirement.
 */
export type ResourceInfo = {
    /**
     * Human-readable description of the resource
     */
    description: string;
    /**
     * MIME type of the resource response
     */
    mimeType: string;
    /**
     * URL of the resource being paid for
     */
    url: string;
};

/**
 * Revenue breakdown by day.
 */
export type RevenueByDay = {
    /**
     * Date (YYYY-MM-DD)
     */
    date: string;
    /**
     * Number of queries on this day
     */
    query_count: number;
    /**
     * Revenue as decimal string
     */
    revenue: string;
    /**
     * Revenue on this day (atomic units)
     */
    revenue_atomic: number;
    /**
     * Number of unique agents on this day
     */
    unique_agents: number;
};

/**
 * Revenue metrics with period-over-period comparison.
 */
export type RevenueMetrics = {
    /**
     * Number of active agents in the period
     */
    active_agents: number;
    /**
     * Agent count change from previous period (percentage)
     */
    agents_change_pct: number;
    /**
     * Average query cost (atomic units)
     */
    avg_query_cost_atomic: number;
    /**
     * Period end date (ISO 8601)
     */
    period_end: string;
    /**
     * Period start date (ISO 8601)
     */
    period_start: string;
    /**
     * Query count change from previous period (percentage)
     */
    queries_change_pct: number;
    /**
     * Revenue change from previous period (percentage, e.g., 15 = +15%)
     */
    revenue_change_pct: number;
    /**
     * Total queries executed in the period
     */
    total_queries: number;
    /**
     * Total revenue as decimal string
     */
    total_revenue: string;
    /**
     * Total revenue in the period (atomic units)
     */
    total_revenue_atomic: number;
};

export type RevokeResponse = {
    message: string;
    success: boolean;
};

/**
 * Response for listing user sessions (hides sensitive token hash)
 */
export type Session = {
    created_at: string;
    expires_at: string;
    id: string;
    ip_address?: string | null;
    is_current: boolean;
    last_active_at: string;
    user_agent?: string | null;
};

export type SessionsRevoked = {
    message: string;
    revoked_count: number;
};

/**
 * Request to set up account recovery
 */
export type SetRecoveryRequest = {
    /**
     * Email address for account recovery (optional, for human contact)
     */
    email?: string | null;
};

/**
 * Setup instructions for new agents
 */
export type SetupInstructions = {
    /**
     * Step 1: Save your API key
     */
    step_1: string;
    /**
     * Step 2: Set up authentication header
     */
    step_2: string;
    /**
     * Step 3: Browse publishers
     */
    step_3: string;
    /**
     * Step 4: Use publishers by type
     */
    step_4: PublisherTypeInstructions;
};

/**
 * Skill files and documentation links
 */
export type SkillFiles = {
    /**
     * Link to the documentation
     */
    docs: string;
    /**
     * Link to the main skill.md file
     */
    skill_md: string;
};

export type SlashChargeRequest = {
    reason: string;
    slash_amount_atomic: number;
};

/**
 * A validated URL-safe slug.
 *
 * Slugs must be:
 * - 2-64 characters long
 * - Lowercase alphanumeric with hyphens
 * - Cannot start or end with a hyphen
 * - Cannot have consecutive hyphens
 *
 * # Examples
 *
 * ```
 * use seren_core::models::Slug;
 *
 * let slug = Slug::new("my-project").unwrap();
 * assert!(Slug::new("My Project").is_err()); // spaces not allowed
 * assert!(Slug::new("-invalid").is_err()); // can't start with hyphen
 * ```
 */
export type Slug = string;

/**
 * A Stripe Charge ID (ch_xxx).
 */
export type StripeChargeId = string;

/**
 * A Stripe Payment Intent ID (pi_xxx).
 */
export type StripePaymentIntentId = string;

/**
 * A Stripe Payment Method ID (pm_xxx).
 */
export type StripePaymentMethodId = string;

/**
 * Response for suggest endpoint
 * Returns publisher and agent recommendations based on task/query matching
 */
export type SuggestResponse = {
    /**
     * Matched agents sorted by relevance (agent templates coming soon)
     */
    agents: Array<unknown>;
    /**
     * Matched publishers sorted by relevance
     */
    publishers: Array<PublisherSuggestion>;
};

/**
 * Supported payment kind (from facilitator /supported endpoint)
 */
export type SupportedKind = {
    /**
     * Extra scheme-specific info
     */
    extra?: unknown;
    /**
     * Network in CAIP-2 format
     */
    network: string;
    /**
     * Payment scheme
     */
    scheme: string;
    /**
     * x402 protocol version
     */
    x402Version: number;
};

/**
 * Response from facilitator /supported endpoint
 */
export type SupportedResponse = {
    /**
     * List of supported extensions
     */
    extensions?: Array<string> | null;
    /**
     * List of supported payment kinds
     */
    kinds: Array<SupportedKind>;
    /**
     * Signer addresses by network family
     */
    signers?: unknown;
};

export type TaskType = 'code_generation' | 'file_operations' | 'research' | 'document_generation' | 'general_chat';

/**
 * Analytics data for a single template
 */
export type TemplateAnalytics = {
    avg_execution_time_ms?: number | null;
    failed_invocations: number;
    name: string;
    slug: string;
    success_rate: number;
    successful_invocations: number;
    template_id: string;
    total_invocations: number;
    total_revenue_atomic: number;
    total_revenue_usd: string;
    unique_agents_served: number;
};

export type TemplateLanguage = 'python' | 'typescript' | 'javascript';

/**
 * Sorting options for template catalog
 */
export type TemplateSortBy = 'popularity' | 'price_asc' | 'price_desc' | 'newest' | 'oldest';

export type TokenCount = {
    input?: number | null;
    output?: number | null;
};

export type TokenEndpointAuthMethod = 'client_secret_post' | 'client_secret_basic';

/**
 * Top agent by spending.
 */
export type TopAgent = {
    /**
     * Agent wallet address
     */
    agent_wallet: string;
    /**
     * Current balance (atomic units)
     */
    balance_atomic: number;
    /**
     * Last activity timestamp (ISO 8601)
     */
    last_active?: string | null;
    /**
     * Number of queries executed
     */
    query_count: number;
    /**
     * Rank (1 = highest spender)
     */
    rank: number;
    /**
     * Total amount spent as decimal string
     */
    total_spent: string;
    /**
     * Total amount spent (atomic units)
     */
    total_spent_atomic: number;
};

/**
 * Wrapped transaction summary response for OpenAPI
 */
export type TransactionSummaryDataResponse = {
    data: TransactionSummaryResponse;
};

/**
 * Summary statistics for transactions in a date range
 */
export type TransactionSummaryResponse = {
    /**
     * Wallet balance at the end of the selected period
     */
    ending_balance_atomic: number;
    ending_balance_usd: string;
    /**
     * Net change (credits - debits, can be negative)
     */
    net_change_atomic: number;
    net_change_usd: string;
    period_end?: string | null;
    period_start?: string | null;
    /**
     * Wallet balance immediately before the period start
     */
    starting_balance_atomic: number;
    starting_balance_usd: string;
    /**
     * Total credits received in the period (positive)
     */
    total_credits_atomic: number;
    total_credits_usd: string;
    /**
     * Total debits spent in the period (positive number representing absolute spend)
     */
    total_debits_atomic: number;
    total_debits_usd: string;
    /**
     * Total number of transactions in the period
     */
    transaction_count: number;
};

/**
 * Single typed parameter definition
 */
export type TypedParam = {
    name: string;
    type: string;
};

/**
 * Policy for handling requests to paths not in the endpoints catalog
 */
export type UndocumentedEndpointPolicy = 'default_allow' | 'default_deny';

/**
 * Request to update an OAuth provider (admin only).
 *
 * Fields use `Option<Option<T>>` where `null` explicitly clears the value.
 */
export type UpdateOAuthProviderRequest = {
    authorization_url?: string | null;
    client_id?: string | null;
    /**
     * Optional new client secret (will be re-encrypted). If omitted, keep existing.
     */
    client_secret?: string | null;
    /**
     * Custom provider-specific authorization URL parameters. If omitted, leave unchanged.
     */
    custom_auth_params?: unknown;
    /**
     * If omitted, leave unchanged. If null, clear.
     */
    description?: string | null;
    is_active?: boolean | null;
    /**
     * If omitted, leave unchanged. If null, clear.
     */
    logo_url?: string | null;
    name?: string | null;
    /**
     * If omitted, leave unchanged. If null, make global. If set, scope to organization.
     */
    organization_id?: string | null;
    pkce_required?: boolean | null;
    /**
     * If omitted, leave unchanged. If null, clear.
     */
    revocation_url?: string | null;
    scopes?: Array<string> | null;
    slug?: string | null;
    token_endpoint_auth_method?: null | TokenEndpointAuthMethod;
    token_url?: string | null;
    /**
     * If omitted, leave unchanged. If null, clear.
     */
    userinfo_url?: string | null;
};

/**
 * Request to update pricing config
 */
export type UpdatePricingRequest = {
    /**
     * Asset ID for this pricing config (required)
     */
    asset_id: string;
    base_price_per_1000_rows?: string | null;
    grace_period_minutes?: number | null;
    hourly_rate?: string | null;
    low_balance_threshold?: string | null;
    markup_multiplier?: string | null;
    max_queries_per_minute?: number | null;
    min_charge?: string | null;
    /**
     * Minimum price to display in UI for passthrough publishers (informational only)
     */
    min_display_price?: string | null;
    minimum_balance?: string | null;
    onchain_enabled?: boolean | null;
    payment_expiry_minutes?: number | null;
    prepaid_enabled?: boolean | null;
    price_per_call?: string | null;
    price_per_delete?: string | null;
    /**
     * Price per execution for agent templates or usage-based billing
     */
    price_per_execution?: string | null;
    price_per_get?: string | null;
    price_per_patch?: string | null;
    price_per_post?: string | null;
    price_per_put?: string | null;
    /**
     * Text to display for variable pricing (e.g., "Varies by model")
     */
    pricing_display_text?: string | null;
    pricing_model?: null | PricingModel;
    reserve_max_charge?: string | null;
    /**
     * TTL for cached exchanged tokens in seconds (60-86400)
     */
    token_cache_ttl_seconds?: number | null;
    /**
     * HTTP method for exchange endpoint (POST or GET)
     */
    token_exchange_method?: string | null;
    /**
     * How to send Seren token: header, body, or query
     */
    token_exchange_mode?: string | null;
    /**
     * URL to call for exchanging Seren API keys for publisher auth tokens
     */
    token_exchange_url?: string | null;
    /**
     * JSON field in exchange response containing the token
     */
    token_response_field?: string | null;
    unresolved_fallback_charge?: string | null;
};

/**
 * Request to update a publisher
 */
export type UpdatePublisherRequest = {
    /**
     * A2A endpoint base URL (for compute_type = agent)
     */
    a2a_endpoint_url?: string | null;
    /**
     * Asset IDs to add to accepted assets
     */
    add_asset_ids?: Array<string> | null;
    /**
     * Whitelist of agent-provided headers allowed to pass through to upstream
     */
    allowed_passthrough_headers?: Array<string> | null;
    /**
     * Headers for API requests (will be encrypted)
     */
    api_headers?: unknown;
    /**
     * Header name to inject upstream_api_key into (e.g., "Authorization", "X-API-Key")
     */
    api_key_header?: string | null;
    /**
     * Query parameter name to inject upstream_api_key into (e.g., "api_key")
     */
    api_key_query_param?: string | null;
    /**
     * External API URL (for integration_type = api)
     */
    api_url?: string | null;
    /**
     * Upstream auth mode ("static" or "jwt")
     */
    auth_type?: string | null;
    base_price_per_1000_rows?: string | null;
    /**
     * Billing model ("x402_per_request", "prepaid_credits", "x402_passthrough", "pay_per_use")
     */
    billing_model?: string | null;
    /**
     * SerenDB branch ID (for database_type = serendb)
     */
    branch_id?: string | null;
    /**
     * Publisher-declared capabilities for task matching (e.g., "web_scraping", "ai_search")
     */
    capabilities?: Array<string> | null;
    categories?: Array<string> | null;
    compute_type?: null | ComputeType;
    /**
     * Provider-specific configuration
     */
    database_config?: unknown;
    /**
     * Database name within the SerenDB project
     */
    database_name?: string | null;
    database_type?: null | DatabaseType;
    description?: string | null;
    /**
     * Publisher contact email for notifications and support
     */
    email?: string | null;
    /**
     * Structured endpoint definitions for LLM discoverability and access control
     */
    endpoints?: Array<EndpointDefinition> | null;
    /**
     * Gateway fee percentage for upstream x402 payments (pass-through).
     */
    gateway_fee_percent?: string | null;
    grace_period_minutes?: number | null;
    hourly_rate?: string | null;
    integration_type?: null | IntegrationType;
    is_active?: boolean | null;
    /**
     * JWT access key / issuer claim (plaintext)
     */
    jwt_access_key?: string | null;
    /**
     * JWT signing algorithm ("HS256", "HS384", "HS512")
     */
    jwt_algorithm?: string | null;
    /**
     * JWT expiration seconds
     */
    jwt_expiration_seconds?: number | null;
    /**
     * JWT secret key (will be encrypted)
     */
    jwt_secret_key?: string | null;
    /**
     * Optional publisher branding URL
     */
    logo_url?: string | null;
    low_balance_threshold?: string | null;
    markup_multiplier?: string | null;
    /**
     * MCP server endpoint URL (for integration_type = mcp)
     */
    mcp_endpoint?: string | null;
    minimum_balance?: string | null;
    name?: string | null;
    /**
     * OAuth2 client ID for Client Credentials flow
     */
    oauth2_client_id?: string | null;
    /**
     * OAuth2 client secret for Client Credentials flow (will be encrypted)
     */
    oauth2_client_secret?: string | null;
    /**
     * OAuth2 scopes to request during Client Credentials flow
     */
    oauth2_scopes?: Array<string> | null;
    /**
     * OAuth2 token endpoint URL for Client Credentials flow
     */
    oauth2_token_url?: string | null;
    /**
     * OAuth provider ID for BYOC (Bring Your Own Credentials) authentication.
     * Set to enable user-specific OAuth tokens for this publisher.
     */
    oauth_provider_id?: string | null;
    /**
     * Enable resource ownership tracking (legacy gateway parity)
     */
    ownership_tracking_enabled?: boolean | null;
    price_per_call?: string | null;
    price_per_delete?: string | null;
    /**
     * Price per execution for agent templates or usage-based billing
     */
    price_per_execution?: string | null;
    price_per_get?: string | null;
    price_per_patch?: string | null;
    price_per_post?: string | null;
    price_per_put?: string | null;
    /**
     * SerenDB project ID (for database_type = serendb)
     */
    project_id?: string | null;
    /**
     * Protected operations configuration - legacy, use endpoints[].is_protected instead
     */
    protected_operations?: unknown;
    publisher_category?: null | PublisherCategory;
    /**
     * Asset IDs to remove from accepted assets
     */
    remove_asset_ids?: Array<string> | null;
    /**
     * Content-Type for upstream API requests (default: application/json)
     */
    request_content_type?: string | null;
    /**
     * If true, users must connect via OAuth before using this publisher (BYOC mode).
     * Requires oauth_provider_id to be set.
     */
    requires_user_oauth?: boolean | null;
    /**
     * Maximum amount to reserve up-front for pay_per_use pre-authorization.
     */
    reserve_max_charge?: string | null;
    resource_description?: string | null;
    /**
     * JSONPath to resource ID in response body (for ownership tracking)
     */
    resource_id_response_path?: string | null;
    /**
     * URL pattern with :resourceId placeholder (for ownership tracking)
     */
    resource_id_url_pattern?: string | null;
    resource_name?: string | null;
    routing?: null | GeoRoutingConfig;
    /**
     * TTL for cached exchanged tokens in seconds (60-86400)
     */
    token_cache_ttl_seconds?: number | null;
    /**
     * HTTP method for exchange endpoint (POST or GET)
     */
    token_exchange_method?: string | null;
    /**
     * How to send Seren token: header, body, or query
     */
    token_exchange_mode?: string | null;
    /**
     * URL to call for exchanging Seren API keys for publisher auth tokens
     */
    token_exchange_url?: string | null;
    /**
     * JSON field in exchange response containing the token (default: access_token)
     */
    token_response_field?: string | null;
    undocumented_endpoint_policy?: null | UndocumentedEndpointPolicy;
    /**
     * Fallback charge used when pay_per_use cost cannot be resolved from upstream response or token estimates.
     */
    unresolved_fallback_charge?: string | null;
    /**
     * Upstream static API key (will be encrypted)
     */
    upstream_api_key?: string | null;
    /**
     * Dot-separated path to upstream cost in response body (for pay_per_use and prepaid passthrough billing).
     * Example: "usage.cost"
     */
    upstream_cost_response_path?: string | null;
    /**
     * Non-sensitive headers to send to upstream API (e.g., User-Agent)
     */
    upstream_headers?: unknown;
    /**
     * Usage examples showing how to call the publisher's API
     */
    usage_examples?: Array<UsageExample> | null;
    /**
     * Human-readable use case descriptions (e.g., "Scrape dynamic JavaScript websites")
     */
    use_cases?: Array<string> | null;
    wallet_address?: null | WalletAddress;
    /**
     * Network ID for wallet (must be provided if changing wallet_address)
     */
    wallet_network_id?: string | null;
};

/**
 * Request to update a role
 */
export type UpdateRoleRequest = {
    description?: string | null;
    name?: string | null;
    permissions?: Array<string> | null;
};

/**
 * Request to update a webhook
 */
export type UpdateWebhookRequest = {
    enabled?: boolean | null;
    events?: Array<string> | null;
    name?: string | null;
    url?: string | null;
};

/**
 * Request to upsert a federated resource
 */
export type UpsertFederatedResourceRequest = {
    /**
     * Optional expiration timestamp
     */
    expires_at?: string | null;
    /**
     * External ID of the resource (unique within publisher + type)
     */
    external_id: string;
    /**
     * Resource metadata (JSON object with type-specific fields)
     */
    metadata: unknown;
    /**
     * Optional database ID where the resource data lives
     */
    org_database_id?: string | null;
    /**
     * Optional publisher slug for disambiguation when an organization owns multiple publishers
     */
    publisher_slug?: string | null;
    /**
     * Type of resource being registered
     */
    resource_type: string;
    /**
     * Resource status (default: "active")
     */
    status?: string;
};

/**
 * Debug view: usage_events entry for an endpoint
 */
export type UsageEventDebugRecord = {
    event_timestamp: string;
    event_type: string;
    metadata: string;
    quantity: number;
    unit: string;
};

/**
 * A single usage example showing how to call a publisher's API
 */
export type UsageExample = {
    /**
     * Full curl command example
     */
    curl?: string | null;
    /**
     * Description of what this example demonstrates
     */
    description?: string | null;
    /**
     * Short title for the example (e.g., "Create a collection")
     */
    title?: string | null;
};

/**
 * Usage summary for billing period
 */
export type UsageSummary = {
    compute_cost_usd: string;
    compute_hours_large: number;
    compute_hours_medium: number;
    compute_hours_small: number;
    compute_hours_xlarge: number;
    organization_id: string;
    period_end: string;
    period_start: string;
    pitr_gb_avg: number;
    project_id: string;
    /**
     * Human-readable project name (denormalized for convenience).
     */
    project_name: string;
    /**
     * Cloud region for the project (e.g., aws-us-east-1).
     */
    project_region: string;
    storage_cost_usd: string;
    storage_gb_avg: number;
    total_cost_usd: string;
};

/**
 * Combined user view for API responses
 */
export type UserInfo = {
    avatar_url?: string | null;
    created_at: string;
    email: Email;
    id: string;
    name: string;
    status: UserStatus;
};

/**
 * Response for GET /auth/me - current user info with default organization
 */
export type UserMe = UserInfo & {
    /**
     * The user's default organization ID for API calls requiring an organization context.
     * This is typically the first organization the user joined (their personal org).
     */
    default_organization_id: string;
};

/**
 * Response type for user OAuth connection (excludes tokens)
 */
export type UserOAuthConnectionResponse = {
    created_at: string;
    expires_at?: string | null;
    id: string;
    is_valid: boolean;
    last_used_at?: string | null;
    provider_email?: string | null;
    provider_id: string;
    provider_logo_url?: string | null;
    provider_name: string;
    provider_slug: string;
    provider_user_id?: string | null;
    scopes: Array<string>;
};

/**
 * User status enum matching PostgreSQL enum
 */
export type UserStatus = 'active' | 'deleted' | 'disabled' | 'paused';

export type VerificationSent = {
    message: string;
};

export type VerifyEmailRequest = {
    token: string;
};

/**
 * A validated wallet address (EVM or Solana).
 *
 * This type ensures wallet addresses are validated at construction time.
 * Stored as TEXT in the database via SQLx's transparent encoding.
 *
 * # Examples
 *
 * ```
 * use seren_core::models::WalletAddress;
 *
 * // EVM address
 * let evm = WalletAddress::new("0x1234567890123456789012345678901234567890").unwrap();
 *
 * // Solana address
 * let sol = WalletAddress::new("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v").unwrap();
 *
 * // Convert to alloy Address for EVM operations
 * if let Some(addr) = evm.as_evm() {
 * // Use with alloy...
 * }
 * ```
 */
export type WalletAddress = string;

/**
 * Wrapped wallet balance response for OpenAPI
 */
export type WalletBalanceDataResponse = {
    data: WalletBalanceResponse;
};

export type WalletBalanceKind = 'funded' | 'promotional';

/**
 * Wallet balance response (funded + promotional)
 */
export type WalletBalanceResponse = {
    /**
     * Total wallet balance in atomic units
     */
    balance_atomic: number;
    balance_usd: string;
    /**
     * Breakdown by source
     */
    by_source: Array<WalletSourceBalance>;
    /**
     * Total funded balance (fiat purchases + tier bonuses)
     */
    funded_balance_atomic: number;
    funded_balance_usd: string;
    /**
     * Whether recovery is set up for this account
     */
    has_recovery: boolean;
    /**
     * Total promotional balance (bonuses, daily claims, referrals, admin grants)
     */
    promotional_balance_atomic: number;
    promotional_balance_usd: string;
    /**
     * Warning if funds exist but no recovery is set up
     */
    recovery_warning?: string | null;
    /**
     * Total lifetime SerenBucks purchases in cents (for plan upgrade tracking)
     */
    total_purchases_cents: number;
    total_purchases_usd: string;
    wallet_address: string;
};

/**
 * Wrapped wallet recover response for OpenAPI
 */
export type WalletRecoverDataResponse = {
    data: WalletRecoverResponse;
};

/**
 * Request to recover an agent account using a recovery code.
 *
 * Use this endpoint when you've lost access to your API key but still have
 * your recovery code (provided when setting up wallet recovery).
 */
export type WalletRecoverRequest = {
    /**
     * Recovery code (24 characters). Dashes/whitespace are allowed; letters are case-insensitive.
     */
    recovery_code: string;
};

/**
 * Response from wallet recovery endpoint.
 */
export type WalletRecoverResponse = {
    /**
     * The recovered agent account (with a new API key)
     */
    agent: AgentInfo;
    /**
     * Message about recovery result
     */
    message: string;
    /**
     * New recovery code (the old one has been rotated). Save this securely!
     */
    new_recovery_code: string;
    /**
     * Setup instructions for getting started
     */
    setup: SetupInstructions;
    /**
     * Links to skill files and documentation
     */
    skill_files: SkillFiles;
    /**
     * Whether recovery was successful
     */
    success: boolean;
};

/**
 * Balance by source type
 */
export type WalletSourceBalance = {
    balance_atomic: number;
    balance_usd: string;
    kind: WalletBalanceKind;
    source: AgentCreditSource;
};

/**
 * Response for a single transaction
 */
export type WalletTransactionDirection = 'credit' | 'debit';

/**
 * Wrapped transaction history response for OpenAPI
 */
export type WalletTransactionHistoryDataResponse = {
    data: WalletTransactionHistoryResponse;
};

/**
 * Response for transaction history
 */
export type WalletTransactionHistoryResponse = {
    limit: number;
    offset: number;
    total: number;
    transactions: Array<WalletTransactionResponse>;
};

/**
 * Response for a single transaction
 */
export type WalletTransactionResponse = {
    amount_atomic: number;
    amount_usd: string;
    /**
     * Wallet balance immediately after this debit (debit entries only)
     */
    balance_after_atomic?: number | null;
    /**
     * Wallet balance immediately after this debit in USD (debit entries only)
     */
    balance_after_usd?: string | null;
    /**
     * Bonus amount included in this grant (only for tier_bonus source)
     */
    bonus_amount_usd?: string | null;
    created_at: string;
    description?: string | null;
    direction: WalletTransactionDirection;
    expires_at?: string | null;
    id: string;
    /**
     * Original Stripe payment amount (only for fiat_purchase source)
     */
    paid_amount_usd?: string | null;
    /**
     * Prompt/query text associated with this transaction (when available)
     */
    prompt?: string | null;
    /**
     * Publisher context for this transaction (when available)
     */
    publisher_id?: string | null;
    /**
     * Publisher name (when available)
     */
    publisher_name?: string | null;
    /**
     * Remaining amount on the grant (credit entries only)
     */
    remaining_atomic?: number | null;
    /**
     * Remaining amount on the grant in USD (credit entries only)
     */
    remaining_usd?: string | null;
    source: string;
};

/**
 * Webhook created response (includes secret on creation only)
 */
export type WebhookCreated = {
    /**
     * The webhook secret - only shown once at creation time
     */
    secret: string;
    webhook: WebhookInfo;
};

/**
 * Webhook delivery record
 */
export type WebhookDelivery = {
    attempt_number: number;
    created_at: string;
    delivered_at?: string | null;
    error_message?: string | null;
    event_id: string;
    event_type: string;
    id: string;
    next_retry_at?: string | null;
    payload: {
        [key: string]: unknown;
    };
    response_body?: string | null;
    response_status?: number | null;
    webhook_id: string;
};

/**
 * Webhook response (hides secret)
 */
export type WebhookInfo = {
    created_at: string;
    created_by: string;
    enabled: boolean;
    events: Array<string>;
    id: string;
    name: string;
    organization_id: string;
    project_id?: string | null;
    url: string;
};

export type AgentUpdateData = {
    body: AgentUpdateRequest;
    path?: never;
    query?: never;
    url: '/auth/agent';
};

export type AgentUpdateErrors = {
    /**
     * Invalid email
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
};

export type AgentUpdateResponses = {
    /**
     * Agent updated
     */
    200: unknown;
};

export type AgentRegisterData = {
    body: AgentRegisterRequest;
    path?: never;
    query?: never;
    url: '/auth/agent';
};

export type AgentRegisterErrors = {
    /**
     * Invalid request (validation error)
     */
    400: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type AgentRegisterResponses = {
    /**
     * Agent registered successfully
     */
    201: AgentRegisterDataResponse;
};

export type AgentRegisterResponse2 = AgentRegisterResponses[keyof AgentRegisterResponses];

export type ForgotPasswordData = {
    body: ForgotPasswordRequest;
    path?: never;
    query?: never;
    url: '/auth/forgot-password';
};

export type ForgotPasswordErrors = {
    /**
     * Invalid request
     */
    400: unknown;
};

export type ForgotPasswordResponses = {
    /**
     * Password reset email sent if account exists
     */
    200: DataResponsePasswordResetSent;
};

export type ForgotPasswordResponse = ForgotPasswordResponses[keyof ForgotPasswordResponses];

export type GetCurrentUserData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/me';
};

export type GetCurrentUserErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type GetCurrentUserResponses = {
    /**
     * Current user information with default organization
     */
    200: DataResponseUserMe;
};

export type GetCurrentUserResponse = GetCurrentUserResponses[keyof GetCurrentUserResponses];

export type ResendVerificationEmailData = {
    body: ResendVerificationRequest;
    path?: never;
    query?: never;
    url: '/auth/resend-verification';
};

export type ResendVerificationEmailErrors = {
    /**
     * Invalid request
     */
    400: unknown;
};

export type ResendVerificationEmailResponses = {
    /**
     * Verification email sent if account exists
     */
    200: DataResponseVerificationSent;
};

export type ResendVerificationEmailResponse = ResendVerificationEmailResponses[keyof ResendVerificationEmailResponses];

export type ResetPasswordData = {
    body: ResetPasswordRequest;
    path?: never;
    query?: never;
    url: '/auth/reset-password';
};

export type ResetPasswordErrors = {
    /**
     * Invalid or expired token
     */
    400: unknown;
    /**
     * Token not found
     */
    404: unknown;
};

export type ResetPasswordResponses = {
    /**
     * Password reset successfully
     */
    200: DataResponsePasswordReset;
};

export type ResetPasswordResponse = ResetPasswordResponses[keyof ResetPasswordResponses];

export type VerifyEmailData = {
    body: VerifyEmailRequest;
    path?: never;
    query?: never;
    url: '/auth/verify-email';
};

export type VerifyEmailErrors = {
    /**
     * Invalid or expired token
     */
    400: unknown;
};

export type VerifyEmailResponses = {
    /**
     * Email verified and user logged in
     */
    200: DataResponseLoginResult;
};

export type VerifyEmailResponse = VerifyEmailResponses[keyof VerifyEmailResponses];

export type GetBillingHealthData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/billing/health';
};

export type GetBillingHealthErrors = {
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetBillingHealthResponses = {
    /**
     * Billing health retrieved successfully
     */
    200: DataResponseBillingHealth;
};

export type GetBillingHealthResponse = GetBillingHealthResponses[keyof GetBillingHealthResponses];

export type GenerateInvoicesData = {
    body: GenerateInvoicesRequest;
    path?: never;
    query?: never;
    url: '/billing/invoices/generate';
};

export type GenerateInvoicesErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GenerateInvoicesResponses = {
    /**
     * Invoices generated successfully
     */
    200: DataResponseInvoicesGenerated;
};

export type GenerateInvoicesResponse = GenerateInvoicesResponses[keyof GenerateInvoicesResponses];

export type GetInvoiceData = {
    body?: never;
    path: {
        /**
         * Invoice ID
         */
        id: string;
    };
    query?: never;
    url: '/billing/invoices/{id}';
};

export type GetInvoiceErrors = {
    /**
     * Invoice not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetInvoiceResponses = {
    /**
     * Invoice retrieved successfully
     */
    200: DataResponseInvoice;
};

export type GetInvoiceResponse = GetInvoiceResponses[keyof GetInvoiceResponses];

export type IssueInvoiceData = {
    body?: never;
    path: {
        /**
         * Invoice ID
         */
        id: string;
    };
    query?: never;
    url: '/billing/invoices/{id}/issue';
};

export type IssueInvoiceErrors = {
    /**
     * Invoice not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type IssueInvoiceResponses = {
    /**
     * Invoice issued successfully
     */
    200: unknown;
};

export type CreatePaymentIntentData = {
    body?: never;
    path: {
        /**
         * Invoice ID
         */
        id: string;
    };
    query?: never;
    url: '/billing/invoices/{id}/pay';
};

export type CreatePaymentIntentErrors = {
    /**
     * Invoice not in payable state
     */
    400: unknown;
    /**
     * Invoice not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type CreatePaymentIntentResponses = {
    /**
     * Payment intent created
     */
    200: DataResponsePaymentIntentCreated;
};

export type CreatePaymentIntentResponse = CreatePaymentIntentResponses[keyof CreatePaymentIntentResponses];

export type GetPaymentHistoryData = {
    body?: never;
    path: {
        /**
         * Invoice ID
         */
        id: string;
    };
    query?: never;
    url: '/billing/invoices/{id}/payments';
};

export type GetPaymentHistoryErrors = {
    /**
     * Invoice not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetPaymentHistoryResponses = {
    /**
     * Payment history retrieved
     */
    200: DataResponsePaymentHistory;
};

export type GetPaymentHistoryResponse = GetPaymentHistoryResponses[keyof GetPaymentHistoryResponses];

export type ListPaymentMethodsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/billing/payment-methods';
};

export type ListPaymentMethodsErrors = {
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListPaymentMethodsResponses = {
    /**
     * Payment methods retrieved
     */
    200: DataResponseVecPaymentMethod;
};

export type ListPaymentMethodsResponse = ListPaymentMethodsResponses[keyof ListPaymentMethodsResponses];

export type AddPaymentMethodData = {
    body: AddPaymentMethodRequest;
    path?: never;
    query?: never;
    url: '/billing/payment-methods';
};

export type AddPaymentMethodErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type AddPaymentMethodResponses = {
    /**
     * Payment method added
     */
    200: DataResponsePaymentMethodAdded;
};

export type AddPaymentMethodResponse = AddPaymentMethodResponses[keyof AddPaymentMethodResponses];

export type DeletePaymentMethodData = {
    body?: never;
    path: {
        /**
         * Payment method ID
         */
        id: string;
    };
    query?: never;
    url: '/billing/payment-methods/{id}';
};

export type DeletePaymentMethodErrors = {
    /**
     * Payment method not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type DeletePaymentMethodResponses = {
    /**
     * Payment method removed
     */
    204: void;
};

export type DeletePaymentMethodResponse = DeletePaymentMethodResponses[keyof DeletePaymentMethodResponses];

export type CreateChargeData = {
    body: CreateChargeRequest;
    path: {
        /**
         * Publisher slug
         */
        slug: string;
    };
    query?: never;
    url: '/billing/publishers/{slug}/charges';
};

export type CreateChargeErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Insufficient balance
     */
    402: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
};

export type CreateChargeResponses = {
    /**
     * Charge created
     */
    200: DataResponsePublisherChargeInfo;
};

export type CreateChargeResponse = CreateChargeResponses[keyof CreateChargeResponses];

export type GetChargeStatusData = {
    body?: never;
    path: {
        /**
         * Publisher slug
         */
        slug: string;
        /**
         * Charge ID
         */
        charge_id: string;
    };
    query?: never;
    url: '/billing/publishers/{slug}/charges/{charge_id}';
};

export type GetChargeStatusErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Charge not found
     */
    404: unknown;
};

export type GetChargeStatusResponses = {
    /**
     * Charge retrieved
     */
    200: DataResponsePublisherChargeInfo;
};

export type GetChargeStatusResponse = GetChargeStatusResponses[keyof GetChargeStatusResponses];

export type RefundChargeData = {
    body: RefundChargeRequest;
    path: {
        /**
         * Publisher slug
         */
        slug: string;
        /**
         * Charge ID
         */
        charge_id: string;
    };
    query?: never;
    url: '/billing/publishers/{slug}/charges/{charge_id}/refund';
};

export type RefundChargeErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Charge not found
     */
    404: unknown;
};

export type RefundChargeResponses = {
    /**
     * Charge refunded
     */
    200: DataResponsePublisherChargeInfo;
};

export type RefundChargeResponse = RefundChargeResponses[keyof RefundChargeResponses];

export type SlashChargeData = {
    body: SlashChargeRequest;
    path: {
        /**
         * Publisher slug
         */
        slug: string;
        /**
         * Original charge ID
         */
        charge_id: string;
    };
    query?: never;
    url: '/billing/publishers/{slug}/charges/{charge_id}/slash';
};

export type SlashChargeErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Insufficient balance
     */
    402: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Charge not found
     */
    404: unknown;
};

export type SlashChargeResponses = {
    /**
     * Slash applied
     */
    204: void;
};

export type SlashChargeResponse = SlashChargeResponses[keyof SlashChargeResponses];

export type CreatePayoutData = {
    body: CreatePayoutRequest;
    path: {
        /**
         * Publisher slug
         */
        slug: string;
    };
    query?: never;
    url: '/billing/publishers/{slug}/payouts';
};

export type CreatePayoutErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
};

export type CreatePayoutResponses = {
    /**
     * Payout created
     */
    200: DataResponsePublisherPayoutInfo;
};

export type CreatePayoutResponse = CreatePayoutResponses[keyof CreatePayoutResponses];

export type GetPayoutStatusData = {
    body?: never;
    path: {
        /**
         * Publisher slug
         */
        slug: string;
        /**
         * Payout ID
         */
        payout_id: string;
    };
    query?: never;
    url: '/billing/publishers/{slug}/payouts/{payout_id}';
};

export type GetPayoutStatusErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Payout not found
     */
    404: unknown;
};

export type GetPayoutStatusResponses = {
    /**
     * Payout retrieved
     */
    200: DataResponsePublisherPayoutInfo;
};

export type GetPayoutStatusResponse = GetPayoutStatusResponses[keyof GetPayoutStatusResponses];

export type GetUsageSummaryData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
    };
    query?: {
        start_date?: string | null;
        end_date?: string | null;
    };
    url: '/billing/usage/{organization_id}';
};

export type GetUsageSummaryErrors = {
    /**
     * Organization not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetUsageSummaryResponses = {
    /**
     * Usage summary retrieved
     */
    200: DataResponseVecUsageSummary;
};

export type GetUsageSummaryResponse = GetUsageSummaryResponses[keyof GetUsageSummaryResponses];

export type ListAllDatabasesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/databases';
};

export type ListAllDatabasesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type ListAllDatabasesResponses = {
    /**
     * List of all databases with context
     */
    200: DataResponseVecDatabaseWithContext;
};

export type ListAllDatabasesResponse = ListAllDatabasesResponses[keyof ListAllDatabasesResponses];

export type GetMatrixData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/eval/matrix';
};

export type GetMatrixErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type GetMatrixResponses = {
    /**
     * Eval matrix
     */
    200: EvalMatrixResponse;
};

export type GetMatrixResponse = GetMatrixResponses[keyof GetMatrixResponses];

export type PostSignalsData = {
    body: EvalSignalRequest;
    path?: never;
    query?: never;
    url: '/eval/signals';
};

export type PostSignalsErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
};

export type PostSignalsResponses = {
    /**
     * Signals accepted
     */
    201: EvalSignalResponse;
};

export type PostSignalsResponse = PostSignalsResponses[keyof PostSignalsResponses];

export type ListResourcesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by publisher slug
         */
        publisher_slug?: string | null;
        /**
         * Filter by resource type (e.g., "bounty", "dataset")
         */
        resource_type?: string | null;
        /**
         * Filter by status (default: "active")
         */
        status?: string | null;
        /**
         * Maximum number of results (default: 50, max: 100)
         */
        limit?: number;
        /**
         * Offset for pagination
         */
        offset?: number;
    };
    url: '/federation';
};

export type ListResourcesErrors = {
    /**
     * Invalid query parameters
     */
    400: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListResourcesResponses = {
    /**
     * Resources retrieved successfully
     */
    200: DataResponseVecFederatedResourceWithPublisherResponse;
};

export type ListResourcesResponse = ListResourcesResponses[keyof ListResourcesResponses];

export type UpsertResourceData = {
    body: UpsertFederatedResourceRequest;
    path?: never;
    query?: never;
    url: '/federation';
};

export type UpsertResourceErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Not authorized - must be a publisher
     */
    403: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type UpsertResourceResponses = {
    /**
     * Resource upserted successfully
     */
    200: DataResponseFederatedResourceResponse;
};

export type UpsertResourceResponse = UpsertResourceResponses[keyof UpsertResourceResponses];

export type ListHistoryData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by publisher slug
         */
        publisher_slug?: string | null;
        /**
         * Filter by resource type
         */
        resource_type?: string | null;
        /**
         * Filter by external resource ID
         */
        external_id?: string | null;
        /**
         * Filter by history operation: insert, update, delete
         */
        operation?: string | null;
        /**
         * Maximum number of results (default: 50, max: 100)
         */
        limit?: number;
        /**
         * Offset for pagination
         */
        offset?: number;
    };
    url: '/federation/history';
};

export type ListHistoryErrors = {
    /**
     * Invalid query parameters
     */
    400: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListHistoryResponses = {
    /**
     * History retrieved successfully
     */
    200: DataResponseVecFederatedResourceHistoryResponse;
};

export type ListHistoryResponse = ListHistoryResponses[keyof ListHistoryResponses];

export type GetHistoryStatsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by publisher slug (optional)
         */
        publisher_slug?: string | null;
        /**
         * Filter by resource type (optional)
         */
        resource_type?: string | null;
    };
    url: '/federation/history/stats';
};

export type GetHistoryStatsErrors = {
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetHistoryStatsResponses = {
    /**
     * History stats retrieved successfully
     */
    200: DataResponseFederationHistoryStatsResponse;
};

export type GetHistoryStatsResponse = GetHistoryStatsResponses[keyof GetHistoryStatsResponses];

export type GetStatsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by publisher slug (optional - if omitted, returns stats across all publishers)
         */
        publisher_slug?: string | null;
    };
    url: '/federation/stats';
};

export type GetStatsErrors = {
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetStatsResponses = {
    /**
     * Stats retrieved successfully
     */
    200: DataResponseFederationStatsResponse;
};

export type GetStatsResponse = GetStatsResponses[keyof GetStatsResponses];

export type GetResourceData = {
    body?: never;
    path: {
        /**
         * Federated resource ID
         */
        id: string;
    };
    query?: never;
    url: '/federation/{id}';
};

export type GetResourceErrors = {
    /**
     * Resource not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetResourceResponses = {
    /**
     * Resource retrieved successfully
     */
    200: DataResponseFederatedResourceResponse;
};

export type GetResourceResponse = GetResourceResponses[keyof GetResourceResponses];

export type DeleteResourceData = {
    body?: never;
    path: {
        /**
         * Resource type
         */
        resource_type: string;
        /**
         * External resource ID
         */
        external_id: string;
    };
    query?: never;
    url: '/federation/{resource_type}/{external_id}';
};

export type DeleteResourceErrors = {
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Not authorized to delete this resource
     */
    403: unknown;
    /**
     * Resource not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type DeleteResourceResponses = {
    /**
     * Resource deleted successfully
     */
    204: void;
};

export type DeleteResourceResponse = DeleteResourceResponses[keyof DeleteResourceResponses];

export type ListConnectionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/oauth/connections';
};

export type ListConnectionsResponses = {
    /**
     * List of user's OAuth connections
     */
    200: ConnectionsResponse;
};

export type ListConnectionsResponse = ListConnectionsResponses[keyof ListConnectionsResponses];

export type RevokeConnectionByIdData = {
    body?: never;
    path: {
        /**
         * OAuth provider UUID to disconnect
         */
        provider_id: string;
    };
    query?: never;
    url: '/oauth/connections/providers/{provider_id}';
};

export type RevokeConnectionByIdErrors = {
    /**
     * Connection not found
     */
    404: unknown;
};

export type RevokeConnectionByIdResponses = {
    /**
     * Connection revoked successfully
     */
    200: RevokeResponse;
};

export type RevokeConnectionByIdResponse = RevokeConnectionByIdResponses[keyof RevokeConnectionByIdResponses];

export type RevokeConnectionData = {
    body?: never;
    path: {
        /**
         * OAuth provider slug to disconnect
         */
        provider: string;
    };
    query?: never;
    url: '/oauth/connections/{provider}';
};

export type RevokeConnectionErrors = {
    /**
     * Connection not found
     */
    404: unknown;
};

export type RevokeConnectionResponses = {
    /**
     * Connection revoked successfully
     */
    200: RevokeResponse;
};

export type RevokeConnectionResponse = RevokeConnectionResponses[keyof RevokeConnectionResponses];

export type ListProvidersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/oauth/providers';
};

export type ListProvidersResponses = {
    /**
     * List of available OAuth providers
     */
    200: ProvidersResponse;
};

export type ListProvidersResponse = ListProvidersResponses[keyof ListProvidersResponses];

export type InitiateOauthByIdData = {
    body?: never;
    path: {
        /**
         * OAuth provider UUID
         */
        provider_id: string;
    };
    query?: {
        /**
         * Where to redirect after OAuth completes
         */
        redirect_uri?: string;
    };
    url: '/oauth/providers/{provider_id}/authorize';
};

export type InitiateOauthByIdErrors = {
    /**
     * Provider not found
     */
    404: unknown;
};

export type OauthCallbackByIdData = {
    body?: never;
    path: {
        /**
         * OAuth provider UUID
         */
        provider_id: string;
    };
    query: {
        /**
         * Authorization code from provider
         */
        code: string;
        /**
         * State parameter for CSRF verification
         */
        state: string;
    };
    url: '/oauth/providers/{provider_id}/callback';
};

export type OauthCallbackByIdErrors = {
    /**
     * Invalid callback parameters
     */
    400: unknown;
    /**
     * Provider not found
     */
    404: unknown;
};

export type InitiateOauthData = {
    body?: never;
    path: {
        /**
         * OAuth provider slug (e.g., 'neon')
         */
        provider: string;
    };
    query?: {
        /**
         * Where to redirect after OAuth completes
         */
        redirect_uri?: string;
    };
    url: '/oauth/{provider}/authorize';
};

export type InitiateOauthErrors = {
    /**
     * Provider not found
     */
    404: unknown;
};

export type OauthCallbackData = {
    body?: never;
    path: {
        /**
         * OAuth provider slug
         */
        provider: string;
    };
    query: {
        /**
         * Authorization code from provider
         */
        code: string;
        /**
         * State parameter for CSRF verification
         */
        state: string;
    };
    url: '/oauth/{provider}/callback';
};

export type OauthCallbackErrors = {
    /**
     * Invalid callback parameters
     */
    400: unknown;
};

export type ListOrganizationsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/organizations';
};

export type ListOrganizationsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type ListOrganizationsResponses = {
    /**
     * List of organizations
     */
    200: DataResponseVecOrganization;
};

export type ListOrganizationsResponse = ListOrganizationsResponses[keyof ListOrganizationsResponses];

export type ListDefaultOrgApiKeysData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/organizations/default/api-keys';
};

export type ListDefaultOrgApiKeysErrors = {
    /**
     * User has no organization
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
};

export type ListDefaultOrgApiKeysResponses = {
    /**
     * List of API keys
     */
    200: DataResponseVecApiKeyInfo;
};

export type ListDefaultOrgApiKeysResponse = ListDefaultOrgApiKeysResponses[keyof ListDefaultOrgApiKeysResponses];

export type CreateDefaultOrgApiKeyData = {
    body: CreateApiKeyRequest;
    path?: never;
    query?: never;
    url: '/organizations/default/api-keys';
};

export type CreateDefaultOrgApiKeyErrors = {
    /**
     * User has no organization
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
};

export type CreateDefaultOrgApiKeyResponses = {
    /**
     * API key created
     */
    201: DataResponseApiKeyCreated;
};

export type CreateDefaultOrgApiKeyResponse = CreateDefaultOrgApiKeyResponses[keyof CreateDefaultOrgApiKeyResponses];

export type RevokeDefaultOrgApiKeyData = {
    body?: never;
    path: {
        /**
         * API key ID
         */
        key_id: string;
    };
    query?: never;
    url: '/organizations/default/api-keys/{key_id}';
};

export type RevokeDefaultOrgApiKeyErrors = {
    /**
     * User has no organization
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * API key not found
     */
    404: unknown;
};

export type RevokeDefaultOrgApiKeyResponses = {
    /**
     * API key revoked
     */
    200: unknown;
};

export type ListTasksData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
    };
    query?: {
        limit?: number;
        offset?: number;
    };
    url: '/organizations/{organization_id}/agents/tasks';
};

export type ListTasksErrors = {
    /**
     * Not authorized
     */
    403: unknown;
};

export type ListTasksResponses = {
    /**
     * Tasks retrieved
     */
    200: DataResponseVecAgentTask;
};

export type ListTasksResponse = ListTasksResponses[keyof ListTasksResponses];

export type GetTaskData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Task ID
         */
        task_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/agents/tasks/{task_id}';
};

export type GetTaskErrors = {
    /**
     * Task not found
     */
    404: unknown;
};

export type GetTaskResponses = {
    /**
     * Task retrieved
     */
    200: DataResponseAgentTask;
};

export type GetTaskResponse = GetTaskResponses[keyof GetTaskResponses];

export type CancelTaskData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Task ID
         */
        task_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/agents/tasks/{task_id}/cancel';
};

export type CancelTaskErrors = {
    /**
     * Already terminal
     */
    400: unknown;
    /**
     * Not found
     */
    404: unknown;
};

export type CancelTaskResponses = {
    /**
     * Task canceled
     */
    200: DataResponseAgentTask;
};

export type CancelTaskResponse = CancelTaskResponses[keyof CancelTaskResponses];

export type ListTaskEventsData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Task ID
         */
        task_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/agents/tasks/{task_id}/events';
};

export type ListTaskEventsErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type ListTaskEventsResponses = {
    /**
     * Events retrieved
     */
    200: DataResponseVecAgentTaskEvent;
};

export type ListTaskEventsResponse = ListTaskEventsResponses[keyof ListTaskEventsResponses];

export type StreamTaskData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        organization_id: string;
        /**
         * Task ID
         */
        task_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/agents/tasks/{task_id}/stream';
};

export type StreamTaskResponses = {
    /**
     * SSE event stream
     */
    200: unknown;
};

export type ListOrgApiKeysData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/api-keys';
};

export type ListOrgApiKeysErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Organization not found
     */
    404: unknown;
};

export type ListOrgApiKeysResponses = {
    /**
     * List of API keys
     */
    200: DataResponseVecApiKeyInfo;
};

export type ListOrgApiKeysResponse = ListOrgApiKeysResponses[keyof ListOrgApiKeysResponses];

export type CreateOrgApiKeyData = {
    body: CreateApiKeyRequest;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/api-keys';
};

export type CreateOrgApiKeyErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Organization not found
     */
    404: unknown;
};

export type CreateOrgApiKeyResponses = {
    /**
     * API key created
     */
    201: DataResponseApiKeyCreated;
};

export type CreateOrgApiKeyResponse = CreateOrgApiKeyResponses[keyof CreateOrgApiKeyResponses];

export type RevokeOrgApiKeyData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * API key ID
         */
        key_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/api-keys/{key_id}';
};

export type RevokeOrgApiKeyErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * API key not found
     */
    404: unknown;
};

export type RevokeOrgApiKeyResponses = {
    /**
     * API key revoked
     */
    200: unknown;
};

export type ListAuditLogsData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
    };
    query?: {
        /**
         * Filter by actor ID
         */
        actor_id?: string | null;
        /**
         * Filter by action (e.g., "project.create")
         */
        action?: string | null;
        /**
         * Filter by resource type (e.g., "project", "branch")
         */
        resource_type?: string | null;
        /**
         * Filter by resource ID
         */
        resource_id?: string | null;
        /**
         * Filter by status
         */
        status?: string | null;
        /**
         * Filter by action category
         */
        action_category?: string | null;
        /**
         * Filter by start date (ISO 8601)
         */
        start_date?: string | null;
        /**
         * Filter by end date (ISO 8601)
         */
        end_date?: string | null;
        /**
         * Maximum number of results (default 50, max 100)
         */
        limit?: number;
        /**
         * Offset for pagination
         */
        offset?: number;
    };
    url: '/organizations/{organization_id}/audit-logs';
};

export type ListAuditLogsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of this organization
     */
    403: unknown;
    /**
     * Organization not found
     */
    404: unknown;
};

export type ListAuditLogsResponses = {
    /**
     * Audit logs retrieved successfully
     */
    200: DataResponseAuditLogList;
};

export type ListAuditLogsResponse = ListAuditLogsResponses[keyof ListAuditLogsResponses];

export type GetAuditLogData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Audit log ID
         */
        log_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/audit-logs/{log_id}';
};

export type GetAuditLogErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of this organization
     */
    403: unknown;
    /**
     * Audit log not found
     */
    404: unknown;
};

export type GetAuditLogResponses = {
    /**
     * Audit log retrieved successfully
     */
    200: DataResponseAuditLog;
};

export type GetAuditLogResponse = GetAuditLogResponses[keyof GetAuditLogResponses];

export type GetEndpointBillingEventsData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Endpoint ID
         */
        endpoint_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/billing/endpoints/{endpoint_id}/events';
};

export type GetEndpointBillingEventsErrors = {
    /**
     * Endpoint not found for organization
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetEndpointBillingEventsResponses = {
    /**
     * Billing events retrieved successfully
     */
    200: DataResponseEndpointBillingEvents;
};

export type GetEndpointBillingEventsResponse = GetEndpointBillingEventsResponses[keyof GetEndpointBillingEventsResponses];

export type GetOrganizationConsumptionData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
    };
    query?: {
        /**
         * Optional ISO-8601 start date (YYYY-MM-DD), defaults to first day of current month.
         */
        start_date?: string | null;
        /**
         * Optional ISO-8601 end date (YYYY-MM-DD), defaults to today (UTC).
         */
        end_date?: string | null;
    };
    url: '/organizations/{organization_id}/consumption';
};

export type GetOrganizationConsumptionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * User is not a member of the organization
     */
    403: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetOrganizationConsumptionResponses = {
    /**
     * Organization consumption retrieved
     */
    200: DataResponseOrganizationConsumption;
};

export type GetOrganizationConsumptionResponse = GetOrganizationConsumptionResponses[keyof GetOrganizationConsumptionResponses];

export type ListInvitesData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/invites';
};

export type ListInvitesErrors = {
    /**
     * User is not allowed to view invites
     */
    403: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListInvitesResponses = {
    /**
     * Organization invites retrieved
     */
    200: DataResponseVecOrganizationInvite;
};

export type ListInvitesResponse = ListInvitesResponses[keyof ListInvitesResponses];

export type CreateInviteData = {
    body: CreateOrganizationInviteRequest;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/invites';
};

export type CreateInviteErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * User is not allowed to create invites
     */
    403: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type CreateInviteResponses = {
    /**
     * Invite created and email sent
     */
    201: DataResponseOrganizationInvite;
};

export type CreateInviteResponse = CreateInviteResponses[keyof CreateInviteResponses];

export type ListMembersData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/members';
};

export type ListMembersErrors = {
    /**
     * User is not a member of the organization
     */
    403: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListMembersResponses = {
    /**
     * Organization members retrieved
     */
    200: DataResponseVecOrganizationMemberWithUser;
};

export type ListMembersResponse = ListMembersResponses[keyof ListMembersResponses];

export type AssignRoleData = {
    body: AssignRoleRequest;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Member user ID
         */
        member_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/members/{member_id}/role';
};

export type AssignRoleErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - requires org.manage_members permission
     */
    403: unknown;
    /**
     * Member or role not found
     */
    404: unknown;
};

export type AssignRoleResponses = {
    /**
     * Role assigned successfully
     */
    200: unknown;
};

export type ListOrgOauthProvidersData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/oauth/providers';
};

export type ListOrgOauthProvidersErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of the organization
     */
    403: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListOrgOauthProvidersResponses = {
    /**
     * List of OAuth providers
     */
    200: OAuthProvidersDataResponse;
};

export type ListOrgOauthProvidersResponse = ListOrgOauthProvidersResponses[keyof ListOrgOauthProvidersResponses];

export type CreateOrgOauthProviderData = {
    body: CreateOAuthProviderRequest;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/oauth/providers';
};

export type CreateOrgOauthProviderErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of the organization
     */
    403: unknown;
    /**
     * Conflict - provider with this slug already exists
     */
    409: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type CreateOrgOauthProviderResponses = {
    /**
     * OAuth provider created
     */
    201: OAuthProviderDataResponse;
};

export type CreateOrgOauthProviderResponse = CreateOrgOauthProviderResponses[keyof CreateOrgOauthProviderResponses];

export type DeleteOrgOauthProviderData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * OAuth provider ID
         */
        provider_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/oauth/providers/{provider_id}';
};

export type DeleteOrgOauthProviderErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of the organization
     */
    403: unknown;
    /**
     * Provider not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type DeleteOrgOauthProviderResponses = {
    /**
     * OAuth provider deleted
     */
    204: void;
};

export type DeleteOrgOauthProviderResponse = DeleteOrgOauthProviderResponses[keyof DeleteOrgOauthProviderResponses];

export type GetOrgOauthProviderData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * OAuth provider ID
         */
        provider_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/oauth/providers/{provider_id}';
};

export type GetOrgOauthProviderErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of the organization
     */
    403: unknown;
    /**
     * Provider not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetOrgOauthProviderResponses = {
    /**
     * OAuth provider details
     */
    200: OAuthProviderDataResponse;
};

export type GetOrgOauthProviderResponse = GetOrgOauthProviderResponses[keyof GetOrgOauthProviderResponses];

export type UpdateOrgOauthProviderData = {
    body: UpdateOAuthProviderRequest;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * OAuth provider ID
         */
        provider_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/oauth/providers/{provider_id}';
};

export type UpdateOrgOauthProviderErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of the organization
     */
    403: unknown;
    /**
     * Provider not found
     */
    404: unknown;
    /**
     * Conflict - provider with this slug already exists
     */
    409: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type UpdateOrgOauthProviderResponses = {
    /**
     * OAuth provider updated
     */
    200: OAuthProviderDataResponse;
};

export type UpdateOrgOauthProviderResponse = UpdateOrgOauthProviderResponses[keyof UpdateOrgOauthProviderResponses];

export type CheckPermissionData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Permission name to check
         */
        permission: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/permissions/check/{permission}';
};

export type CheckPermissionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of this organization
     */
    403: unknown;
};

export type CheckPermissionResponses = {
    /**
     * Permission check result
     */
    200: boolean;
};

export type CheckPermissionResponse = CheckPermissionResponses[keyof CheckPermissionResponses];

export type GetMyPermissionsData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/permissions/mine';
};

export type GetMyPermissionsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of this organization
     */
    403: unknown;
};

export type GetMyPermissionsResponses = {
    /**
     * User's permissions
     */
    200: Array<string>;
};

export type GetMyPermissionsResponse = GetMyPermissionsResponses[keyof GetMyPermissionsResponses];

export type GetOrganizationPlanData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/plan';
};

export type GetOrganizationPlanErrors = {
    /**
     * Organization or plan not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetOrganizationPlanResponses = {
    /**
     * Organization plan retrieved successfully
     */
    200: DataResponseOrganizationPlanWithDetails;
};

export type GetOrganizationPlanResponse = GetOrganizationPlanResponses[keyof GetOrganizationPlanResponses];

export type ChangeOrganizationPlanData = {
    body: ChangePlanRequest;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/plan';
};

export type ChangeOrganizationPlanErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Organization or plan not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ChangeOrganizationPlanResponses = {
    /**
     * Plan changed successfully
     */
    200: DataResponseOrganizationPlanWithDetails;
};

export type ChangeOrganizationPlanResponse = ChangeOrganizationPlanResponses[keyof ChangeOrganizationPlanResponses];

export type ListOrgPublishersData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/publishers';
};

export type ListOrgPublishersErrors = {
    /**
     * Not authorized
     */
    403: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListOrgPublishersResponses = {
    /**
     * Publishers retrieved successfully
     */
    200: DataResponseVecPublisherResponse;
};

export type ListOrgPublishersResponse = ListOrgPublishersResponses[keyof ListOrgPublishersResponses];

export type CreatePublisherData = {
    body: CreatePublisherRequest;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/publishers';
};

export type CreatePublisherErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Not authorized
     */
    403: unknown;
    /**
     * Publisher slug already exists
     */
    409: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type CreatePublisherResponses = {
    /**
     * Publisher created successfully
     */
    201: DataResponsePublisherResponse;
};

export type CreatePublisherResponse = CreatePublisherResponses[keyof CreatePublisherResponses];

export type DeletePublisherData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Publisher ID
         */
        publisher_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/publishers/{publisher_id}';
};

export type DeletePublisherErrors = {
    /**
     * Not authorized
     */
    403: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type DeletePublisherResponses = {
    /**
     * Publisher deleted successfully
     */
    200: unknown;
};

export type GetOrgPublisherData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Publisher ID
         */
        publisher_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/publishers/{publisher_id}';
};

export type GetOrgPublisherErrors = {
    /**
     * Not authorized
     */
    403: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetOrgPublisherResponses = {
    /**
     * Publisher retrieved successfully
     */
    200: DataResponsePublisherResponse;
};

export type GetOrgPublisherResponse = GetOrgPublisherResponses[keyof GetOrgPublisherResponses];

export type UpdatePublisherData = {
    body: UpdatePublisherRequest;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Publisher ID
         */
        publisher_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/publishers/{publisher_id}';
};

export type UpdatePublisherErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Not authorized
     */
    403: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type UpdatePublisherResponses = {
    /**
     * Publisher updated successfully
     */
    200: DataResponsePublisherResponse;
};

export type UpdatePublisherResponse = UpdatePublisherResponses[keyof UpdatePublisherResponses];

export type GetRevenueMetricsData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Publisher ID
         */
        publisher_id: string;
    };
    query?: {
        /**
         * Number of days to analyze (default: 30)
         */
        days?: number;
    };
    url: '/organizations/{organization_id}/publishers/{publisher_id}/analytics/revenue';
};

export type GetRevenueMetricsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
};

export type GetRevenueMetricsResponses = {
    /**
     * Revenue metrics
     */
    200: RevenueMetrics;
};

export type GetRevenueMetricsResponse = GetRevenueMetricsResponses[keyof GetRevenueMetricsResponses];

export type GetRevenueByDayData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Publisher ID
         */
        publisher_id: string;
    };
    query?: {
        /**
         * Number of days to analyze (default: 30)
         */
        days?: number;
    };
    url: '/organizations/{organization_id}/publishers/{publisher_id}/analytics/revenue-by-day';
};

export type GetRevenueByDayErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
};

export type GetRevenueByDayResponses = {
    /**
     * Daily revenue breakdown
     */
    200: Array<RevenueByDay>;
};

export type GetRevenueByDayResponse = GetRevenueByDayResponses[keyof GetRevenueByDayResponses];

export type GetTopAgentsData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Publisher ID
         */
        publisher_id: string;
    };
    query?: {
        /**
         * Number of agents to return (default: 10)
         */
        limit?: number;
    };
    url: '/organizations/{organization_id}/publishers/{publisher_id}/analytics/top-agents';
};

export type GetTopAgentsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
};

export type GetTopAgentsResponses = {
    /**
     * Top agents by spending
     */
    200: Array<TopAgent>;
};

export type GetTopAgentsResponse = GetTopAgentsResponses[keyof GetTopAgentsResponses];

export type GetOrgPublisherEarningsData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Publisher ID
         */
        publisher_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/publishers/{publisher_id}/earnings';
};

export type GetOrgPublisherEarningsErrors = {
    /**
     * Not authorized
     */
    403: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetOrgPublisherEarningsResponses = {
    /**
     * Earnings retrieved successfully
     */
    200: DataResponseVecPublisherEarningsResponse;
};

export type GetOrgPublisherEarningsResponse = GetOrgPublisherEarningsResponses[keyof GetOrgPublisherEarningsResponses];

export type UploadPublisherLogoData = {
    body: LogoUploadRequest;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Publisher ID
         */
        publisher_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/publishers/{publisher_id}/logo';
};

export type UploadPublisherLogoErrors = {
    /**
     * Invalid image format or size
     */
    400: unknown;
    /**
     * Not authorized
     */
    403: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type UploadPublisherLogoResponses = {
    /**
     * Logo uploaded successfully
     */
    200: DataResponseLogoUploadResponse;
};

export type UploadPublisherLogoResponse = UploadPublisherLogoResponses[keyof UploadPublisherLogoResponses];

export type ListOrgPublisherPayoutsData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Publisher ID
         */
        publisher_id: string;
    };
    query?: {
        /**
         * Maximum number of results (default: 50)
         */
        limit?: number | null;
        /**
         * Offset for pagination
         */
        offset?: number | null;
    };
    url: '/organizations/{organization_id}/publishers/{publisher_id}/payouts';
};

export type ListOrgPublisherPayoutsErrors = {
    /**
     * Not authorized
     */
    403: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListOrgPublisherPayoutsResponses = {
    /**
     * Payouts retrieved successfully
     */
    200: DataResponseVecPublisherPayoutResponse;
};

export type ListOrgPublisherPayoutsResponse = ListOrgPublisherPayoutsResponses[keyof ListOrgPublisherPayoutsResponses];

export type CreateOrgPublisherPayoutData = {
    body: CreatePublisherPayoutRequest;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Publisher ID
         */
        publisher_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/publishers/{publisher_id}/payouts';
};

export type CreateOrgPublisherPayoutErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Not authorized
     */
    403: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type CreateOrgPublisherPayoutResponses = {
    /**
     * Payout request created
     */
    201: DataResponsePublisherPayoutResponse;
};

export type CreateOrgPublisherPayoutResponse = CreateOrgPublisherPayoutResponses[keyof CreateOrgPublisherPayoutResponses];

export type UpdatePublisherPricingData = {
    body: UpdatePricingRequest;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Publisher ID
         */
        publisher_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/publishers/{publisher_id}/pricing';
};

export type UpdatePublisherPricingErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Not authorized
     */
    403: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type UpdatePublisherPricingResponses = {
    /**
     * Pricing updated successfully
     */
    200: DataResponsePricingConfigResponse;
};

export type UpdatePublisherPricingResponse = UpdatePublisherPricingResponses[keyof UpdatePublisherPricingResponses];

export type GetQuotaUsageData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/quota';
};

export type GetQuotaUsageErrors = {
    /**
     * Organization or plan not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetQuotaUsageResponses = {
    /**
     * Quota usage retrieved successfully
     */
    200: DataResponseQuotaUsage;
};

export type GetQuotaUsageResponse = GetQuotaUsageResponses[keyof GetQuotaUsageResponses];

export type ListOrganizationRolesData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/roles';
};

export type ListOrganizationRolesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of this organization
     */
    403: unknown;
};

export type ListOrganizationRolesResponses = {
    /**
     * Roles retrieved successfully
     */
    200: DataResponseVecRbacRole;
};

export type ListOrganizationRolesResponse = ListOrganizationRolesResponses[keyof ListOrganizationRolesResponses];

export type CreateOrganizationRoleData = {
    body: CreateRoleRequest;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/roles';
};

export type CreateOrganizationRoleErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - requires org.manage_roles permission
     */
    403: unknown;
};

export type CreateOrganizationRoleResponses = {
    /**
     * Role created successfully
     */
    201: DataResponseRbacRole;
};

export type CreateOrganizationRoleResponse = CreateOrganizationRoleResponses[keyof CreateOrganizationRoleResponses];

export type DeleteOrganizationRoleData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Role ID
         */
        role_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/roles/{role_id}';
};

export type DeleteOrganizationRoleErrors = {
    /**
     * Cannot delete built-in role
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - requires org.manage_roles permission
     */
    403: unknown;
    /**
     * Role not found
     */
    404: unknown;
};

export type DeleteOrganizationRoleResponses = {
    /**
     * Role deleted successfully
     */
    204: void;
};

export type DeleteOrganizationRoleResponse = DeleteOrganizationRoleResponses[keyof DeleteOrganizationRoleResponses];

export type GetRoleData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Role ID
         */
        role_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/roles/{role_id}';
};

export type GetRoleErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of this organization
     */
    403: unknown;
    /**
     * Role not found
     */
    404: unknown;
};

export type GetRoleResponses = {
    /**
     * Role retrieved successfully
     */
    200: DataResponseRbacRole;
};

export type GetRoleResponse = GetRoleResponses[keyof GetRoleResponses];

export type UpdateRoleData = {
    body: UpdateRoleRequest;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Role ID
         */
        role_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/roles/{role_id}';
};

export type UpdateRoleErrors = {
    /**
     * Invalid request or cannot modify built-in role
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - requires org.manage_roles permission
     */
    403: unknown;
    /**
     * Role not found
     */
    404: unknown;
};

export type UpdateRoleResponses = {
    /**
     * Role updated successfully
     */
    200: DataResponseRbacRole;
};

export type UpdateRoleResponse = UpdateRoleResponses[keyof UpdateRoleResponses];

export type GetPublisherTemplateAnalyticsData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Publisher ID
         */
        publisher_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/templates/analytics/{publisher_id}';
};

export type GetPublisherTemplateAnalyticsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Not authorized
     */
    403: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetPublisherTemplateAnalyticsResponses = {
    /**
     * Analytics retrieved successfully
     */
    200: DataResponsePublisherAnalytics;
};

export type GetPublisherTemplateAnalyticsResponse = GetPublisherTemplateAnalyticsResponses[keyof GetPublisherTemplateAnalyticsResponses];

export type ListOrgVpcEndpointsData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
    };
    query?: {
        /**
         * Filter endpoints by region
         */
        region?: string | null;
    };
    url: '/organizations/{organization_id}/vpc-endpoints';
};

export type ListOrgVpcEndpointsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Organization not found
     */
    404: unknown;
};

export type ListOrgVpcEndpointsResponses = {
    /**
     * List of VPC endpoints
     */
    200: Array<OrganizationVpcEndpoint>;
};

export type ListOrgVpcEndpointsResponse = ListOrgVpcEndpointsResponses[keyof ListOrgVpcEndpointsResponses];

export type CreateOrgVpcEndpointData = {
    body: CreateOrganizationVpcEndpointRequest;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/vpc-endpoints';
};

export type CreateOrgVpcEndpointErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type CreateOrgVpcEndpointResponses = {
    /**
     * VPC endpoint recorded
     */
    201: DataResponseOrganizationVpcEndpoint;
};

export type CreateOrgVpcEndpointResponse = CreateOrgVpcEndpointResponses[keyof CreateOrgVpcEndpointResponses];

export type DeleteOrgVpcEndpointData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Organization VPC endpoint ID
         */
        endpoint_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/vpc-endpoints/{endpoint_id}';
};

export type DeleteOrgVpcEndpointErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * VPC endpoint not found
     */
    404: unknown;
};

export type DeleteOrgVpcEndpointResponses = {
    /**
     * VPC endpoint removed
     */
    204: void;
};

export type DeleteOrgVpcEndpointResponse = DeleteOrgVpcEndpointResponses[keyof DeleteOrgVpcEndpointResponses];

export type GetOrgVpcEndpointData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Organization VPC endpoint ID
         */
        endpoint_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/vpc-endpoints/{endpoint_id}';
};

export type GetOrgVpcEndpointErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * VPC endpoint not found
     */
    404: unknown;
};

export type GetOrgVpcEndpointResponses = {
    /**
     * VPC endpoint details
     */
    200: DataResponseOrganizationVpcEndpoint;
};

export type GetOrgVpcEndpointResponse = GetOrgVpcEndpointResponses[keyof GetOrgVpcEndpointResponses];

export type ListOrgVpcEndpointsByRegionData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Region
         */
        region_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/vpc/region/{region_id}/vpc_endpoints';
};

export type ListOrgVpcEndpointsByRegionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Organization not found
     */
    404: unknown;
};

export type ListOrgVpcEndpointsByRegionResponses = {
    /**
     * List of VPC endpoints
     */
    200: Array<OrganizationVpcEndpoint>;
};

export type ListOrgVpcEndpointsByRegionResponse = ListOrgVpcEndpointsByRegionResponses[keyof ListOrgVpcEndpointsByRegionResponses];

export type DeleteOrgVpcEndpointByRegionData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Region
         */
        region_id: string;
        /**
         * Organization VPC endpoint ID
         */
        endpoint_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/vpc/region/{region_id}/vpc_endpoints/{endpoint_id}';
};

export type DeleteOrgVpcEndpointByRegionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * VPC endpoint not found
     */
    404: unknown;
};

export type DeleteOrgVpcEndpointByRegionResponses = {
    /**
     * VPC endpoint removed
     */
    204: void;
};

export type DeleteOrgVpcEndpointByRegionResponse = DeleteOrgVpcEndpointByRegionResponses[keyof DeleteOrgVpcEndpointByRegionResponses];

export type GetOrgVpcEndpointByRegionData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Region
         */
        region_id: string;
        /**
         * Organization VPC endpoint ID
         */
        endpoint_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/vpc/region/{region_id}/vpc_endpoints/{endpoint_id}';
};

export type GetOrgVpcEndpointByRegionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * VPC endpoint not found
     */
    404: unknown;
};

export type GetOrgVpcEndpointByRegionResponses = {
    /**
     * VPC endpoint details
     */
    200: DataResponseOrganizationVpcEndpoint;
};

export type GetOrgVpcEndpointByRegionResponse = GetOrgVpcEndpointByRegionResponses[keyof GetOrgVpcEndpointByRegionResponses];

export type ListOrgVpcEndpointsAliasData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/vpc/vpc_endpoints';
};

export type ListOrgVpcEndpointsAliasErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Organization not found
     */
    404: unknown;
};

export type ListOrgVpcEndpointsAliasResponses = {
    /**
     * List of VPC endpoints
     */
    200: Array<OrganizationVpcEndpoint>;
};

export type ListOrgVpcEndpointsAliasResponse = ListOrgVpcEndpointsAliasResponses[keyof ListOrgVpcEndpointsAliasResponses];

export type ListWebhooksData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/webhooks';
};

export type ListWebhooksErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of this organization
     */
    403: unknown;
};

export type ListWebhooksResponses = {
    /**
     * Webhooks retrieved successfully
     */
    200: DataResponseVecWebhookInfo;
};

export type ListWebhooksResponse = ListWebhooksResponses[keyof ListWebhooksResponses];

export type CreateWebhookData = {
    body: CreateWebhookRequest;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/webhooks';
};

export type CreateWebhookErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of this organization
     */
    403: unknown;
};

export type CreateWebhookResponses = {
    /**
     * Webhook created successfully
     */
    201: DataResponseWebhookCreated;
};

export type CreateWebhookResponse = CreateWebhookResponses[keyof CreateWebhookResponses];

export type DeleteWebhookData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Webhook ID
         */
        webhook_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/webhooks/{webhook_id}';
};

export type DeleteWebhookErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of this organization
     */
    403: unknown;
    /**
     * Webhook not found
     */
    404: unknown;
};

export type DeleteWebhookResponses = {
    /**
     * Webhook deleted successfully
     */
    204: void;
};

export type DeleteWebhookResponse = DeleteWebhookResponses[keyof DeleteWebhookResponses];

export type GetWebhookData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Webhook ID
         */
        webhook_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/webhooks/{webhook_id}';
};

export type GetWebhookErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of this organization
     */
    403: unknown;
    /**
     * Webhook not found
     */
    404: unknown;
};

export type GetWebhookResponses = {
    /**
     * Webhook retrieved successfully
     */
    200: DataResponseWebhookInfo;
};

export type GetWebhookResponse = GetWebhookResponses[keyof GetWebhookResponses];

export type UpdateWebhookData = {
    body: UpdateWebhookRequest;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Webhook ID
         */
        webhook_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/webhooks/{webhook_id}';
};

export type UpdateWebhookErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of this organization
     */
    403: unknown;
    /**
     * Webhook not found
     */
    404: unknown;
};

export type UpdateWebhookResponses = {
    /**
     * Webhook updated successfully
     */
    200: DataResponseWebhookInfo;
};

export type UpdateWebhookResponse = UpdateWebhookResponses[keyof UpdateWebhookResponses];

export type ListWebhookDeliveriesData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Webhook ID
         */
        webhook_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/webhooks/{webhook_id}/deliveries';
};

export type ListWebhookDeliveriesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of this organization
     */
    403: unknown;
    /**
     * Webhook not found
     */
    404: unknown;
};

export type ListWebhookDeliveriesResponses = {
    /**
     * Deliveries retrieved successfully
     */
    200: Array<WebhookDelivery>;
};

export type ListWebhookDeliveriesResponse = ListWebhookDeliveriesResponses[keyof ListWebhookDeliveriesResponses];

export type RotateWebhookSecretData = {
    body?: never;
    path: {
        /**
         * Organization ID or 'default' for authenticated user's default organization
         */
        organization_id: string;
        /**
         * Webhook ID
         */
        webhook_id: string;
    };
    query?: never;
    url: '/organizations/{organization_id}/webhooks/{webhook_id}/rotate-secret';
};

export type RotateWebhookSecretErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden - not a member of this organization
     */
    403: unknown;
    /**
     * Webhook not found
     */
    404: unknown;
};

export type RotateWebhookSecretResponses = {
    /**
     * Secret rotated successfully
     */
    200: DataResponseWebhookCreated;
};

export type RotateWebhookSecretResponse = RotateWebhookSecretResponses[keyof RotateWebhookSecretResponses];

export type GetSupportedData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/payments/supported';
};

export type GetSupportedErrors = {
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetSupportedResponses = {
    /**
     * Supported payment kinds
     */
    200: SupportedResponse;
};

export type GetSupportedResponse = GetSupportedResponses[keyof GetSupportedResponses];

export type ListPermissionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/permissions';
};

export type ListPermissionsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type ListPermissionsResponses = {
    /**
     * Permissions retrieved successfully
     */
    200: Array<Permission>;
};

export type ListPermissionsResponse = ListPermissionsResponses[keyof ListPermissionsResponses];

export type ListPlansData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/plans';
};

export type ListPlansErrors = {
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListPlansResponses = {
    /**
     * Plans retrieved successfully
     */
    200: DataResponseVecPlan;
};

export type ListPlansResponse = ListPlansResponses[keyof ListPlansResponses];

export type GetPlanData = {
    body?: never;
    path: {
        /**
         * Plan ID
         */
        plan_id: string;
    };
    query?: never;
    url: '/plans/{plan_id}';
};

export type GetPlanErrors = {
    /**
     * Plan not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetPlanResponses = {
    /**
     * Plan retrieved successfully
     */
    200: DataResponsePlan;
};

export type GetPlanResponse = GetPlanResponses[keyof GetPlanResponses];

export type ListStorePublishersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by verification status
         */
        is_verified?: boolean | null;
        /**
         * Filter by publisher category
         */
        category?: null | PublisherCategory;
        /**
         * Search by name or slug
         */
        search?: string | null;
        /**
         * Maximum number of results (default: 50, max: 100)
         */
        limit?: number;
        /**
         * Offset for pagination
         */
        offset?: number;
    };
    url: '/publishers';
};

export type ListStorePublishersErrors = {
    /**
     * Invalid query parameters
     */
    400: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListStorePublishersResponses = {
    /**
     * Publishers retrieved successfully
     */
    200: PaginatedResponseVecPublisherResponse;
};

export type ListStorePublishersResponse = ListStorePublishersResponses[keyof ListStorePublishersResponses];

export type SuggestPublishersData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The task or query to match against publisher capabilities.
         * Examples: "scrape website", "AI research", "PDF extraction"
         */
        query: string;
        /**
         * Type of suggestions: "publisher", "agent", or "both" (default: "both")
         * Note: Agent suggestions are planned but not yet implemented.
         */
        type?: string;
        /**
         * Maximum number of results (default: 5, max: 20)
         */
        limit?: number;
    };
    url: '/publishers/suggest';
};

export type SuggestPublishersErrors = {
    /**
     * Invalid query parameters
     */
    400: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type SuggestPublishersResponses = {
    /**
     * Publisher suggestions retrieved successfully
     */
    200: DataResponseSuggestResponse;
};

export type SuggestPublishersResponse = SuggestPublishersResponses[keyof SuggestPublishersResponses];

export type GetStorePublisherData = {
    body?: never;
    path: {
        /**
         * Publisher slug
         */
        slug: string;
    };
    query?: never;
    url: '/publishers/{slug}';
};

export type GetStorePublisherErrors = {
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetStorePublisherResponses = {
    /**
     * Publisher retrieved successfully
     */
    200: DataResponsePublisherResponse;
};

export type GetStorePublisherResponse = GetStorePublisherResponses[keyof GetStorePublisherResponses];

export type PublisherRootHandlerData = {
    body: PublisherRootRequest;
    path: {
        /**
         * Publisher slug identifier
         */
        slug: string;
    };
    query?: never;
    url: '/publishers/{slug}';
};

export type PublisherRootHandlerErrors = {
    /**
     * Payment required
     */
    402: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type PublisherRootHandlerResponses = {
    /**
     * Request processed successfully (database/API)
     */
    200: unknown;
    /**
     * Agent task accepted (async)
     */
    202: unknown;
};

export type EstimateQueryData = {
    body: EstimateRequestBody;
    path: {
        /**
         * Publisher slug
         */
        slug: string;
    };
    query?: never;
    url: '/publishers/{slug}/estimate';
};

export type EstimateQueryErrors = {
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type EstimateQueryResponses = {
    /**
     * Cost estimate
     */
    200: EstimateResponse;
};

export type EstimateQueryResponse = EstimateQueryResponses[keyof EstimateQueryResponses];

export type GetStorePublisherLogoData = {
    body?: never;
    path: {
        /**
         * Publisher slug or UUID
         */
        slug: string;
    };
    query?: never;
    url: '/publishers/{slug}/logo';
};

export type GetStorePublisherLogoErrors = {
    /**
     * Logo not found
     */
    404: unknown;
};

export type GetStorePublisherLogoResponses = {
    /**
     * Publisher logo bytes
     */
    200: unknown;
};

export type ProxyToPublisherGetData = {
    body: unknown;
    path: {
        /**
         * Publisher slug identifier
         */
        slug: string;
        /**
         * Path to proxy to the publisher
         */
        path: string;
    };
    query?: never;
    url: '/publishers/{slug}/{path}';
};

export type ProxyToPublisherGetErrors = {
    /**
     * Payment required
     */
    402: unknown;
    /**
     * Publisher is geo-restricted and routing is not enabled
     */
    403: GeoRestrictedError;
    /**
     * Publisher or endpoint not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ProxyToPublisherGetError = ProxyToPublisherGetErrors[keyof ProxyToPublisherGetErrors];

export type ProxyToPublisherGetResponses = {
    /**
     * Request proxied successfully
     */
    200: unknown;
};

export type ProxyToPublisherPostData = {
    body: unknown;
    path: {
        /**
         * Publisher slug identifier
         */
        slug: string;
        /**
         * Path to proxy to the publisher
         */
        path: string;
    };
    query?: never;
    url: '/publishers/{slug}/{path}';
};

export type ProxyToPublisherPostErrors = {
    /**
     * Payment required
     */
    402: unknown;
    /**
     * Publisher is geo-restricted and routing is not enabled
     */
    403: GeoRestrictedError;
    /**
     * Publisher or endpoint not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ProxyToPublisherPostError = ProxyToPublisherPostErrors[keyof ProxyToPublisherPostErrors];

export type ProxyToPublisherPostResponses = {
    /**
     * Request proxied successfully
     */
    200: unknown;
};

export type ListSessionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sessions';
};

export type ListSessionsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type ListSessionsResponses = {
    /**
     * Sessions retrieved successfully
     */
    200: Array<Session>;
};

export type ListSessionsResponse = ListSessionsResponses[keyof ListSessionsResponses];

export type RevokeAllSessionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sessions/revoke-all';
};

export type RevokeAllSessionsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type RevokeAllSessionsResponses = {
    /**
     * All sessions revoked successfully
     */
    200: DataResponseSessionsRevoked;
};

export type RevokeAllSessionsResponse = RevokeAllSessionsResponses[keyof RevokeAllSessionsResponses];

export type RevokeSessionData = {
    body?: never;
    path: {
        /**
         * Session ID to revoke
         */
        session_id: string;
    };
    query?: never;
    url: '/sessions/{session_id}';
};

export type RevokeSessionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Session not found
     */
    404: unknown;
};

export type RevokeSessionResponses = {
    /**
     * Session revoked successfully
     */
    200: DataResponseSessionsRevoked;
};

export type RevokeSessionResponse = RevokeSessionResponses[keyof RevokeSessionResponses];

export type RevokeOtherSessionsData = {
    body?: never;
    path: {
        /**
         * Session ID to keep (current session)
         */
        session_id: string;
    };
    query?: never;
    url: '/sessions/{session_id}/revoke-others';
};

export type RevokeOtherSessionsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Session not found or doesn't belong to user
     */
    404: unknown;
};

export type RevokeOtherSessionsResponses = {
    /**
     * Other sessions revoked successfully
     */
    200: DataResponseSessionsRevoked;
};

export type RevokeOtherSessionsResponse = RevokeOtherSessionsResponses[keyof RevokeOtherSessionsResponses];

export type ListTemplatesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter to verified templates only
         */
        verified_only?: boolean;
        /**
         * Filter by language (python, typescript, javascript)
         */
        language?: string;
        /**
         * Minimum price in atomic units
         */
        min_price?: number;
        /**
         * Maximum price in atomic units
         */
        max_price?: number;
        /**
         * Search in name and description
         */
        search?: string;
        /**
         * Sort order (popularity, price_asc, price_desc, newest, oldest)
         */
        sort_by?: TemplateSortBy;
        /**
         * Maximum number of templates to return (default: 50)
         */
        limit?: number;
        /**
         * Offset for pagination (default: 0)
         */
        offset?: number;
    };
    url: '/templates';
};

export type ListTemplatesErrors = {
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListTemplatesResponses = {
    /**
     * Templates retrieved successfully
     */
    200: DataResponseVecAgentTemplateSummary;
};

export type ListTemplatesResponse = ListTemplatesResponses[keyof ListTemplatesResponses];

export type PublishTemplateData = {
    body: CreateTemplateRequest;
    path?: never;
    query?: never;
    url: '/templates/publish';
};

export type PublishTemplateErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Template slug already exists
     */
    409: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type PublishTemplateResponses = {
    /**
     * Template published successfully
     */
    201: DataResponseCreateTemplateResponse;
};

export type PublishTemplateResponse = PublishTemplateResponses[keyof PublishTemplateResponses];

export type GetTemplateData = {
    body?: never;
    path: {
        /**
         * Template slug
         */
        slug: string;
    };
    query?: never;
    url: '/templates/{slug}';
};

export type GetTemplateErrors = {
    /**
     * Template not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetTemplateResponses = {
    /**
     * Template retrieved successfully
     */
    200: DataResponseCreateTemplateResponse;
};

export type GetTemplateResponse = GetTemplateResponses[keyof GetTemplateResponses];

export type InvokeTemplateData = {
    body: InvokeTemplateRequest;
    path: {
        /**
         * Template slug
         */
        slug: string;
    };
    query?: never;
    url: '/templates/{slug}/invoke';
};

export type InvokeTemplateErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Authentication failed
     */
    401: unknown;
    /**
     * Payment required
     */
    402: unknown;
    /**
     * Template not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
    /**
     * Sandbox execution failed
     */
    503: unknown;
};

export type InvokeTemplateResponses = {
    /**
     * Template invoked successfully
     */
    200: DataResponseInvokeTemplateResponse;
};

export type InvokeTemplateResponse2 = InvokeTemplateResponses[keyof InvokeTemplateResponses];

export type GetWalletBalanceData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/wallet/balance';
};

export type GetWalletBalanceErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type GetWalletBalanceResponses = {
    /**
     * Wallet balance retrieved
     */
    200: WalletBalanceDataResponse;
};

export type GetWalletBalanceResponse = GetWalletBalanceResponses[keyof GetWalletBalanceResponses];

export type ClaimPaymentMethodBonusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/wallet/bonus/payment-method';
};

export type ClaimPaymentMethodBonusErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Recovery setup required
     */
    403: unknown;
    /**
     * Bonus already claimed
     */
    409: unknown;
};

export type ClaimPaymentMethodBonusResponses = {
    /**
     * Payment method bonus claimed
     */
    200: BonusClaimDataResponse;
};

export type ClaimPaymentMethodBonusResponse = ClaimPaymentMethodBonusResponses[keyof ClaimPaymentMethodBonusResponses];

export type ClaimSignupBonusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/wallet/bonus/signup';
};

export type ClaimSignupBonusErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Recovery setup required
     */
    403: unknown;
    /**
     * Bonus already claimed
     */
    409: unknown;
};

export type ClaimSignupBonusResponses = {
    /**
     * Signup bonus claimed
     */
    200: BonusClaimDataResponse;
};

export type ClaimSignupBonusResponse = ClaimSignupBonusResponses[keyof ClaimSignupBonusResponses];

export type ClaimDailyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/wallet/daily/claim';
};

export type ClaimDailyErrors = {
    /**
     * Not eligible for daily claim
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Recovery setup required
     */
    403: unknown;
};

export type ClaimDailyResponses = {
    /**
     * Daily credits claimed
     */
    200: DailyClaimDataResponse;
};

export type ClaimDailyResponse = ClaimDailyResponses[keyof ClaimDailyResponses];

export type CheckDailyEligibilityData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/wallet/daily/eligibility';
};

export type CheckDailyEligibilityErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type CheckDailyEligibilityResponses = {
    /**
     * Eligibility checked
     */
    200: DailyClaimEligibilityDataResponse;
};

export type CheckDailyEligibilityResponse = CheckDailyEligibilityResponses[keyof CheckDailyEligibilityResponses];

export type CreateDepositData = {
    body: DepositRequest;
    path?: never;
    query?: never;
    url: '/wallet/deposit';
};

export type CreateDepositErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Recovery setup required
     */
    403: unknown;
};

export type CreateDepositResponses = {
    /**
     * Deposit initiated
     */
    200: DepositDataResponse;
};

export type CreateDepositResponse = CreateDepositResponses[keyof CreateDepositResponses];

export type OnchainDepositData = {
    body: OnchainDepositRequest;
    path?: never;
    query?: never;
    url: '/wallet/deposit/crypto';
};

export type OnchainDepositErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Payment required
     */
    402: PaymentRequiredResponseWithInfo;
    /**
     * Publisher not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type OnchainDepositError = OnchainDepositErrors[keyof OnchainDepositErrors];

export type OnchainDepositResponses = {
    /**
     * Deposit successful
     */
    200: OnchainDepositResponse;
};

export type OnchainDepositResponse2 = OnchainDepositResponses[keyof OnchainDepositResponses];

export type GetAgentBalanceData = {
    body?: never;
    path: {
        /**
         * Agent wallet address
         */
        agent_wallet: string;
    };
    query?: never;
    url: '/wallet/lookup/{agent_wallet}';
};

export type GetAgentBalanceErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Publisher not found
     */
    404: unknown;
};

export type GetAgentBalanceResponses = {
    /**
     * Balance retrieved
     */
    200: DataResponsePublisherAgentBalance;
};

export type GetAgentBalanceResponse = GetAgentBalanceResponses[keyof GetAgentBalanceResponses];

export type WalletRecoverData = {
    body: WalletRecoverRequest;
    path?: never;
    query?: never;
    url: '/wallet/recover';
};

export type WalletRecoverErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Invalid recovery code
     */
    401: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type WalletRecoverResponses = {
    /**
     * Account recovered successfully
     */
    200: WalletRecoverDataResponse;
};

export type WalletRecoverResponse2 = WalletRecoverResponses[keyof WalletRecoverResponses];

export type SetRecoveryData = {
    body: SetRecoveryRequest;
    path?: never;
    query?: never;
    url: '/wallet/recovery';
};

export type SetRecoveryErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type SetRecoveryResponses = {
    /**
     * Recovery set up
     */
    200: RecoveryDataResponse;
};

export type SetRecoveryResponse = SetRecoveryResponses[keyof SetRecoveryResponses];

export type GetReferralInfoData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/wallet/referral';
};

export type GetReferralInfoErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type GetReferralInfoResponses = {
    /**
     * Referral info retrieved
     */
    200: ReferralInfoDataResponse;
};

export type GetReferralInfoResponse = GetReferralInfoResponses[keyof GetReferralInfoResponses];

export type ApplyReferralCodeData = {
    body: ApplyReferralRequest;
    path?: never;
    query?: never;
    url: '/wallet/referral/apply';
};

export type ApplyReferralCodeErrors = {
    /**
     * Invalid referral code
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Already has a referrer
     */
    409: unknown;
};

export type ApplyReferralCodeResponses = {
    /**
     * Referral code applied
     */
    200: unknown;
};

export type GetTransactionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Maximum number of transactions to return (default 50, max 100)
         */
        limit?: number;
        /**
         * Offset for pagination
         */
        offset?: number;
        /**
         * Include raw usage/micropayment debits (default false).
         * When false, usage debits are aggregated by day and publisher.
         */
        include_usage?: boolean;
        /**
         * Filter: only transactions on or after this date (YYYY-MM-DD, interpreted as UTC midnight)
         */
        start_date?: string | null;
        /**
         * Filter: only transactions strictly before this date (YYYY-MM-DD, interpreted as UTC midnight).
         * To include a full day, set end_date to the day *after* the last day you want.
         */
        end_date?: string | null;
    };
    url: '/wallet/transactions';
};

export type GetTransactionsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type GetTransactionsResponses = {
    /**
     * Transaction history retrieved
     */
    200: WalletTransactionHistoryDataResponse;
};

export type GetTransactionsResponse = GetTransactionsResponses[keyof GetTransactionsResponses];

export type ExportTransactionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Start date (YYYY-MM-DD, inclusive, UTC midnight)
         */
        start_date?: string | null;
        /**
         * End date (YYYY-MM-DD, exclusive, UTC midnight)
         */
        end_date?: string | null;
    };
    url: '/wallet/transactions/export';
};

export type ExportTransactionsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type ExportTransactionsResponses = {
    /**
     * CSV file download
     */
    200: unknown;
};

export type GetTransactionSummaryData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Start date (YYYY-MM-DD, inclusive, UTC midnight)
         */
        start_date?: string | null;
        /**
         * End date (YYYY-MM-DD, exclusive, UTC midnight)
         */
        end_date?: string | null;
    };
    url: '/wallet/transactions/summary';
};

export type GetTransactionSummaryErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type GetTransactionSummaryResponses = {
    /**
     * Transaction summary retrieved
     */
    200: TransactionSummaryDataResponse;
};

export type GetTransactionSummaryResponse = GetTransactionSummaryResponses[keyof GetTransactionSummaryResponses];

export type ListEventTypesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/webhooks/event-types';
};

export type ListEventTypesErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type ListEventTypesResponses = {
    /**
     * Event types retrieved successfully
     */
    200: Array<string>;
};

export type ListEventTypesResponse = ListEventTypesResponses[keyof ListEventTypesResponses];

export type HandleStripeWebhookData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/webhooks/stripe';
};

export type HandleStripeWebhookErrors = {
    /**
     * Invalid webhook signature
     */
    400: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type HandleStripeWebhookResponses = {
    /**
     * Webhook processed
     */
    200: unknown;
};
