# ABOUTME: Release workflow for building and signing production binaries.
# ABOUTME: Triggers on version tags, signs for macOS/Windows, and notarizes for Apple.

name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

env:
  TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
  TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
  # Signing availability flags (for conditional steps)
  HAS_APPLE_SIGNING: ${{ secrets.APPLE_CERTIFICATE != '' }}
  HAS_WINDOWS_SIGNING: ${{ secrets.WINDOWS_CERTIFICATE != '' }}

jobs:
  create-release:
    runs-on: ubuntu-latest
    outputs:
      release_id: ${{ steps.set_release_id.outputs.id }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate release notes
        id: release_notes
        run: |
          # Get previous tag
          PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")

          if [ -z "$PREV_TAG" ]; then
            # First release - get all commits
            COMMITS=$(git log --pretty=format:"- %s" --no-merges | head -20)
          else
            # Get commits since previous tag
            COMMITS=$(git log ${PREV_TAG}..HEAD --pretty=format:"- %s" --no-merges)
          fi

          # Create release body by writing commits directly (avoid sed issues with special chars)
          {
            echo "## What's New"
            echo ""
            echo "$COMMITS"
            echo ""
            echo "## Installation"
            echo ""
            echo "Download the appropriate installer for your platform:"
            echo "- **macOS (Apple Silicon)**: \`Seren-Desktop_*_aarch64.dmg\`"
            echo "- **macOS (Intel)**: \`Seren-Desktop_*_x64.dmg\`"
            echo "- **Windows**: \`Seren-Desktop_*_x64-setup.exe\` or \`.msi\`"
            echo "- **Linux**: \`.deb\`"
            echo ""
            echo "## Note"
            echo ""
            echo "This is an alpha release. macOS and Windows builds are unsigned - you may need to bypass security warnings to run the app."
          } > release_notes.md

          echo "Generated release notes:"
          cat release_notes.md

      - name: Check for existing release
        id: check_release
        uses: actions/github-script@v7
        with:
          script: |
            const tagName = '${{ github.ref_name }}';
            try {
              const release = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: tagName
              });
              console.log(`Found existing release: ${release.data.id} (draft: ${release.data.draft})`);
              return { exists: true, id: release.data.id, draft: release.data.draft };
            } catch (error) {
              if (error.status === 404) {
                console.log('No existing release found');
                return { exists: false };
              }
              throw error;
            }

      - name: Create Release
        id: create_release
        if: fromJSON(steps.check_release.outputs.result).exists == false
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref_name }}
          release_name: Seren Desktop ${{ github.ref_name }}
          body_path: release_notes.md
          draft: true
          prerelease: false

      - name: Set release ID output
        id: set_release_id
        run: |
          if [ "${{ fromJSON(steps.check_release.outputs.result).exists }}" == "true" ]; then
            echo "id=${{ fromJSON(steps.check_release.outputs.result).id }}" >> $GITHUB_OUTPUT
          else
            echo "id=${{ steps.create_release.outputs.id }}" >> $GITHUB_OUTPUT
          fi

  build:
    needs: create-release
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-latest
            target: aarch64-apple-darwin
            name: macOS-arm64
          - os: macos-latest
            target: x86_64-apple-darwin
            name: macOS-x64
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            name: Windows-x64
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            name: Linux-x64

    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'pnpm'

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: 'src-tauri'

      - name: Install dependencies (Ubuntu)
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf

      - name: Install frontend dependencies
        run: pnpm install

      - name: Prepare embedded runtime (macOS arm64)
        if: matrix.target == 'aarch64-apple-darwin'
        run: pnpm prepare:runtime:darwin-arm64
      - name: Prepare embedded runtime (macOS x64)
        if: matrix.target == 'x86_64-apple-darwin'
        run: pnpm prepare:runtime:darwin-x64
      - name: Prepare embedded runtime (Windows x64)
        if: matrix.target == 'x86_64-pc-windows-msvc'
        run: pnpm prepare:runtime:win32-x64
      - name: Prepare embedded runtime (Linux x64)
        if: matrix.target == 'x86_64-unknown-linux-gnu'
        run: pnpm prepare:runtime:linux-x64

      # macOS: Import certificates and setup keychain (skip if no certificate)
      - name: Import macOS certificates
        if: matrix.os == 'macos-latest' && env.HAS_APPLE_SIGNING == 'true'
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          # Create variables
          CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          # Import certificate from secrets
          echo -n "$APPLE_CERTIFICATE" | base64 --decode > $CERTIFICATE_PATH

          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Import certificate to keychain
          security import $CERTIFICATE_PATH -P "$APPLE_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

      # Windows: Setup certificate for signing (skip if no certificate)
      - name: Setup Windows signing
        if: matrix.os == 'windows-latest' && env.HAS_WINDOWS_SIGNING == 'true'
        env:
          WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
          WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
        shell: powershell
        run: |
          $certificatePath = "$env:RUNNER_TEMP\certificate.pfx"
          [System.Convert]::FromBase64String($env:WINDOWS_CERTIFICATE) | Set-Content -Path $certificatePath -AsByteStream
          Import-PfxCertificate -FilePath $certificatePath -CertStoreLocation Cert:\CurrentUser\My -Password (ConvertTo-SecureString -String $env:WINDOWS_CERTIFICATE_PASSWORD -Force -AsPlainText)

      # Build the app (with signing for macOS when certificates available)
      - name: Build Tauri app (signed)
        if: matrix.os == 'macos-latest' && env.HAS_APPLE_SIGNING == 'true'
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: pnpm tauri build --target ${{ matrix.target }}

      # Build the app (unsigned for macOS without certificates, or other platforms)
      - name: Build Tauri app (unsigned, Linux)
        if: matrix.os == 'ubuntu-latest'
        run: pnpm tauri build --target ${{ matrix.target }} --bundles deb
      - name: Build Tauri app (unsigned, other)
        if: matrix.os != 'macos-latest' && matrix.os != 'ubuntu-latest'
        run: pnpm tauri build --target ${{ matrix.target }}
      - name: Build Tauri app (unsigned, macOS without signing)
        if: matrix.os == 'macos-latest' && env.HAS_APPLE_SIGNING != 'true'
        run: pnpm tauri build --target ${{ matrix.target }}

      # macOS: Notarize the app (skip if no Apple ID configured)
      - name: Notarize macOS app
        if: matrix.os == 'macos-latest' && env.HAS_APPLE_SIGNING == 'true'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          # Find the DMG file
          DMG_PATH=$(find src-tauri/target/${{ matrix.target }}/release/bundle/dmg -name "*.dmg" | head -1)

          if [ -n "$DMG_PATH" ]; then
            echo "Notarizing $DMG_PATH"
            xcrun notarytool submit "$DMG_PATH" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_PASSWORD" \
              --team-id "$APPLE_TEAM_ID" \
              --wait

            # Staple the notarization ticket
            xcrun stapler staple "$DMG_PATH"
          fi

      # Upload artifacts
      - name: Upload macOS DMG
        if: matrix.os == 'macos-latest'
        uses: actions/upload-artifact@v4
        with:
          name: Seren-Desktop-${{ matrix.name }}.dmg
          path: src-tauri/target/${{ matrix.target }}/release/bundle/dmg/*.dmg

      - name: Upload Windows NSIS
        if: matrix.os == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: Seren-Desktop-${{ matrix.name }}.exe
          path: src-tauri/target/${{ matrix.target }}/release/bundle/nsis/*.exe

      - name: Upload Linux DEB
        if: matrix.os == 'ubuntu-latest'
        uses: actions/upload-artifact@v4
        with:
          name: Seren-Desktop-${{ matrix.name }}.deb
          path: src-tauri/target/${{ matrix.target }}/release/bundle/deb/*.deb

      # Clean up macOS keychain (only if we created one)
      - name: Cleanup macOS keychain
        if: matrix.os == 'macos-latest' && env.HAS_APPLE_SIGNING == 'true' && always()
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true

  publish-release:
    needs: [create-release, build]
    runs-on: ubuntu-latest
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Display structure of downloaded files
        run: ls -R artifacts

      - name: Publish release
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const releaseId = '${{ needs.create-release.outputs.release_id }}';
            const artifactsDir = 'artifacts';

            if (!releaseId) {
              throw new Error('No release ID available - create-release job may have failed');
            }

            console.log(`Publishing to release ID: ${releaseId}`);

            // Get existing assets to avoid duplicates
            const existingAssets = await github.rest.repos.listReleaseAssets({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId
            });
            const existingNames = new Set(existingAssets.data.map(a => a.name));

            // Upload all artifact files
            const uploadAsset = async (filePath, fileName) => {
              if (existingNames.has(fileName)) {
                console.log(`Skipping ${fileName} - already exists`);
                return;
              }
              const content = fs.readFileSync(filePath);
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: releaseId,
                name: fileName,
                data: content
              });
            };

            // Walk through artifacts directory
            const walkDir = async (dir) => {
              const files = fs.readdirSync(dir);
              for (const file of files) {
                const filePath = path.join(dir, file);
                const stat = fs.statSync(filePath);
                if (stat.isDirectory()) {
                  await walkDir(filePath);
                } else {
                  console.log(`Uploading: ${filePath}`);
                  await uploadAsset(filePath, file);
                }
              }
            };

            await walkDir(artifactsDir);

            // Undraft the release
            console.log('Setting release to published (non-draft)');
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId,
              draft: false
            });

            console.log('Release published successfully!');
