// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: `${string}://${string}/publishers/seren-cloud` | (string & {});
};

/**
 * Cloud deployment compute backend target.
 */
export type CloudDeploymentComputeBackend = 'aws_container' | 'cloudflare_worker' | 'daytona';

/**
 * Reusable execution environment profile for cloud deployments.
 */
export type CloudDeploymentEnvironment = {
    created_at: string;
    deleted_at?: string | null;
    description?: string | null;
    docker_image: string;
    id: string;
    is_default: boolean;
    name: string;
    organization_id: string;
    setup_commands: unknown;
    updated_at: string;
    user_id: string;
};

/**
 * Cloud deployment execution mode.
 */
export type CloudDeploymentMode = 'always_on' | 'cron';

/**
 * Artifact emitted by a cloud run (for example PR links, plans, screenshots).
 */
export type CloudDeploymentRunArtifact = {
    artifact_type: string;
    created_at: string;
    deployment_id: string;
    id: string;
    organization_id: string;
    payload: unknown;
    run_event_id: string;
    title?: string | null;
    updated_at: string;
    url?: string | null;
    user_id: string;
};

/**
 * A single execution run event for a cloud deployment.
 */
export type CloudDeploymentRunEvent = {
    billed_duration_ms: number;
    completed_at?: string | null;
    compute_backend: CloudDeploymentComputeBackend;
    compute_cost_atomic: number;
    compute_cost_usd: string;
    conversation_id?: string | null;
    created_at: string;
    deployment_id: string;
    execution_id: string;
    execution_time_ms: number;
    id: string;
    inference_cost_atomic: number;
    inference_cost_usd: string;
    inference_input_tokens: number;
    inference_output_tokens: number;
    metadata: unknown;
    organization_id: string;
    /**
     * Raw stdout/stderr output. Universal fallback for all backend types.
     */
    output?: string | null;
    /**
     * Structured event trace for agentic executions (thinking, tool calls, text).
     * Null for non-agentic scripts that produce plain stdout/stderr.
     */
    output_events?: unknown;
    requested_cpu_millicores: number;
    requested_memory_mib: number;
    run_name?: string | null;
    session_id?: string | null;
    session_url?: string | null;
    source: string;
    started_at: string;
    status: string;
    status_message?: string | null;
    stop_reason?: string | null;
    updated_at: string;
    user_id: string;
};

/**
 * Cloud deployment runtime kind (language/runtime format).
 */
export type CloudDeploymentRuntimeKind = 'python' | 'javascript' | 'typescript' | 'rust' | 'rust_wasm_adk';

/**
 * Cloud deployment lifecycle status.
 */
export type CloudDeploymentStatus = 'pending' | 'building' | 'running' | 'stopped' | 'failed';

/**
 * Summary view for listing deployments (excludes large fields like code_bundle).
 */
export type CloudDeploymentSummary = {
    code_bundle_hash: string;
    compute_backend: CloudDeploymentComputeBackend;
    created_at: string;
    cron_schedule?: string | null;
    endpoint_url?: string | null;
    environment_id?: string | null;
    error_message?: string | null;
    id: string;
    mode: CloudDeploymentMode;
    model_id?: string | null;
    name: string;
    orchestration_mode: OrchestrationMode;
    organization_id: string;
    runtime_kind: CloudDeploymentRuntimeKind;
    skill_slug: string;
    status: CloudDeploymentStatus;
    updated_at: string;
    user_id: string;
};

/**
 * Request body for creating a reusable execution environment.
 */
export type CreateCloudDeploymentEnvironmentRequest = {
    description?: string | null;
    docker_image: string;
    is_default?: boolean | null;
    name: string;
    setup_commands?: Array<string> | null;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseCloudDeploymentEnvironment = {
    /**
     * Reusable execution environment profile for cloud deployments.
     */
    data: {
        created_at: string;
        deleted_at?: string | null;
        description?: string | null;
        docker_image: string;
        id: string;
        is_default: boolean;
        name: string;
        organization_id: string;
        setup_commands: unknown;
        updated_at: string;
        user_id: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseCloudDeploymentRunEvent = {
    /**
     * A single execution run event for a cloud deployment.
     */
    data: {
        billed_duration_ms: number;
        completed_at?: string | null;
        compute_backend: CloudDeploymentComputeBackend;
        compute_cost_atomic: number;
        compute_cost_usd: string;
        conversation_id?: string | null;
        created_at: string;
        deployment_id: string;
        execution_id: string;
        execution_time_ms: number;
        id: string;
        inference_cost_atomic: number;
        inference_cost_usd: string;
        inference_input_tokens: number;
        inference_output_tokens: number;
        metadata: unknown;
        organization_id: string;
        /**
         * Raw stdout/stderr output. Universal fallback for all backend types.
         */
        output?: string | null;
        /**
         * Structured event trace for agentic executions (thinking, tool calls, text).
         * Null for non-agentic scripts that produce plain stdout/stderr.
         */
        output_events?: unknown;
        requested_cpu_millicores: number;
        requested_memory_mib: number;
        run_name?: string | null;
        session_id?: string | null;
        session_url?: string | null;
        source: string;
        started_at: string;
        status: string;
        status_message?: string | null;
        stop_reason?: string | null;
        updated_at: string;
        user_id: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseCloudDeploymentSummary = {
    /**
     * Summary view for listing deployments (excludes large fields like code_bundle).
     */
    data: {
        code_bundle_hash: string;
        compute_backend: CloudDeploymentComputeBackend;
        created_at: string;
        cron_schedule?: string | null;
        endpoint_url?: string | null;
        environment_id?: string | null;
        error_message?: string | null;
        id: string;
        mode: CloudDeploymentMode;
        model_id?: string | null;
        name: string;
        orchestration_mode: OrchestrationMode;
        organization_id: string;
        runtime_kind: CloudDeploymentRuntimeKind;
        skill_slug: string;
        status: CloudDeploymentStatus;
        updated_at: string;
        user_id: string;
    };
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecCloudDeploymentEnvironment = {
    data: Array<{
        created_at: string;
        deleted_at?: string | null;
        description?: string | null;
        docker_image: string;
        id: string;
        is_default: boolean;
        name: string;
        organization_id: string;
        setup_commands: unknown;
        updated_at: string;
        user_id: string;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecCloudDeploymentRunArtifact = {
    data: Array<{
        artifact_type: string;
        created_at: string;
        deployment_id: string;
        id: string;
        organization_id: string;
        payload: unknown;
        run_event_id: string;
        title?: string | null;
        updated_at: string;
        url?: string | null;
        user_id: string;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecCloudDeploymentRunEvent = {
    data: Array<{
        billed_duration_ms: number;
        completed_at?: string | null;
        compute_backend: CloudDeploymentComputeBackend;
        compute_cost_atomic: number;
        compute_cost_usd: string;
        conversation_id?: string | null;
        created_at: string;
        deployment_id: string;
        execution_id: string;
        execution_time_ms: number;
        id: string;
        inference_cost_atomic: number;
        inference_cost_usd: string;
        inference_input_tokens: number;
        inference_output_tokens: number;
        metadata: unknown;
        organization_id: string;
        /**
         * Raw stdout/stderr output. Universal fallback for all backend types.
         */
        output?: string | null;
        /**
         * Structured event trace for agentic executions (thinking, tool calls, text).
         * Null for non-agentic scripts that produce plain stdout/stderr.
         */
        output_events?: unknown;
        requested_cpu_millicores: number;
        requested_memory_mib: number;
        run_name?: string | null;
        session_id?: string | null;
        session_url?: string | null;
        source: string;
        started_at: string;
        status: string;
        status_message?: string | null;
        stop_reason?: string | null;
        updated_at: string;
        user_id: string;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * Generic API response wrapper with optional pagination
 *
 * This wrapper provides a consistent structure for all API responses,
 * making it easier for clients to handle responses uniformly. It supports
 * both single resources and collections, with optional pagination metadata.
 *
 * # Response Structure
 *
 * ```json
 * {
 * "data": T,
 * "pagination": { ... } // optional
 * }
 * ```
 *
 * # Examples
 *
 * ## Single Resource
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let project = Project {
 * id: "123".to_string(),
 * name: "My Project".to_string(),
 * };
 *
 * let response = DataResponse::new(project);
 * // Serializes to: {"data": {"id": "123", "name": "My Project"}}
 * ```
 *
 * ## Collection with Pagination
 *
 * ```rust
 * use seren_core::http::DataResponse;
 * use seren_core::pagination::PaginationMeta;
 * use serde::Serialize;
 *
 * #[derive(Serialize)]
 * struct Project {
 * id: String,
 * name: String,
 * }
 *
 * let projects: Vec<Project> = Vec::new();
 * let pagination = PaginationMeta {
 * total: 0,
 * count: 0,
 * limit: 20,
 * offset: 0,
 * has_more: false,
 * };
 *
 * let response = DataResponse::with_pagination(projects, pagination);
 * // Serializes to: {"data": [...], "pagination": {"total": 0, "count": 0, "limit": 20, "offset": 0, "has_more": false}}
 * ```
 */
export type DataResponseVecCloudDeploymentSummary = {
    data: Array<{
        code_bundle_hash: string;
        compute_backend: CloudDeploymentComputeBackend;
        created_at: string;
        cron_schedule?: string | null;
        endpoint_url?: string | null;
        environment_id?: string | null;
        error_message?: string | null;
        id: string;
        mode: CloudDeploymentMode;
        model_id?: string | null;
        name: string;
        orchestration_mode: OrchestrationMode;
        organization_id: string;
        runtime_kind: CloudDeploymentRuntimeKind;
        skill_slug: string;
        status: CloudDeploymentStatus;
        updated_at: string;
        user_id: string;
    }>;
    pagination?: null | PaginationMeta;
};

/**
 * JSON body for the deploy endpoint (base64-encoded code bundle).
 */
export type DeployRequest = {
    /**
     * Base64-encoded tar.gz of the scripts/ directory.
     */
    code_bundle_base64: string;
    compute_backend?: string | null;
    /**
     * JSON config object (will be encrypted at rest).
     */
    config?: unknown;
    cron_schedule?: string | null;
    environment_id?: string | null;
    mode: string;
    /**
     * Additional model parameters (temperature, max_tokens, etc.).
     */
    model_config?: unknown;
    /**
     * Model identifier (e.g. "anthropic/claude-sonnet-4-20250514").
     */
    model_id?: string | null;
    name: string;
    /**
     * Orchestration mode: "script" (default) or "llm".
     */
    orchestration_mode?: string | null;
    requirements_txt?: string | null;
    runtime_kind?: string | null;
    /**
     * JSON secrets object (key-value pairs, will be encrypted at rest).
     */
    secrets?: unknown;
    skill_slug: string;
    /**
     * System prompt for LLM orchestration (required when orchestration_mode = "llm").
     */
    system_prompt?: string | null;
    /**
     * Tool definitions for the LLM to call.
     */
    tool_definitions?: unknown;
};

/**
 * Cloud deployment orchestration mode.
 *
 * `Script` (default): container runs user code directly (existing behavior).
 * `Llm`: container runs the seren-orchestrator LLM tool-calling loop.
 */
export type OrchestrationMode = 'script' | 'llm';

/**
 * Pagination metadata included in responses.
 */
export type PaginationMeta = {
    /**
     * Number of items in this response
     */
    count: number;
    /**
     * Whether there are more items after this page
     */
    has_more: boolean;
    /**
     * Maximum items per page
     */
    limit: number;
    /**
     * Offset from start
     */
    offset: number;
    /**
     * Total number of items across all pages
     */
    total: number;
};

/**
 * Request body for updating a reusable execution environment.
 */
export type UpdateCloudDeploymentEnvironmentRequest = {
    description?: string | null;
    docker_image?: string | null;
    is_default?: boolean | null;
    name?: string | null;
    setup_commands?: Array<string> | null;
};

/**
 * Request body for updating config/secrets without redeploying.
 */
export type UpdateCloudDeploymentRequest = {
    config?: unknown;
    secrets?: unknown;
};

export type SerenCloudDeployData = {
    body: DeployRequest;
    path?: never;
    query?: never;
    url: '/deploy';
};

export type SerenCloudDeployErrors = {
    /**
     * Bad request
     */
    400: unknown;
    /**
     * Unauthorized
     */
    401: unknown;
};

export type SerenCloudDeployResponses = {
    /**
     * Deployment accepted
     */
    202: DataResponseCloudDeploymentSummary;
};

export type SerenCloudDeployResponse = SerenCloudDeployResponses[keyof SerenCloudDeployResponses];

export type SerenCloudListDeploymentsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/deployments';
};

export type SerenCloudListDeploymentsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type SerenCloudListDeploymentsResponses = {
    /**
     * Deployments listed
     */
    200: DataResponseVecCloudDeploymentSummary;
};

export type SerenCloudListDeploymentsResponse = SerenCloudListDeploymentsResponses[keyof SerenCloudListDeploymentsResponses];

export type SerenCloudDeleteData = {
    body?: never;
    path: {
        /**
         * Deployment ID
         */
        id: string;
    };
    query?: never;
    url: '/deployments/{id}';
};

export type SerenCloudDeleteErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenCloudDeleteResponses = {
    /**
     * Deployment deleted
     */
    204: void;
};

export type SerenCloudDeleteResponse = SerenCloudDeleteResponses[keyof SerenCloudDeleteResponses];

export type SerenCloudGetDeploymentData = {
    body?: never;
    path: {
        /**
         * Deployment ID
         */
        id: string;
    };
    query?: never;
    url: '/deployments/{id}';
};

export type SerenCloudGetDeploymentErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenCloudGetDeploymentResponses = {
    /**
     * Deployment details
     */
    200: DataResponseCloudDeploymentSummary;
};

export type SerenCloudGetDeploymentResponse = SerenCloudGetDeploymentResponses[keyof SerenCloudGetDeploymentResponses];

export type SerenCloudUpdateConfigData = {
    body: UpdateCloudDeploymentRequest;
    path: {
        /**
         * Deployment ID
         */
        id: string;
    };
    query?: never;
    url: '/deployments/{id}';
};

export type SerenCloudUpdateConfigErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenCloudUpdateConfigResponses = {
    /**
     * Config updated
     */
    200: unknown;
};

export type SerenCloudLogsData = {
    body?: never;
    path: {
        /**
         * Deployment ID
         */
        id: string;
    };
    query?: never;
    url: '/deployments/{id}/logs';
};

export type SerenCloudLogsErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenCloudLogsResponses = {
    /**
     * Logs retrieved
     */
    200: unknown;
};

export type SerenCloudDeploymentRunsData = {
    body?: never;
    path: {
        /**
         * Deployment ID
         */
        id: string;
    };
    query?: {
        /**
         * Max runs to return (default: 50, max: 100)
         */
        limit?: number;
        /**
         * Pagination offset (default: 0)
         */
        offset?: number;
        /**
         * Repeat or comma-separate statuses: queued, running, completed, failed, cancelled, timeout, blocked, error
         */
        status?: string;
        /**
         * Filter by compute backend (aws_container, cloudflare_worker, daytona)
         */
        compute_backend?: string;
        /**
         * Filter by run source (api, cli, scheduler, ui, system, unknown)
         */
        source?: string;
        /**
         * Filter runs by artifact existence
         */
        has_artifacts?: boolean;
        /**
         * Filter runs started at/after RFC3339 timestamp
         */
        started_after?: string;
        /**
         * Filter runs started at/before RFC3339 timestamp
         */
        started_before?: string;
        /**
         * Case-insensitive search across execution_id, status, source, run_name, output, metadata
         */
        q?: string;
    };
    url: '/deployments/{id}/runs';
};

export type SerenCloudDeploymentRunsErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenCloudDeploymentRunsResponses = {
    /**
     * Runs listed
     */
    200: DataResponseVecCloudDeploymentRunEvent;
};

export type SerenCloudDeploymentRunsResponse = SerenCloudDeploymentRunsResponses[keyof SerenCloudDeploymentRunsResponses];

export type SerenCloudRunData = {
    body?: unknown;
    path: {
        /**
         * Deployment ID
         */
        id: string;
    };
    query?: never;
    url: '/deployments/{id}/runs';
};

export type SerenCloudRunErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenCloudRunResponses = {
    /**
     * Run completed (always_on deployments)
     */
    200: unknown;
    /**
     * Run triggered
     */
    202: unknown;
};

export type SerenCloudDeploymentRunData = {
    body?: never;
    path: {
        /**
         * Deployment ID
         */
        id: string;
        /**
         * Run event ID
         */
        run_id: string;
    };
    query?: never;
    url: '/deployments/{id}/runs/{run_id}';
};

export type SerenCloudDeploymentRunErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenCloudDeploymentRunResponses = {
    /**
     * Run event details
     */
    200: DataResponseCloudDeploymentRunEvent;
};

export type SerenCloudDeploymentRunResponse = SerenCloudDeploymentRunResponses[keyof SerenCloudDeploymentRunResponses];

export type SerenCloudDeploymentRunArtifactsData = {
    body?: never;
    path: {
        /**
         * Deployment ID
         */
        id: string;
        /**
         * Run event ID
         */
        run_id: string;
    };
    query?: {
        /**
         * Max artifacts to return (default: 50, max: 200)
         */
        limit?: number;
        /**
         * Pagination offset (default: 0)
         */
        offset?: number;
    };
    url: '/deployments/{id}/runs/{run_id}/artifacts';
};

export type SerenCloudDeploymentRunArtifactsErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenCloudDeploymentRunArtifactsResponses = {
    /**
     * Run artifacts listed
     */
    200: DataResponseVecCloudDeploymentRunArtifact;
};

export type SerenCloudDeploymentRunArtifactsResponse = SerenCloudDeploymentRunArtifactsResponses[keyof SerenCloudDeploymentRunArtifactsResponses];

export type SerenCloudDeploymentRunCancelData = {
    body?: never;
    path: {
        /**
         * Deployment ID
         */
        id: string;
        /**
         * Run event ID
         */
        run_id: string;
    };
    query?: never;
    url: '/deployments/{id}/runs/{run_id}/cancel';
};

export type SerenCloudDeploymentRunCancelErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenCloudDeploymentRunCancelResponses = {
    /**
     * Run cancellation requested
     */
    200: DataResponseCloudDeploymentRunEvent;
};

export type SerenCloudDeploymentRunCancelResponse = SerenCloudDeploymentRunCancelResponses[keyof SerenCloudDeploymentRunCancelResponses];

export type SerenCloudDeploymentRunStreamData = {
    body?: never;
    path: {
        /**
         * Deployment ID
         */
        id: string;
        /**
         * Run event ID
         */
        run_id: string;
    };
    query?: never;
    url: '/deployments/{id}/runs/{run_id}/stream';
};

export type SerenCloudDeploymentRunStreamErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenCloudDeploymentRunStreamResponses = {
    /**
     * SSE stream of run updates
     */
    200: unknown;
};

export type SerenCloudStartData = {
    body?: never;
    path: {
        /**
         * Deployment ID
         */
        id: string;
    };
    query?: never;
    url: '/deployments/{id}/start';
};

export type SerenCloudStartErrors = {
    /**
     * Bad request (not always_on)
     */
    400: unknown;
};

export type SerenCloudStartResponses = {
    /**
     * Deployment started
     */
    200: unknown;
};

export type SerenCloudStopData = {
    body?: never;
    path: {
        /**
         * Deployment ID
         */
        id: string;
    };
    query?: never;
    url: '/deployments/{id}/stop';
};

export type SerenCloudStopErrors = {
    /**
     * Bad request (not always_on)
     */
    400: unknown;
};

export type SerenCloudStopResponses = {
    /**
     * Deployment stopped
     */
    200: unknown;
};

export type SerenCloudListEnvironmentsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/environments';
};

export type SerenCloudListEnvironmentsResponses = {
    /**
     * Environments listed
     */
    200: DataResponseVecCloudDeploymentEnvironment;
};

export type SerenCloudListEnvironmentsResponse = SerenCloudListEnvironmentsResponses[keyof SerenCloudListEnvironmentsResponses];

export type SerenCloudCreateEnvironmentData = {
    body: CreateCloudDeploymentEnvironmentRequest;
    path?: never;
    query?: never;
    url: '/environments';
};

export type SerenCloudCreateEnvironmentErrors = {
    /**
     * Bad request
     */
    400: unknown;
};

export type SerenCloudCreateEnvironmentResponses = {
    /**
     * Environment created
     */
    200: DataResponseCloudDeploymentEnvironment;
};

export type SerenCloudCreateEnvironmentResponse = SerenCloudCreateEnvironmentResponses[keyof SerenCloudCreateEnvironmentResponses];

export type SerenCloudDeleteEnvironmentData = {
    body?: never;
    path: {
        /**
         * Environment ID
         */
        id: string;
    };
    query?: never;
    url: '/environments/{id}';
};

export type SerenCloudDeleteEnvironmentErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenCloudDeleteEnvironmentResponses = {
    /**
     * Environment deleted
     */
    204: void;
};

export type SerenCloudDeleteEnvironmentResponse = SerenCloudDeleteEnvironmentResponses[keyof SerenCloudDeleteEnvironmentResponses];

export type SerenCloudGetEnvironmentData = {
    body?: never;
    path: {
        /**
         * Environment ID
         */
        id: string;
    };
    query?: never;
    url: '/environments/{id}';
};

export type SerenCloudGetEnvironmentErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenCloudGetEnvironmentResponses = {
    /**
     * Environment details
     */
    200: DataResponseCloudDeploymentEnvironment;
};

export type SerenCloudGetEnvironmentResponse = SerenCloudGetEnvironmentResponses[keyof SerenCloudGetEnvironmentResponses];

export type SerenCloudUpdateEnvironmentData = {
    body: UpdateCloudDeploymentEnvironmentRequest;
    path: {
        /**
         * Environment ID
         */
        id: string;
    };
    query?: never;
    url: '/environments/{id}';
};

export type SerenCloudUpdateEnvironmentErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenCloudUpdateEnvironmentResponses = {
    /**
     * Environment updated
     */
    200: DataResponseCloudDeploymentEnvironment;
};

export type SerenCloudUpdateEnvironmentResponse = SerenCloudUpdateEnvironmentResponses[keyof SerenCloudUpdateEnvironmentResponses];

export type SerenCloudRunsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Max runs to return (default: 50, max: 100)
         */
        limit?: number;
        /**
         * Pagination offset (default: 0)
         */
        offset?: number;
        /**
         * Repeat or comma-separate statuses: queued, running, completed, failed, cancelled, timeout, blocked, error
         */
        status?: string;
        /**
         * Filter by compute backend (aws_container, cloudflare_worker, daytona)
         */
        compute_backend?: string;
        /**
         * Filter by run source (api, cli, scheduler, ui, system, unknown)
         */
        source?: string;
        /**
         * Filter runs by artifact existence
         */
        has_artifacts?: boolean;
        /**
         * Filter runs started at/after RFC3339 timestamp
         */
        started_after?: string;
        /**
         * Filter runs started at/before RFC3339 timestamp
         */
        started_before?: string;
        /**
         * Case-insensitive search across execution_id, status, source, run_name, output, metadata
         */
        q?: string;
    };
    url: '/runs';
};

export type SerenCloudRunsErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
};

export type SerenCloudRunsResponses = {
    /**
     * All runs listed
     */
    200: DataResponseVecCloudDeploymentRunEvent;
};

export type SerenCloudRunsResponse = SerenCloudRunsResponses[keyof SerenCloudRunsResponses];

export type SerenCloudRunDetailData = {
    body?: never;
    path: {
        /**
         * Run event ID
         */
        run_id: string;
    };
    query?: never;
    url: '/runs/{run_id}';
};

export type SerenCloudRunDetailErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenCloudRunDetailResponses = {
    /**
     * Run event details
     */
    200: DataResponseCloudDeploymentRunEvent;
};

export type SerenCloudRunDetailResponse = SerenCloudRunDetailResponses[keyof SerenCloudRunDetailResponses];

export type SerenCloudRunArtifactsData = {
    body?: never;
    path: {
        /**
         * Run event ID
         */
        run_id: string;
    };
    query?: {
        /**
         * Max artifacts to return (default: 50, max: 200)
         */
        limit?: number;
        /**
         * Pagination offset (default: 0)
         */
        offset?: number;
    };
    url: '/runs/{run_id}/artifacts';
};

export type SerenCloudRunArtifactsErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenCloudRunArtifactsResponses = {
    /**
     * Run artifacts listed
     */
    200: DataResponseVecCloudDeploymentRunArtifact;
};

export type SerenCloudRunArtifactsResponse = SerenCloudRunArtifactsResponses[keyof SerenCloudRunArtifactsResponses];

export type SerenCloudRunCancelData = {
    body?: never;
    path: {
        /**
         * Run event ID
         */
        run_id: string;
    };
    query?: never;
    url: '/runs/{run_id}/cancel';
};

export type SerenCloudRunCancelErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenCloudRunCancelResponses = {
    /**
     * Run cancellation requested
     */
    200: DataResponseCloudDeploymentRunEvent;
};

export type SerenCloudRunCancelResponse = SerenCloudRunCancelResponses[keyof SerenCloudRunCancelResponses];

export type SerenCloudRunStreamData = {
    body?: never;
    path: {
        /**
         * Run event ID
         */
        run_id: string;
    };
    query?: never;
    url: '/runs/{run_id}/stream';
};

export type SerenCloudRunStreamErrors = {
    /**
     * Not found
     */
    404: unknown;
};

export type SerenCloudRunStreamResponses = {
    /**
     * SSE stream of run updates
     */
    200: unknown;
};
