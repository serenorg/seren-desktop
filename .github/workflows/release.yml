# ABOUTME: Release workflow for building and signing production binaries.
# ABOUTME: Triggers on version tags, signs for macOS/Windows, and notarizes for Apple.

name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

env:
  TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
  TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
  # Signing availability flags (for conditional steps)
  HAS_APPLE_SIGNING: ${{ secrets.APPLE_CERTIFICATE != '' }}
  # SSL.com eSigner cloud signing for Windows EV code signing
  HAS_WINDOWS_SIGNING: ${{ secrets.ES_USERNAME != '' }}

jobs:
  create-release:
    runs-on: ubuntu-latest
    outputs:
      release_id: ${{ steps.set_release_id.outputs.id }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate release notes
        id: release_notes
        run: |
          # Get previous tag
          PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")

          if [ -z "$PREV_TAG" ]; then
            # First release - get all commits
            COMMITS=$(git log --pretty=format:"- %s" --no-merges | head -20)
          else
            # Get commits since previous tag
            COMMITS=$(git log ${PREV_TAG}..HEAD --pretty=format:"- %s" --no-merges)
          fi

          # Create release body by writing commits directly (avoid sed issues with special chars)
          {
            echo "## What's New"
            echo ""
            echo "$COMMITS"
            echo ""
            echo "## Installation"
            echo ""
            echo "Download the appropriate installer for your platform:"
            echo "- **macOS (Apple Silicon)**: \`Seren-Desktop_*_aarch64.dmg\`"
            echo "- **macOS (Intel)**: \`Seren-Desktop_*_x64.dmg\`"
            echo "- **Windows**: \`Seren-Desktop_*_x64-setup.exe\` or \`.msi\`"
            echo "- **Linux**: \`.deb\` or \`.AppImage\`"
            echo ""
            echo "## Note"
            echo ""
            echo "This is an alpha release. Windows builds are EV code signed. macOS builds are signed; if notarization is still processing, run: \`xattr -cr /Volumes/SerenDesktop/SerenDesktop.app\`"
          } > release_notes.md

          echo "Generated release notes:"
          cat release_notes.md

      - name: Check for existing release
        id: check_release
        uses: actions/github-script@v7
        with:
          script: |
            const tagName = '${{ github.ref_name }}';
            try {
              const release = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: tagName
              });
              console.log(`Found existing release: ${release.data.id} (draft: ${release.data.draft})`);
              return { exists: true, id: release.data.id, draft: release.data.draft };
            } catch (error) {
              if (error.status === 404) {
                console.log('No existing release found');
                return { exists: false };
              }
              throw error;
            }

      - name: Create Release
        id: create_release
        if: fromJSON(steps.check_release.outputs.result).exists == false
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref_name }}
          release_name: Seren Desktop ${{ github.ref_name }}
          body_path: release_notes.md
          draft: true
          prerelease: false

      - name: Set release ID output
        id: set_release_id
        run: |
          if [ "${{ fromJSON(steps.check_release.outputs.result).exists }}" == "true" ]; then
            echo "id=${{ fromJSON(steps.check_release.outputs.result).id }}" >> $GITHUB_OUTPUT
          else
            echo "id=${{ steps.create_release.outputs.id }}" >> $GITHUB_OUTPUT
          fi

  build:
    needs: create-release
    env:
      NODE_OPTIONS: '--max-old-space-size=4096'
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-latest
            target: aarch64-apple-darwin
            name: macOS-arm64
            updater_platform: darwin-aarch64
          - os: macos-latest
            target: x86_64-apple-darwin
            name: macOS-x64
            updater_platform: darwin-x86_64
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            name: Windows-x64
            updater_platform: windows-x86_64
          - os: ubuntu-22.04
            target: x86_64-unknown-linux-gnu
            name: Linux-x64
            updater_platform: linux-x86_64

    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set version from tag
        shell: bash
        run: |
          # Extract version from git tag (strip 'v' prefix)
          VERSION="${GITHUB_REF_NAME#v}"
          echo "Setting version to $VERSION"
          # Update tauri.conf.json with the tag version
          node -e "
            const fs = require('fs');
            const conf = JSON.parse(fs.readFileSync('src-tauri/tauri.conf.json', 'utf8'));
            conf.version = '$VERSION';
            fs.writeFileSync('src-tauri/tauri.conf.json', JSON.stringify(conf, null, 2) + '\n');
          "
          echo "Updated tauri.conf.json version to $VERSION"

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'pnpm'

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          prefix-key: ${{ matrix.os }}
          workspaces: 'src-tauri'

      - name: Install dependencies (Ubuntu)
        if: startsWith(matrix.os, 'ubuntu')
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libayatana-appindicator3-dev librsvg2-dev libssl-dev libxdo-dev patchelf libfuse2

      - name: Install frontend dependencies
        run: pnpm install

      - name: Prepare embedded runtime (macOS arm64)
        if: matrix.target == 'aarch64-apple-darwin'
        run: pnpm prepare:runtime:darwin-arm64
      - name: Prepare embedded runtime (macOS x64)
        if: matrix.target == 'x86_64-apple-darwin'
        run: pnpm prepare:runtime:darwin-x64
      - name: Prepare embedded runtime (Windows x64)
        if: matrix.target == 'x86_64-pc-windows-msvc'
        run: pnpm prepare:runtime:win32-x64
      - name: Prepare embedded runtime (Linux x64)
        if: matrix.target == 'x86_64-unknown-linux-gnu'
        run: pnpm prepare:runtime:linux-x64

      # macOS: Import certificates and setup keychain (skip if no certificate)
      - name: Import macOS certificates
        if: matrix.os == 'macos-latest' && env.HAS_APPLE_SIGNING == 'true'
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          # Create variables
          CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          # Import certificate from secrets
          echo -n "$APPLE_CERTIFICATE" | base64 --decode > $CERTIFICATE_PATH

          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Import certificate to keychain
          security import $CERTIFICATE_PATH -P "$APPLE_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

      # Build the app (with signing for macOS when certificates available)
      # Note: APPLE_ID/PASSWORD/TEAM_ID removed to prevent Tauri's internal notarization
      # Notarization is handled separately with polling in the "Notarize macOS app" step
      - name: Build Tauri app (signed)
        if: matrix.os == 'macos-latest' && env.HAS_APPLE_SIGNING == 'true'
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: pnpm tauri build --target ${{ matrix.target }}

      # Build the app (unsigned for macOS without certificates, or other platforms)
      - name: Build Tauri app (unsigned, Linux)
        if: startsWith(matrix.os, 'ubuntu')
        env:
          NO_STRIP: "true"
        run: pnpm tauri build --verbose --target ${{ matrix.target }} --bundles deb,appimage
      - name: Build Tauri app (unsigned, other)
        if: matrix.os != 'macos-latest' && !startsWith(matrix.os, 'ubuntu')
        run: pnpm tauri build --target ${{ matrix.target }}
      - name: Build Tauri app (unsigned, macOS without signing)
        if: matrix.os == 'macos-latest' && env.HAS_APPLE_SIGNING != 'true'
        run: pnpm tauri build --target ${{ matrix.target }}

      # Upload macOS DMG immediately (before notarization so we always have an artifact)
      - name: Upload macOS DMG (pre-notarization)
        if: matrix.os == 'macos-latest'
        uses: actions/upload-artifact@v4
        with:
          name: Seren-Desktop-${{ matrix.name }}.dmg
          path: src-tauri/target/${{ matrix.target }}/release/bundle/dmg/*.dmg

      # macOS: Notarize the app (non-blocking - continues even if notarization fails/times out)
      # Uses polling with retries to handle Apple's notary service issues
      - name: Notarize macOS app
        id: notarize
        if: matrix.os == 'macos-latest' && env.HAS_APPLE_SIGNING == 'true'
        continue-on-error: true
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          # Find the DMG file
          DMG_PATH=$(find src-tauri/target/${{ matrix.target }}/release/bundle/dmg -name "*.dmg" | head -1)

          if [ -z "$DMG_PATH" ]; then
            echo "No DMG found"
            exit 1
          fi

          echo "Notarizing $DMG_PATH"

          # Retry logic: 3 submission attempts
          MAX_SUBMISSION_ATTEMPTS=3
          SUBMISSION_ATTEMPT=0
          NOTARIZATION_SUCCESS=false

          while [ $SUBMISSION_ATTEMPT -lt $MAX_SUBMISSION_ATTEMPTS ] && [ "$NOTARIZATION_SUCCESS" = "false" ]; do
            SUBMISSION_ATTEMPT=$((SUBMISSION_ATTEMPT + 1))
            echo "=== Submission attempt $SUBMISSION_ATTEMPT/$MAX_SUBMISSION_ATTEMPTS ==="

            # Submit for notarization
            SUBMIT_OUTPUT=$(xcrun notarytool submit "$DMG_PATH" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_PASSWORD" \
              --team-id "$APPLE_TEAM_ID" \
              --output-format json 2>&1) || true

            echo "Submit output: $SUBMIT_OUTPUT"
            SUBMISSION_ID=$(echo "$SUBMIT_OUTPUT" | grep -o '"id"[[:space:]]*:[[:space:]]*"[^"]*"' | head -1 | sed 's/.*"id"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')

            if [ -z "$SUBMISSION_ID" ]; then
              echo "Failed to get submission ID, retrying in 30 seconds..."
              sleep 30
              continue
            fi

            echo "Submission ID: $SUBMISSION_ID"
            echo "Polling for notarization status..."

            # Poll for status (max 2 hours per attempt = 120 polls * 60 seconds)
            MAX_POLL_ATTEMPTS=120
            POLL_ATTEMPT=0
            POLL_RESULT="timeout"

            while [ $POLL_ATTEMPT -lt $MAX_POLL_ATTEMPTS ]; do
              POLL_ATTEMPT=$((POLL_ATTEMPT + 1))
              echo "Status check $POLL_ATTEMPT/$MAX_POLL_ATTEMPTS (attempt $SUBMISSION_ATTEMPT)..."

              STATUS_OUTPUT=$(xcrun notarytool info "$SUBMISSION_ID" \
                --apple-id "$APPLE_ID" \
                --password "$APPLE_PASSWORD" \
                --team-id "$APPLE_TEAM_ID" \
                --output-format json 2>&1) || true

              # Check for Accepted status
              if echo "$STATUS_OUTPUT" | grep -q '"status"[[:space:]]*:[[:space:]]*"Accepted"'; then
                echo "Notarization accepted!"
                POLL_RESULT="accepted"
                break
              fi

              # Check for Invalid/Rejected status (don't retry these - they need fixes)
              if echo "$STATUS_OUTPUT" | grep -q '"status"[[:space:]]*:[[:space:]]*"Invalid"'; then
                echo "Notarization failed - Invalid"
                xcrun notarytool log "$SUBMISSION_ID" \
                  --apple-id "$APPLE_ID" \
                  --password "$APPLE_PASSWORD" \
                  --team-id "$APPLE_TEAM_ID" || true
                POLL_RESULT="rejected"
                break
              fi

              if echo "$STATUS_OUTPUT" | grep -q '"status"[[:space:]]*:[[:space:]]*"Rejected"'; then
                echo "Notarization rejected"
                xcrun notarytool log "$SUBMISSION_ID" \
                  --apple-id "$APPLE_ID" \
                  --password "$APPLE_PASSWORD" \
                  --team-id "$APPLE_TEAM_ID" || true
                POLL_RESULT="rejected"
                break
              fi

              # Still in progress, wait 60 seconds
              sleep 60
            done

            if [ "$POLL_RESULT" = "accepted" ]; then
              NOTARIZATION_SUCCESS=true
            elif [ "$POLL_RESULT" = "rejected" ]; then
              # Don't retry rejections - they need code fixes
              echo "Notarization was rejected by Apple - not retrying"
              exit 1
            else
              echo "Polling timed out after 2 hours, will retry submission..."
              sleep 60
            fi
          done

          if [ "$NOTARIZATION_SUCCESS" = "false" ]; then
            echo "Notarization failed after $MAX_SUBMISSION_ATTEMPTS attempts"
            exit 1
          fi

          # Staple the notarization ticket
          echo "Stapling notarization ticket..."
          xcrun stapler staple "$DMG_PATH"
          echo "Notarization and stapling complete!"

      # Upload notarized DMG if notarization succeeded (overwrites the pre-notarization artifact)
      - name: Upload macOS DMG (notarized)
        if: matrix.os == 'macos-latest' && steps.notarize.outcome == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: Seren-Desktop-${{ matrix.name }}.dmg
          path: src-tauri/target/${{ matrix.target }}/release/bundle/dmg/*.dmg
          overwrite: true

      # Move updater artifacts (.sig, .nsis.zip) out of NSIS dir before code signing
      # so SSL.com's batch_sign doesn't choke on non-exe files
      - name: Move updater artifacts before code signing
        if: matrix.os == 'windows-latest' && env.HAS_WINDOWS_SIGNING == 'true'
        shell: pwsh
        run: |
          $nsisDir = "src-tauri/target/${{ matrix.target }}/release/bundle/nsis"
          $tempDir = "src-tauri/target/${{ matrix.target }}/release/bundle/nsis-updater-temp"
          New-Item -ItemType Directory -Force -Path $tempDir | Out-Null
          Get-ChildItem -Path $nsisDir -Exclude "*.exe" | ForEach-Object {
            Move-Item -Path $_.FullName -Destination $tempDir -Force
            Write-Host "Moved aside: $($_.Name)"
          }

      # Windows: Sign executables with SSL.com eSigner (cloud EV code signing)
      # Sign NSIS installer (.exe) - output to temp dir then copy back
      # (workaround: action's override flag doesn't work, same-dir output fails)
      - name: Sign Windows NSIS installer
        if: matrix.os == 'windows-latest' && env.HAS_WINDOWS_SIGNING == 'true'
        uses: sslcom/esigner-codesign@v1.3.2
        with:
          command: batch_sign
          username: ${{ secrets.ES_USERNAME }}
          password: ${{ secrets.ES_PASSWORD }}
          credential_id: ${{ secrets.ES_CREDENTIAL_ID }}
          totp_secret: ${{ secrets.ES_TOTP_SECRET }}
          dir_path: src-tauri/target/${{ matrix.target }}/release/bundle/nsis
          output_path: src-tauri/target/${{ matrix.target }}/release/bundle/nsis-signed
          environment_name: PROD
          malware_block: true

      # Copy signed files back to original location
      - name: Copy signed NSIS installer
        if: matrix.os == 'windows-latest' && env.HAS_WINDOWS_SIGNING == 'true'
        shell: pwsh
        run: |
          $signedDir = "src-tauri/target/${{ matrix.target }}/release/bundle/nsis-signed"
          $targetDir = "src-tauri/target/${{ matrix.target }}/release/bundle/nsis"

          if (Test-Path $signedDir) {
            Write-Host "Copying signed files from $signedDir to $targetDir"
            Get-ChildItem -Path $signedDir -Filter "*.exe" | ForEach-Object {
              Copy-Item -Path $_.FullName -Destination $targetDir -Force
              Write-Host "Copied: $($_.Name)"
            }
          } else {
            Write-Host "Signed output directory not found: $signedDir"
            exit 1
          }

      # Restore updater artifacts (.sig, .nsis.zip) back to NSIS dir
      - name: Restore updater artifacts after code signing
        if: matrix.os == 'windows-latest' && env.HAS_WINDOWS_SIGNING == 'true'
        shell: pwsh
        run: |
          $nsisDir = "src-tauri/target/${{ matrix.target }}/release/bundle/nsis"
          $tempDir = "src-tauri/target/${{ matrix.target }}/release/bundle/nsis-updater-temp"
          if (Test-Path $tempDir) {
            Get-ChildItem -Path $tempDir | ForEach-Object {
              Move-Item -Path $_.FullName -Destination $nsisDir -Force
              Write-Host "Restored: $($_.Name)"
            }
            Remove-Item -Path $tempDir -Force
          }

      # Verify Windows code signing
      - name: Verify Windows code signing
        if: matrix.os == 'windows-latest' && env.HAS_WINDOWS_SIGNING == 'true'
        shell: pwsh
        run: |
          Write-Host "Verifying code signatures..."

          # Verify NSIS installer
          $nsisFiles = Get-ChildItem -Path "src-tauri/target/${{ matrix.target }}/release/bundle/nsis" -Filter "*.exe"
          foreach ($file in $nsisFiles) {
            Write-Host "Checking signature for: $($file.FullName)"
            $sig = Get-AuthenticodeSignature -FilePath $file.FullName
            if ($sig.Status -eq "Valid") {
              Write-Host "✓ Valid signature: $($sig.SignerCertificate.Subject)"
            } else {
              Write-Host "✗ Invalid or missing signature: $($sig.Status)"
              exit 1
            }
          }

          Write-Host "NSIS installer is properly signed!"

      # Upload artifacts
      - name: Upload Windows NSIS
        if: matrix.os == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: Seren-Desktop-${{ matrix.name }}.exe
          path: src-tauri/target/${{ matrix.target }}/release/bundle/nsis/*.exe

      - name: Upload Linux DEB
        if: startsWith(matrix.os, 'ubuntu')
        uses: actions/upload-artifact@v4
        with:
          name: Seren-Desktop-${{ matrix.name }}.deb
          path: src-tauri/target/${{ matrix.target }}/release/bundle/deb/*.deb

      - name: Upload Linux AppImage
        if: startsWith(matrix.os, 'ubuntu')
        uses: actions/upload-artifact@v4
        with:
          name: Seren-Desktop-${{ matrix.name }}.AppImage
          path: src-tauri/target/${{ matrix.target }}/release/bundle/appimage/*.AppImage

      # Rename macOS updater artifacts to include architecture so both can coexist
      # in the same GitHub release (both aarch64 and x86_64 generate "SerenDesktop.app.tar.gz")
      - name: Rename macOS updater artifacts per architecture
        if: matrix.os == 'macos-latest'
        shell: bash
        run: |
          BUNDLE_DIR="src-tauri/target/${{ matrix.target }}/release/bundle/macos"
          if [ ! -d "$BUNDLE_DIR" ]; then
            echo "No macos bundle directory found"
            exit 0
          fi

          case "${{ matrix.target }}" in
            aarch64-apple-darwin) ARCH="aarch64" ;;
            x86_64-apple-darwin) ARCH="x64" ;;
            *) echo "Unknown macOS target: ${{ matrix.target }}"; exit 1 ;;
          esac

          if [ -f "$BUNDLE_DIR/SerenDesktop.app.tar.gz" ]; then
            mv "$BUNDLE_DIR/SerenDesktop.app.tar.gz" "$BUNDLE_DIR/SerenDesktop_${ARCH}.app.tar.gz"
            echo "Renamed: SerenDesktop.app.tar.gz -> SerenDesktop_${ARCH}.app.tar.gz"
          fi

          if [ -f "$BUNDLE_DIR/SerenDesktop.app.tar.gz.sig" ]; then
            mv "$BUNDLE_DIR/SerenDesktop.app.tar.gz.sig" "$BUNDLE_DIR/SerenDesktop_${ARCH}.app.tar.gz.sig"
            echo "Renamed: SerenDesktop.app.tar.gz.sig -> SerenDesktop_${ARCH}.app.tar.gz.sig"
          fi

          echo "Files in $BUNDLE_DIR:"
          ls -la "$BUNDLE_DIR/" || true

      # Upload updater artifacts (tar.gz/zip bundles + signatures)
      - name: Upload macOS updater bundle
        if: matrix.os == 'macos-latest'
        uses: actions/upload-artifact@v4
        with:
          name: update-${{ matrix.updater_platform }}
          path: |
            src-tauri/target/${{ matrix.target }}/release/bundle/macos/*.tar.gz
            src-tauri/target/${{ matrix.target }}/release/bundle/macos/*.tar.gz.sig
          if-no-files-found: warn

      - name: Upload Windows updater bundle
        if: matrix.os == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: update-${{ matrix.updater_platform }}
          path: |
            src-tauri/target/${{ matrix.target }}/release/bundle/nsis/*.nsis.zip
            src-tauri/target/${{ matrix.target }}/release/bundle/nsis/*.nsis.zip.sig
          if-no-files-found: warn

      - name: Upload Linux updater bundle
        if: startsWith(matrix.os, 'ubuntu')
        uses: actions/upload-artifact@v4
        with:
          name: update-${{ matrix.updater_platform }}
          path: |
            src-tauri/target/${{ matrix.target }}/release/bundle/appimage/*.tar.gz
            src-tauri/target/${{ matrix.target }}/release/bundle/appimage/*.tar.gz.sig
          if-no-files-found: warn

      # Clean up macOS keychain (only if we created one)
      - name: Cleanup macOS keychain
        if: matrix.os == 'macos-latest' && env.HAS_APPLE_SIGNING == 'true' && always()
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true

  publish-release:
    needs: [create-release, build]
    runs-on: ubuntu-latest
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Display structure of downloaded files
        run: ls -R artifacts

      - name: Setup AWS CLI for R2
        run: |
          pip install awscli

      - name: Verify GitHub release exists before R2 upload
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ github.ref_name }}"
          echo "Verifying GitHub release exists for $TAG..."

          # Check if release exists and is published
          RELEASE_INFO=$(gh api repos/${{ github.repository }}/releases/tags/$TAG 2>&1)

          if [ $? -ne 0 ]; then
            echo "ERROR: GitHub release for $TAG does not exist!"
            echo "Cannot upload to R2 without a valid GitHub release."
            echo "Release details: $RELEASE_INFO"
            exit 1
          fi

          # Check if release is published (not draft)
          IS_DRAFT=$(echo "$RELEASE_INFO" | jq -r '.draft')
          if [ "$IS_DRAFT" = "true" ]; then
            echo "ERROR: GitHub release for $TAG is still a draft!"
            echo "Publish the release before R2 artifacts are uploaded."
            exit 1
          fi

          echo "✓ GitHub release verified: $TAG is published"

      - name: Upload updater artifacts to R2
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          AWS_ENDPOINT_URL: ${{ secrets.R2_ENDPOINT }}
          R2_BUCKET: ${{ secrets.R2_BUCKET_NAME }}
        run: |
          TAG="${{ github.ref_name }}"

          # Upload all updater artifacts to R2 under version directory
          for platform_dir in artifacts/update-*; do
            if [ -d "$platform_dir" ]; then
              platform=$(basename "$platform_dir" | sed 's/update-//')
              echo "Uploading $platform artifacts..."

              for file in "$platform_dir"/*; do
                if [ -f "$file" ]; then
                  filename=$(basename "$file")
                  aws s3 cp "$file" "s3://${R2_BUCKET}/${TAG}/${filename}" \
                    --endpoint-url="${AWS_ENDPOINT_URL}"
                  echo "Uploaded: ${TAG}/${filename}"
                fi
              done
            fi
          done

      - name: Generate latest.json for updater (R2)
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const tag = '${{ github.ref_name }}';
            const version = tag.replace(/^v/, '');
            const baseUrl = '${{ secrets.R2_PUBLIC_URL }}/' + tag;

            // Platform mapping: artifact dir name -> Tauri updater platform key
            const platforms = [
              'darwin-aarch64',
              'darwin-x86_64',
              'windows-x86_64',
              'linux-x86_64'
            ];

            const manifest = {
              version,
              notes: `Release ${tag}`,
              pub_date: new Date().toISOString(),
              platforms: {}
            };

            for (const platform of platforms) {
              const dir = path.join('artifacts', `update-${platform}`);
              if (!fs.existsSync(dir)) {
                console.log(`No update artifact for ${platform}, skipping`);
                continue;
              }

              const files = fs.readdirSync(dir);
              const sigFile = files.find(f => f.endsWith('.sig'));
              const bundleFile = files.find(f => !f.endsWith('.sig'));

              if (!sigFile || !bundleFile) {
                console.log(`Missing sig or bundle for ${platform}: sig=${sigFile}, bundle=${bundleFile}`);
                continue;
              }

              const signature = fs.readFileSync(path.join(dir, sigFile), 'utf8').trim();

              manifest.platforms[platform] = {
                signature,
                url: `${baseUrl}/${bundleFile}`
              };

              console.log(`Added platform ${platform}: ${bundleFile}`);
            }

            fs.writeFileSync('artifacts/latest.json', JSON.stringify(manifest, null, 2));
            console.log('Generated latest.json:', JSON.stringify(manifest, null, 2));

      - name: Upload latest.json to R2
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          AWS_ENDPOINT_URL: ${{ secrets.R2_ENDPOINT }}
          R2_BUCKET: ${{ secrets.R2_BUCKET_NAME }}
        run: |
          # Upload latest.json to root of bucket
          aws s3 cp artifacts/latest.json "s3://${R2_BUCKET}/latest.json" \
            --endpoint-url="${AWS_ENDPOINT_URL}" \
            --content-type "application/json"
          echo "Uploaded latest.json to R2"

      - name: Upload installer files to R2
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          AWS_ENDPOINT_URL: ${{ secrets.R2_ENDPOINT }}
          R2_BUCKET: ${{ secrets.R2_BUCKET_NAME }}
        run: |
          TAG="${{ github.ref_name }}"

          # Upload DMG files (macOS installers)
          find artifacts -name "*.dmg" -type f | while read file; do
            filename=$(basename "$file")
            # Upload to versioned path
            aws s3 cp "$file" "s3://${R2_BUCKET}/${TAG}/${filename}" \
              --endpoint-url="${AWS_ENDPOINT_URL}" \
              --content-type "application/x-apple-diskimage"
            # Upload to latest path with versioned filename
            aws s3 cp "$file" "s3://${R2_BUCKET}/latest/${filename}" \
              --endpoint-url="${AWS_ENDPOINT_URL}" \
              --content-type "application/x-apple-diskimage"

            # Create version-less symlink for easier linking
            if echo "$filename" | grep -q "aarch64"; then
              aws s3 cp "$file" "s3://${R2_BUCKET}/latest/SerenDesktop_aarch64.dmg" \
                --endpoint-url="${AWS_ENDPOINT_URL}" \
                --content-type "application/x-apple-diskimage"
            elif echo "$filename" | grep -q "x64"; then
              aws s3 cp "$file" "s3://${R2_BUCKET}/latest/SerenDesktop_x64.dmg" \
                --endpoint-url="${AWS_ENDPOINT_URL}" \
                --content-type "application/x-apple-diskimage"
            fi
            echo "Uploaded installer: ${TAG}/${filename} and latest/${filename}"
          done

          # Upload NSIS exe files (Windows installers)
          find artifacts -name "*-setup.exe" -type f | while read file; do
            filename=$(basename "$file")
            # Upload to versioned path
            aws s3 cp "$file" "s3://${R2_BUCKET}/${TAG}/${filename}" \
              --endpoint-url="${AWS_ENDPOINT_URL}" \
              --content-type "application/x-msdownload"
            # Upload to latest path with versioned filename
            aws s3 cp "$file" "s3://${R2_BUCKET}/latest/${filename}" \
              --endpoint-url="${AWS_ENDPOINT_URL}" \
              --content-type "application/x-msdownload"

            # Create version-less symlink for easier linking
            aws s3 cp "$file" "s3://${R2_BUCKET}/latest/SerenDesktop_x64-setup.exe" \
              --endpoint-url="${AWS_ENDPOINT_URL}" \
              --content-type "application/x-msdownload"
            echo "Uploaded installer: ${TAG}/${filename} and latest/${filename}"
          done

          # Upload AppImage files (Linux installers)
          find artifacts -name "*.AppImage" -type f | while read file; do
            filename=$(basename "$file")
            # Upload to versioned path
            aws s3 cp "$file" "s3://${R2_BUCKET}/${TAG}/${filename}" \
              --endpoint-url="${AWS_ENDPOINT_URL}" \
              --content-type "application/x-executable"
            # Upload to latest path with versioned filename
            aws s3 cp "$file" "s3://${R2_BUCKET}/latest/${filename}" \
              --endpoint-url="${AWS_ENDPOINT_URL}" \
              --content-type "application/x-executable"

            # Create version-less symlink for easier linking
            aws s3 cp "$file" "s3://${R2_BUCKET}/latest/SerenDesktop_amd64.AppImage" \
              --endpoint-url="${AWS_ENDPOINT_URL}" \
              --content-type "application/x-executable"
            echo "Uploaded installer: ${TAG}/${filename} and latest/${filename}"
          done

          # Upload DEB files (Linux installers)
          find artifacts -name "*.deb" -type f | while read file; do
            filename=$(basename "$file")
            # Upload to versioned path
            aws s3 cp "$file" "s3://${R2_BUCKET}/${TAG}/${filename}" \
              --endpoint-url="${AWS_ENDPOINT_URL}" \
              --content-type "application/vnd.debian.binary-package"
            # Upload to latest path with versioned filename
            aws s3 cp "$file" "s3://${R2_BUCKET}/latest/${filename}" \
              --endpoint-url="${AWS_ENDPOINT_URL}" \
              --content-type "application/vnd.debian.binary-package"

            # Create version-less symlink for easier linking
            aws s3 cp "$file" "s3://${R2_BUCKET}/latest/SerenDesktop_amd64.deb" \
              --endpoint-url="${AWS_ENDPOINT_URL}" \
              --content-type "application/vnd.debian.binary-package"
            echo "Uploaded installer: ${TAG}/${filename} and latest/${filename}"
          done

      - name: Publish release
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const releaseId = '${{ needs.create-release.outputs.release_id }}';
            const artifactsDir = 'artifacts';

            if (!releaseId) {
              throw new Error('No release ID available - create-release job may have failed');
            }

            console.log(`Publishing to release ID: ${releaseId}`);

            // Get existing assets to avoid duplicates
            const existingAssets = await github.rest.repos.listReleaseAssets({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId
            });
            const existingNames = new Set(existingAssets.data.map(a => a.name));

            // Upload all artifact files (track names to prevent duplicates within this run)
            const uploadAsset = async (filePath, fileName) => {
              if (existingNames.has(fileName)) {
                console.log(`Skipping ${fileName} - already exists`);
                return;
              }
              const content = fs.readFileSync(filePath);
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: releaseId,
                name: fileName,
                data: content
              });
              existingNames.add(fileName);
            };

            // Walk through artifacts directory
            const walkDir = async (dir) => {
              const files = fs.readdirSync(dir);
              for (const file of files) {
                const filePath = path.join(dir, file);
                const stat = fs.statSync(filePath);
                if (stat.isDirectory()) {
                  await walkDir(filePath);
                } else {
                  console.log(`Uploading: ${filePath}`);
                  await uploadAsset(filePath, file);
                }
              }
            };

            await walkDir(artifactsDir);

            // Undraft the release
            console.log('Setting release to published (non-draft)');
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId,
              draft: false
            });

            console.log('Release published successfully!');
