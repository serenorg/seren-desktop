# ABOUTME: Release workflow for building and signing production binaries.
# ABOUTME: Triggers on version tags, signs for macOS/Windows, and notarizes for Apple.

name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

env:
  TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
  TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
  # Signing availability flags (for conditional steps)
  HAS_APPLE_SIGNING: ${{ secrets.APPLE_CERTIFICATE != '' }}
  # SSL.com eSigner cloud signing for Windows EV code signing
  HAS_WINDOWS_SIGNING: ${{ secrets.ES_USERNAME != '' }}

jobs:
  create-release:
    runs-on: ubuntu-latest
    outputs:
      release_id: ${{ steps.set_release_id.outputs.id }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate release notes
        id: release_notes
        run: |
          # Get previous tag
          PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")

          if [ -z "$PREV_TAG" ]; then
            # First release - get all commits
            COMMITS=$(git log --pretty=format:"- %s" --no-merges | head -20)
          else
            # Get commits since previous tag
            COMMITS=$(git log ${PREV_TAG}..HEAD --pretty=format:"- %s" --no-merges)
          fi

          # Create release body by writing commits directly (avoid sed issues with special chars)
          {
            echo "## What's New"
            echo ""
            echo "$COMMITS"
            echo ""
            echo "## Installation"
            echo ""
            echo "Download the appropriate installer for your platform:"
            echo "- **macOS (Apple Silicon)**: \`Seren-Desktop_*_aarch64.dmg\`"
            echo "- **macOS (Intel)**: \`Seren-Desktop_*_x64.dmg\`"
            echo "- **Windows**: \`Seren-Desktop_*_x64-setup.exe\` or \`.msi\`"
            echo "- **Linux**: \`.deb\`"
            echo ""
            echo "## Note"
            echo ""
            echo "This is an alpha release. Windows builds are EV code signed. macOS builds are signed; if notarization is still processing, run: \`xattr -cr /Volumes/SerenDesktop/SerenDesktop.app\`"
          } > release_notes.md

          echo "Generated release notes:"
          cat release_notes.md

      - name: Check for existing release
        id: check_release
        uses: actions/github-script@v7
        with:
          script: |
            const tagName = '${{ github.ref_name }}';
            try {
              const release = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: tagName
              });
              console.log(`Found existing release: ${release.data.id} (draft: ${release.data.draft})`);
              return { exists: true, id: release.data.id, draft: release.data.draft };
            } catch (error) {
              if (error.status === 404) {
                console.log('No existing release found');
                return { exists: false };
              }
              throw error;
            }

      - name: Create Release
        id: create_release
        if: fromJSON(steps.check_release.outputs.result).exists == false
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref_name }}
          release_name: Seren Desktop ${{ github.ref_name }}
          body_path: release_notes.md
          draft: true
          prerelease: false

      - name: Set release ID output
        id: set_release_id
        run: |
          if [ "${{ fromJSON(steps.check_release.outputs.result).exists }}" == "true" ]; then
            echo "id=${{ fromJSON(steps.check_release.outputs.result).id }}" >> $GITHUB_OUTPUT
          else
            echo "id=${{ steps.create_release.outputs.id }}" >> $GITHUB_OUTPUT
          fi

  build:
    needs: create-release
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-latest
            target: aarch64-apple-darwin
            name: macOS-arm64
          - os: macos-latest
            target: x86_64-apple-darwin
            name: macOS-x64
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            name: Windows-x64
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            name: Linux-x64

    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'pnpm'

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: 'src-tauri'

      - name: Install dependencies (Ubuntu)
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf

      - name: Install frontend dependencies
        run: pnpm install

      - name: Prepare embedded runtime (macOS arm64)
        if: matrix.target == 'aarch64-apple-darwin'
        run: pnpm prepare:runtime:darwin-arm64
      - name: Prepare embedded runtime (macOS x64)
        if: matrix.target == 'x86_64-apple-darwin'
        run: pnpm prepare:runtime:darwin-x64
      - name: Prepare embedded runtime (Windows x64)
        if: matrix.target == 'x86_64-pc-windows-msvc'
        run: pnpm prepare:runtime:win32-x64
      - name: Prepare embedded runtime (Linux x64)
        if: matrix.target == 'x86_64-unknown-linux-gnu'
        run: pnpm prepare:runtime:linux-x64

      # macOS: Import certificates and setup keychain (skip if no certificate)
      - name: Import macOS certificates
        if: matrix.os == 'macos-latest' && env.HAS_APPLE_SIGNING == 'true'
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          # Create variables
          CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          # Import certificate from secrets
          echo -n "$APPLE_CERTIFICATE" | base64 --decode > $CERTIFICATE_PATH

          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Import certificate to keychain
          security import $CERTIFICATE_PATH -P "$APPLE_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

      # Build the app (with signing for macOS when certificates available)
      # Note: APPLE_ID/PASSWORD/TEAM_ID removed to prevent Tauri's internal notarization
      # Notarization is handled separately with polling in the "Notarize macOS app" step
      - name: Build Tauri app (signed)
        if: matrix.os == 'macos-latest' && env.HAS_APPLE_SIGNING == 'true'
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: pnpm tauri build --target ${{ matrix.target }}

      # Build the app (unsigned for macOS without certificates, or other platforms)
      - name: Build Tauri app (unsigned, Linux)
        if: matrix.os == 'ubuntu-latest'
        run: pnpm tauri build --target ${{ matrix.target }} --bundles deb
      - name: Build Tauri app (unsigned, other)
        if: matrix.os != 'macos-latest' && matrix.os != 'ubuntu-latest'
        run: pnpm tauri build --target ${{ matrix.target }}
      - name: Build Tauri app (unsigned, macOS without signing)
        if: matrix.os == 'macos-latest' && env.HAS_APPLE_SIGNING != 'true'
        run: pnpm tauri build --target ${{ matrix.target }}

      # Upload macOS DMG immediately (before notarization so we always have an artifact)
      - name: Upload macOS DMG (pre-notarization)
        if: matrix.os == 'macos-latest'
        uses: actions/upload-artifact@v4
        with:
          name: Seren-Desktop-${{ matrix.name }}.dmg
          path: src-tauri/target/${{ matrix.target }}/release/bundle/dmg/*.dmg

      # macOS: Notarize the app (non-blocking - continues even if notarization fails/times out)
      # Uses polling with retries to handle Apple's notary service issues
      - name: Notarize macOS app
        id: notarize
        if: matrix.os == 'macos-latest' && env.HAS_APPLE_SIGNING == 'true'
        continue-on-error: true
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          # Find the DMG file
          DMG_PATH=$(find src-tauri/target/${{ matrix.target }}/release/bundle/dmg -name "*.dmg" | head -1)

          if [ -z "$DMG_PATH" ]; then
            echo "No DMG found"
            exit 1
          fi

          echo "Notarizing $DMG_PATH"

          # Retry logic: 3 submission attempts
          MAX_SUBMISSION_ATTEMPTS=3
          SUBMISSION_ATTEMPT=0
          NOTARIZATION_SUCCESS=false

          while [ $SUBMISSION_ATTEMPT -lt $MAX_SUBMISSION_ATTEMPTS ] && [ "$NOTARIZATION_SUCCESS" = "false" ]; do
            SUBMISSION_ATTEMPT=$((SUBMISSION_ATTEMPT + 1))
            echo "=== Submission attempt $SUBMISSION_ATTEMPT/$MAX_SUBMISSION_ATTEMPTS ==="

            # Submit for notarization
            SUBMIT_OUTPUT=$(xcrun notarytool submit "$DMG_PATH" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_PASSWORD" \
              --team-id "$APPLE_TEAM_ID" \
              --output-format json 2>&1) || true

            echo "Submit output: $SUBMIT_OUTPUT"
            SUBMISSION_ID=$(echo "$SUBMIT_OUTPUT" | grep -o '"id"[[:space:]]*:[[:space:]]*"[^"]*"' | head -1 | sed 's/.*"id"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')

            if [ -z "$SUBMISSION_ID" ]; then
              echo "Failed to get submission ID, retrying in 30 seconds..."
              sleep 30
              continue
            fi

            echo "Submission ID: $SUBMISSION_ID"
            echo "Polling for notarization status..."

            # Poll for status (max 2 hours per attempt = 120 polls * 60 seconds)
            MAX_POLL_ATTEMPTS=120
            POLL_ATTEMPT=0
            POLL_RESULT="timeout"

            while [ $POLL_ATTEMPT -lt $MAX_POLL_ATTEMPTS ]; do
              POLL_ATTEMPT=$((POLL_ATTEMPT + 1))
              echo "Status check $POLL_ATTEMPT/$MAX_POLL_ATTEMPTS (attempt $SUBMISSION_ATTEMPT)..."

              STATUS_OUTPUT=$(xcrun notarytool info "$SUBMISSION_ID" \
                --apple-id "$APPLE_ID" \
                --password "$APPLE_PASSWORD" \
                --team-id "$APPLE_TEAM_ID" \
                --output-format json 2>&1) || true

              # Check for Accepted status
              if echo "$STATUS_OUTPUT" | grep -q '"status"[[:space:]]*:[[:space:]]*"Accepted"'; then
                echo "Notarization accepted!"
                POLL_RESULT="accepted"
                break
              fi

              # Check for Invalid/Rejected status (don't retry these - they need fixes)
              if echo "$STATUS_OUTPUT" | grep -q '"status"[[:space:]]*:[[:space:]]*"Invalid"'; then
                echo "Notarization failed - Invalid"
                xcrun notarytool log "$SUBMISSION_ID" \
                  --apple-id "$APPLE_ID" \
                  --password "$APPLE_PASSWORD" \
                  --team-id "$APPLE_TEAM_ID" || true
                POLL_RESULT="rejected"
                break
              fi

              if echo "$STATUS_OUTPUT" | grep -q '"status"[[:space:]]*:[[:space:]]*"Rejected"'; then
                echo "Notarization rejected"
                xcrun notarytool log "$SUBMISSION_ID" \
                  --apple-id "$APPLE_ID" \
                  --password "$APPLE_PASSWORD" \
                  --team-id "$APPLE_TEAM_ID" || true
                POLL_RESULT="rejected"
                break
              fi

              # Still in progress, wait 60 seconds
              sleep 60
            done

            if [ "$POLL_RESULT" = "accepted" ]; then
              NOTARIZATION_SUCCESS=true
            elif [ "$POLL_RESULT" = "rejected" ]; then
              # Don't retry rejections - they need code fixes
              echo "Notarization was rejected by Apple - not retrying"
              exit 1
            else
              echo "Polling timed out after 2 hours, will retry submission..."
              sleep 60
            fi
          done

          if [ "$NOTARIZATION_SUCCESS" = "false" ]; then
            echo "Notarization failed after $MAX_SUBMISSION_ATTEMPTS attempts"
            exit 1
          fi

          # Staple the notarization ticket
          echo "Stapling notarization ticket..."
          xcrun stapler staple "$DMG_PATH"
          echo "Notarization and stapling complete!"

      # Upload notarized DMG if notarization succeeded (overwrites the pre-notarization artifact)
      - name: Upload macOS DMG (notarized)
        if: matrix.os == 'macos-latest' && steps.notarize.outcome == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: Seren-Desktop-${{ matrix.name }}.dmg
          path: src-tauri/target/${{ matrix.target }}/release/bundle/dmg/*.dmg
          overwrite: true

      # Windows: Sign executables with SSL.com eSigner (cloud EV code signing)
      # Sign NSIS installer (.exe)
      - name: Sign Windows NSIS installer
        if: matrix.os == 'windows-latest' && env.HAS_WINDOWS_SIGNING == 'true'
        uses: sslcom/esigner-codesign@v1.3.0
        with:
          command: batch_sign
          username: ${{ secrets.ES_USERNAME }}
          password: ${{ secrets.ES_PASSWORD }}
          credential_id: ${{ secrets.ES_CREDENTIAL_ID }}
          totp_secret: ${{ secrets.ES_TOTP_SECRET }}
          dir_path: src-tauri/target/${{ matrix.target }}/release/bundle/nsis
          environment_name: PROD
          malware_block: true
          override: true

      # Sign MSI installer
      - name: Sign Windows MSI installer
        if: matrix.os == 'windows-latest' && env.HAS_WINDOWS_SIGNING == 'true'
        uses: sslcom/esigner-codesign@v1.3.0
        with:
          command: batch_sign
          username: ${{ secrets.ES_USERNAME }}
          password: ${{ secrets.ES_PASSWORD }}
          credential_id: ${{ secrets.ES_CREDENTIAL_ID }}
          totp_secret: ${{ secrets.ES_TOTP_SECRET }}
          dir_path: src-tauri/target/${{ matrix.target }}/release/bundle/msi
          environment_name: PROD
          malware_block: true
          override: true

      # Verify Windows code signing
      - name: Verify Windows code signing
        if: matrix.os == 'windows-latest' && env.HAS_WINDOWS_SIGNING == 'true'
        shell: pwsh
        run: |
          Write-Host "Verifying code signatures..."

          # Verify NSIS installer
          $nsisFiles = Get-ChildItem -Path "src-tauri/target/${{ matrix.target }}/release/bundle/nsis" -Filter "*.exe"
          foreach ($file in $nsisFiles) {
            Write-Host "Checking signature for: $($file.FullName)"
            $sig = Get-AuthenticodeSignature -FilePath $file.FullName
            if ($sig.Status -eq "Valid") {
              Write-Host "✓ Valid signature: $($sig.SignerCertificate.Subject)"
            } else {
              Write-Host "✗ Invalid or missing signature: $($sig.Status)"
              exit 1
            }
          }

          # Verify MSI installer
          $msiFiles = Get-ChildItem -Path "src-tauri/target/${{ matrix.target }}/release/bundle/msi" -Filter "*.msi"
          foreach ($file in $msiFiles) {
            Write-Host "Checking signature for: $($file.FullName)"
            $sig = Get-AuthenticodeSignature -FilePath $file.FullName
            if ($sig.Status -eq "Valid") {
              Write-Host "✓ Valid signature: $($sig.SignerCertificate.Subject)"
            } else {
              Write-Host "✗ Invalid or missing signature: $($sig.Status)"
              exit 1
            }
          }

          Write-Host "All Windows installers are properly signed!"

      # Upload artifacts
      - name: Upload Windows NSIS
        if: matrix.os == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: Seren-Desktop-${{ matrix.name }}.exe
          path: src-tauri/target/${{ matrix.target }}/release/bundle/nsis/*.exe

      - name: Upload Windows MSI
        if: matrix.os == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: Seren-Desktop-${{ matrix.name }}.msi
          path: src-tauri/target/${{ matrix.target }}/release/bundle/msi/*.msi

      - name: Upload Linux DEB
        if: matrix.os == 'ubuntu-latest'
        uses: actions/upload-artifact@v4
        with:
          name: Seren-Desktop-${{ matrix.name }}.deb
          path: src-tauri/target/${{ matrix.target }}/release/bundle/deb/*.deb

      # Clean up macOS keychain (only if we created one)
      - name: Cleanup macOS keychain
        if: matrix.os == 'macos-latest' && env.HAS_APPLE_SIGNING == 'true' && always()
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true

  publish-release:
    needs: [create-release, build]
    runs-on: ubuntu-latest
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Display structure of downloaded files
        run: ls -R artifacts

      - name: Publish release
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const releaseId = '${{ needs.create-release.outputs.release_id }}';
            const artifactsDir = 'artifacts';

            if (!releaseId) {
              throw new Error('No release ID available - create-release job may have failed');
            }

            console.log(`Publishing to release ID: ${releaseId}`);

            // Get existing assets to avoid duplicates
            const existingAssets = await github.rest.repos.listReleaseAssets({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId
            });
            const existingNames = new Set(existingAssets.data.map(a => a.name));

            // Upload all artifact files
            const uploadAsset = async (filePath, fileName) => {
              if (existingNames.has(fileName)) {
                console.log(`Skipping ${fileName} - already exists`);
                return;
              }
              const content = fs.readFileSync(filePath);
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: releaseId,
                name: fileName,
                data: content
              });
            };

            // Walk through artifacts directory
            const walkDir = async (dir) => {
              const files = fs.readdirSync(dir);
              for (const file of files) {
                const filePath = path.join(dir, file);
                const stat = fs.statSync(filePath);
                if (stat.isDirectory()) {
                  await walkDir(filePath);
                } else {
                  console.log(`Uploading: ${filePath}`);
                  await uploadAsset(filePath, file);
                }
              }
            };

            await walkDir(artifactsDir);

            // Undraft the release
            console.log('Setting release to published (non-draft)');
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId,
              draft: false
            });

            console.log('Release published successfully!');
